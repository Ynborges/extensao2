
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model PerfilEstudante
 * 
 */
export type PerfilEstudante = $Result.DefaultSelection<Prisma.$PerfilEstudantePayload>
/**
 * Model PerfilInstituicao
 * 
 */
export type PerfilInstituicao = $Result.DefaultSelection<Prisma.$PerfilInstituicaoPayload>
/**
 * Model CategoriaCurso
 * 
 */
export type CategoriaCurso = $Result.DefaultSelection<Prisma.$CategoriaCursoPayload>
/**
 * Model Curso
 * 
 */
export type Curso = $Result.DefaultSelection<Prisma.$CursoPayload>
/**
 * Model CursoCategoria
 * 
 */
export type CursoCategoria = $Result.DefaultSelection<Prisma.$CursoCategoriaPayload>
/**
 * Model Oportunidade
 * 
 */
export type Oportunidade = $Result.DefaultSelection<Prisma.$OportunidadePayload>
/**
 * Model PostagemBlog
 * 
 */
export type PostagemBlog = $Result.DefaultSelection<Prisma.$PostagemBlogPayload>
/**
 * Model Matricula
 * 
 */
export type Matricula = $Result.DefaultSelection<Prisma.$MatriculaPayload>
/**
 * Model Candidatura
 * 
 */
export type Candidatura = $Result.DefaultSelection<Prisma.$CandidaturaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserTypeEnum: {
  estudante: 'estudante',
  instituicao: 'instituicao',
  admin: 'admin'
};

export type UserTypeEnum = (typeof UserTypeEnum)[keyof typeof UserTypeEnum]


export const CourseModalityEnum: {
  presencial: 'presencial',
  online: 'online'
};

export type CourseModalityEnum = (typeof CourseModalityEnum)[keyof typeof CourseModalityEnum]


export const CourseLevelEnum: {
  iniciante: 'iniciante',
  intermediario: 'intermediario',
  avancado: 'avancado'
};

export type CourseLevelEnum = (typeof CourseLevelEnum)[keyof typeof CourseLevelEnum]

}

export type UserTypeEnum = $Enums.UserTypeEnum

export const UserTypeEnum: typeof $Enums.UserTypeEnum

export type CourseModalityEnum = $Enums.CourseModalityEnum

export const CourseModalityEnum: typeof $Enums.CourseModalityEnum

export type CourseLevelEnum = $Enums.CourseLevelEnum

export const CourseLevelEnum: typeof $Enums.CourseLevelEnum

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.perfilEstudante`: Exposes CRUD operations for the **PerfilEstudante** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerfilEstudantes
    * const perfilEstudantes = await prisma.perfilEstudante.findMany()
    * ```
    */
  get perfilEstudante(): Prisma.PerfilEstudanteDelegate<ExtArgs>;

  /**
   * `prisma.perfilInstituicao`: Exposes CRUD operations for the **PerfilInstituicao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerfilInstituicaos
    * const perfilInstituicaos = await prisma.perfilInstituicao.findMany()
    * ```
    */
  get perfilInstituicao(): Prisma.PerfilInstituicaoDelegate<ExtArgs>;

  /**
   * `prisma.categoriaCurso`: Exposes CRUD operations for the **CategoriaCurso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoriaCursos
    * const categoriaCursos = await prisma.categoriaCurso.findMany()
    * ```
    */
  get categoriaCurso(): Prisma.CategoriaCursoDelegate<ExtArgs>;

  /**
   * `prisma.curso`: Exposes CRUD operations for the **Curso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cursos
    * const cursos = await prisma.curso.findMany()
    * ```
    */
  get curso(): Prisma.CursoDelegate<ExtArgs>;

  /**
   * `prisma.cursoCategoria`: Exposes CRUD operations for the **CursoCategoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CursoCategorias
    * const cursoCategorias = await prisma.cursoCategoria.findMany()
    * ```
    */
  get cursoCategoria(): Prisma.CursoCategoriaDelegate<ExtArgs>;

  /**
   * `prisma.oportunidade`: Exposes CRUD operations for the **Oportunidade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Oportunidades
    * const oportunidades = await prisma.oportunidade.findMany()
    * ```
    */
  get oportunidade(): Prisma.OportunidadeDelegate<ExtArgs>;

  /**
   * `prisma.postagemBlog`: Exposes CRUD operations for the **PostagemBlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostagemBlogs
    * const postagemBlogs = await prisma.postagemBlog.findMany()
    * ```
    */
  get postagemBlog(): Prisma.PostagemBlogDelegate<ExtArgs>;

  /**
   * `prisma.matricula`: Exposes CRUD operations for the **Matricula** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matriculas
    * const matriculas = await prisma.matricula.findMany()
    * ```
    */
  get matricula(): Prisma.MatriculaDelegate<ExtArgs>;

  /**
   * `prisma.candidatura`: Exposes CRUD operations for the **Candidatura** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Candidaturas
    * const candidaturas = await prisma.candidatura.findMany()
    * ```
    */
  get candidatura(): Prisma.CandidaturaDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    PerfilEstudante: 'PerfilEstudante',
    PerfilInstituicao: 'PerfilInstituicao',
    CategoriaCurso: 'CategoriaCurso',
    Curso: 'Curso',
    CursoCategoria: 'CursoCategoria',
    Oportunidade: 'Oportunidade',
    PostagemBlog: 'PostagemBlog',
    Matricula: 'Matricula',
    Candidatura: 'Candidatura'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "usuario" | "perfilEstudante" | "perfilInstituicao" | "categoriaCurso" | "curso" | "cursoCategoria" | "oportunidade" | "postagemBlog" | "matricula" | "candidatura"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      PerfilEstudante: {
        payload: Prisma.$PerfilEstudantePayload<ExtArgs>
        fields: Prisma.PerfilEstudanteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerfilEstudanteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilEstudantePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerfilEstudanteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilEstudantePayload>
          }
          findFirst: {
            args: Prisma.PerfilEstudanteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilEstudantePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerfilEstudanteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilEstudantePayload>
          }
          findMany: {
            args: Prisma.PerfilEstudanteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilEstudantePayload>[]
          }
          create: {
            args: Prisma.PerfilEstudanteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilEstudantePayload>
          }
          createMany: {
            args: Prisma.PerfilEstudanteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerfilEstudanteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilEstudantePayload>[]
          }
          delete: {
            args: Prisma.PerfilEstudanteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilEstudantePayload>
          }
          update: {
            args: Prisma.PerfilEstudanteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilEstudantePayload>
          }
          deleteMany: {
            args: Prisma.PerfilEstudanteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerfilEstudanteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PerfilEstudanteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilEstudantePayload>
          }
          aggregate: {
            args: Prisma.PerfilEstudanteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerfilEstudante>
          }
          groupBy: {
            args: Prisma.PerfilEstudanteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerfilEstudanteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerfilEstudanteCountArgs<ExtArgs>
            result: $Utils.Optional<PerfilEstudanteCountAggregateOutputType> | number
          }
        }
      }
      PerfilInstituicao: {
        payload: Prisma.$PerfilInstituicaoPayload<ExtArgs>
        fields: Prisma.PerfilInstituicaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerfilInstituicaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilInstituicaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerfilInstituicaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilInstituicaoPayload>
          }
          findFirst: {
            args: Prisma.PerfilInstituicaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilInstituicaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerfilInstituicaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilInstituicaoPayload>
          }
          findMany: {
            args: Prisma.PerfilInstituicaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilInstituicaoPayload>[]
          }
          create: {
            args: Prisma.PerfilInstituicaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilInstituicaoPayload>
          }
          createMany: {
            args: Prisma.PerfilInstituicaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerfilInstituicaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilInstituicaoPayload>[]
          }
          delete: {
            args: Prisma.PerfilInstituicaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilInstituicaoPayload>
          }
          update: {
            args: Prisma.PerfilInstituicaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilInstituicaoPayload>
          }
          deleteMany: {
            args: Prisma.PerfilInstituicaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerfilInstituicaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PerfilInstituicaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerfilInstituicaoPayload>
          }
          aggregate: {
            args: Prisma.PerfilInstituicaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerfilInstituicao>
          }
          groupBy: {
            args: Prisma.PerfilInstituicaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerfilInstituicaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerfilInstituicaoCountArgs<ExtArgs>
            result: $Utils.Optional<PerfilInstituicaoCountAggregateOutputType> | number
          }
        }
      }
      CategoriaCurso: {
        payload: Prisma.$CategoriaCursoPayload<ExtArgs>
        fields: Prisma.CategoriaCursoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriaCursoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaCursoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriaCursoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaCursoPayload>
          }
          findFirst: {
            args: Prisma.CategoriaCursoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaCursoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriaCursoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaCursoPayload>
          }
          findMany: {
            args: Prisma.CategoriaCursoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaCursoPayload>[]
          }
          create: {
            args: Prisma.CategoriaCursoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaCursoPayload>
          }
          createMany: {
            args: Prisma.CategoriaCursoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoriaCursoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaCursoPayload>[]
          }
          delete: {
            args: Prisma.CategoriaCursoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaCursoPayload>
          }
          update: {
            args: Prisma.CategoriaCursoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaCursoPayload>
          }
          deleteMany: {
            args: Prisma.CategoriaCursoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriaCursoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoriaCursoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaCursoPayload>
          }
          aggregate: {
            args: Prisma.CategoriaCursoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoriaCurso>
          }
          groupBy: {
            args: Prisma.CategoriaCursoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriaCursoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriaCursoCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriaCursoCountAggregateOutputType> | number
          }
        }
      }
      Curso: {
        payload: Prisma.$CursoPayload<ExtArgs>
        fields: Prisma.CursoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CursoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CursoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          findFirst: {
            args: Prisma.CursoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CursoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          findMany: {
            args: Prisma.CursoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>[]
          }
          create: {
            args: Prisma.CursoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          createMany: {
            args: Prisma.CursoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CursoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>[]
          }
          delete: {
            args: Prisma.CursoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          update: {
            args: Prisma.CursoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          deleteMany: {
            args: Prisma.CursoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CursoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CursoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          aggregate: {
            args: Prisma.CursoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurso>
          }
          groupBy: {
            args: Prisma.CursoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CursoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CursoCountArgs<ExtArgs>
            result: $Utils.Optional<CursoCountAggregateOutputType> | number
          }
        }
      }
      CursoCategoria: {
        payload: Prisma.$CursoCategoriaPayload<ExtArgs>
        fields: Prisma.CursoCategoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CursoCategoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoCategoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CursoCategoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoCategoriaPayload>
          }
          findFirst: {
            args: Prisma.CursoCategoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoCategoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CursoCategoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoCategoriaPayload>
          }
          findMany: {
            args: Prisma.CursoCategoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoCategoriaPayload>[]
          }
          create: {
            args: Prisma.CursoCategoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoCategoriaPayload>
          }
          createMany: {
            args: Prisma.CursoCategoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CursoCategoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoCategoriaPayload>[]
          }
          delete: {
            args: Prisma.CursoCategoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoCategoriaPayload>
          }
          update: {
            args: Prisma.CursoCategoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoCategoriaPayload>
          }
          deleteMany: {
            args: Prisma.CursoCategoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CursoCategoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CursoCategoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoCategoriaPayload>
          }
          aggregate: {
            args: Prisma.CursoCategoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCursoCategoria>
          }
          groupBy: {
            args: Prisma.CursoCategoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CursoCategoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CursoCategoriaCountArgs<ExtArgs>
            result: $Utils.Optional<CursoCategoriaCountAggregateOutputType> | number
          }
        }
      }
      Oportunidade: {
        payload: Prisma.$OportunidadePayload<ExtArgs>
        fields: Prisma.OportunidadeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OportunidadeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OportunidadePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OportunidadeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OportunidadePayload>
          }
          findFirst: {
            args: Prisma.OportunidadeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OportunidadePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OportunidadeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OportunidadePayload>
          }
          findMany: {
            args: Prisma.OportunidadeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OportunidadePayload>[]
          }
          create: {
            args: Prisma.OportunidadeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OportunidadePayload>
          }
          createMany: {
            args: Prisma.OportunidadeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OportunidadeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OportunidadePayload>[]
          }
          delete: {
            args: Prisma.OportunidadeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OportunidadePayload>
          }
          update: {
            args: Prisma.OportunidadeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OportunidadePayload>
          }
          deleteMany: {
            args: Prisma.OportunidadeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OportunidadeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OportunidadeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OportunidadePayload>
          }
          aggregate: {
            args: Prisma.OportunidadeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOportunidade>
          }
          groupBy: {
            args: Prisma.OportunidadeGroupByArgs<ExtArgs>
            result: $Utils.Optional<OportunidadeGroupByOutputType>[]
          }
          count: {
            args: Prisma.OportunidadeCountArgs<ExtArgs>
            result: $Utils.Optional<OportunidadeCountAggregateOutputType> | number
          }
        }
      }
      PostagemBlog: {
        payload: Prisma.$PostagemBlogPayload<ExtArgs>
        fields: Prisma.PostagemBlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostagemBlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostagemBlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostagemBlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostagemBlogPayload>
          }
          findFirst: {
            args: Prisma.PostagemBlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostagemBlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostagemBlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostagemBlogPayload>
          }
          findMany: {
            args: Prisma.PostagemBlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostagemBlogPayload>[]
          }
          create: {
            args: Prisma.PostagemBlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostagemBlogPayload>
          }
          createMany: {
            args: Prisma.PostagemBlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostagemBlogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostagemBlogPayload>[]
          }
          delete: {
            args: Prisma.PostagemBlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostagemBlogPayload>
          }
          update: {
            args: Prisma.PostagemBlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostagemBlogPayload>
          }
          deleteMany: {
            args: Prisma.PostagemBlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostagemBlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostagemBlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostagemBlogPayload>
          }
          aggregate: {
            args: Prisma.PostagemBlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostagemBlog>
          }
          groupBy: {
            args: Prisma.PostagemBlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostagemBlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostagemBlogCountArgs<ExtArgs>
            result: $Utils.Optional<PostagemBlogCountAggregateOutputType> | number
          }
        }
      }
      Matricula: {
        payload: Prisma.$MatriculaPayload<ExtArgs>
        fields: Prisma.MatriculaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatriculaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatriculaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>
          }
          findFirst: {
            args: Prisma.MatriculaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatriculaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>
          }
          findMany: {
            args: Prisma.MatriculaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>[]
          }
          create: {
            args: Prisma.MatriculaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>
          }
          createMany: {
            args: Prisma.MatriculaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatriculaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>[]
          }
          delete: {
            args: Prisma.MatriculaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>
          }
          update: {
            args: Prisma.MatriculaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>
          }
          deleteMany: {
            args: Prisma.MatriculaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatriculaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatriculaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatriculaPayload>
          }
          aggregate: {
            args: Prisma.MatriculaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatricula>
          }
          groupBy: {
            args: Prisma.MatriculaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatriculaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatriculaCountArgs<ExtArgs>
            result: $Utils.Optional<MatriculaCountAggregateOutputType> | number
          }
        }
      }
      Candidatura: {
        payload: Prisma.$CandidaturaPayload<ExtArgs>
        fields: Prisma.CandidaturaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CandidaturaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidaturaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CandidaturaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidaturaPayload>
          }
          findFirst: {
            args: Prisma.CandidaturaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidaturaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CandidaturaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidaturaPayload>
          }
          findMany: {
            args: Prisma.CandidaturaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidaturaPayload>[]
          }
          create: {
            args: Prisma.CandidaturaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidaturaPayload>
          }
          createMany: {
            args: Prisma.CandidaturaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CandidaturaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidaturaPayload>[]
          }
          delete: {
            args: Prisma.CandidaturaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidaturaPayload>
          }
          update: {
            args: Prisma.CandidaturaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidaturaPayload>
          }
          deleteMany: {
            args: Prisma.CandidaturaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CandidaturaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CandidaturaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidaturaPayload>
          }
          aggregate: {
            args: Prisma.CandidaturaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCandidatura>
          }
          groupBy: {
            args: Prisma.CandidaturaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CandidaturaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CandidaturaCountArgs<ExtArgs>
            result: $Utils.Optional<CandidaturaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    postagensBlog: number
    matriculas: number
    candidaturas: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    postagensBlog?: boolean | UsuarioCountOutputTypeCountPostagensBlogArgs
    matriculas?: boolean | UsuarioCountOutputTypeCountMatriculasArgs
    candidaturas?: boolean | UsuarioCountOutputTypeCountCandidaturasArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPostagensBlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostagemBlogWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountMatriculasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatriculaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountCandidaturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidaturaWhereInput
  }


  /**
   * Count Type PerfilInstituicaoCountOutputType
   */

  export type PerfilInstituicaoCountOutputType = {
    cursos: number
    oportunidades: number
  }

  export type PerfilInstituicaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | PerfilInstituicaoCountOutputTypeCountCursosArgs
    oportunidades?: boolean | PerfilInstituicaoCountOutputTypeCountOportunidadesArgs
  }

  // Custom InputTypes
  /**
   * PerfilInstituicaoCountOutputType without action
   */
  export type PerfilInstituicaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilInstituicaoCountOutputType
     */
    select?: PerfilInstituicaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PerfilInstituicaoCountOutputType without action
   */
  export type PerfilInstituicaoCountOutputTypeCountCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoWhereInput
  }

  /**
   * PerfilInstituicaoCountOutputType without action
   */
  export type PerfilInstituicaoCountOutputTypeCountOportunidadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OportunidadeWhereInput
  }


  /**
   * Count Type CategoriaCursoCountOutputType
   */

  export type CategoriaCursoCountOutputType = {
    cursos: number
    oportunidadesRelacionadas: number
  }

  export type CategoriaCursoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | CategoriaCursoCountOutputTypeCountCursosArgs
    oportunidadesRelacionadas?: boolean | CategoriaCursoCountOutputTypeCountOportunidadesRelacionadasArgs
  }

  // Custom InputTypes
  /**
   * CategoriaCursoCountOutputType without action
   */
  export type CategoriaCursoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCursoCountOutputType
     */
    select?: CategoriaCursoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriaCursoCountOutputType without action
   */
  export type CategoriaCursoCountOutputTypeCountCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoCategoriaWhereInput
  }

  /**
   * CategoriaCursoCountOutputType without action
   */
  export type CategoriaCursoCountOutputTypeCountOportunidadesRelacionadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OportunidadeWhereInput
  }


  /**
   * Count Type CursoCountOutputType
   */

  export type CursoCountOutputType = {
    categorias: number
    matriculas: number
  }

  export type CursoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categorias?: boolean | CursoCountOutputTypeCountCategoriasArgs
    matriculas?: boolean | CursoCountOutputTypeCountMatriculasArgs
  }

  // Custom InputTypes
  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCountOutputType
     */
    select?: CursoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeCountCategoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoCategoriaWhereInput
  }

  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeCountMatriculasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatriculaWhereInput
  }


  /**
   * Count Type OportunidadeCountOutputType
   */

  export type OportunidadeCountOutputType = {
    candidaturas: number
  }

  export type OportunidadeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidaturas?: boolean | OportunidadeCountOutputTypeCountCandidaturasArgs
  }

  // Custom InputTypes
  /**
   * OportunidadeCountOutputType without action
   */
  export type OportunidadeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OportunidadeCountOutputType
     */
    select?: OportunidadeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OportunidadeCountOutputType without action
   */
  export type OportunidadeCountOutputTypeCountCandidaturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidaturaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: bigint | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: bigint | null
    publicId: string | null
    nomeCompleto: string | null
    email: string | null
    senha: string | null
    tipoUsuario: $Enums.UserTypeEnum | null
    emailConfirmado: boolean | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: bigint | null
    publicId: string | null
    nomeCompleto: string | null
    email: string | null
    senha: string | null
    tipoUsuario: $Enums.UserTypeEnum | null
    emailConfirmado: boolean | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    publicId: number
    nomeCompleto: number
    email: number
    senha: number
    tipoUsuario: number
    emailConfirmado: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    publicId?: true
    nomeCompleto?: true
    email?: true
    senha?: true
    tipoUsuario?: true
    emailConfirmado?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    publicId?: true
    nomeCompleto?: true
    email?: true
    senha?: true
    tipoUsuario?: true
    emailConfirmado?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    publicId?: true
    nomeCompleto?: true
    email?: true
    senha?: true
    tipoUsuario?: true
    emailConfirmado?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: bigint
    publicId: string
    nomeCompleto: string
    email: string
    senha: string
    tipoUsuario: $Enums.UserTypeEnum
    emailConfirmado: boolean
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    nomeCompleto?: boolean
    email?: boolean
    senha?: boolean
    tipoUsuario?: boolean
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    perfilEstudante?: boolean | Usuario$perfilEstudanteArgs<ExtArgs>
    perfilInstituicao?: boolean | Usuario$perfilInstituicaoArgs<ExtArgs>
    postagensBlog?: boolean | Usuario$postagensBlogArgs<ExtArgs>
    matriculas?: boolean | Usuario$matriculasArgs<ExtArgs>
    candidaturas?: boolean | Usuario$candidaturasArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicId?: boolean
    nomeCompleto?: boolean
    email?: boolean
    senha?: boolean
    tipoUsuario?: boolean
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    publicId?: boolean
    nomeCompleto?: boolean
    email?: boolean
    senha?: boolean
    tipoUsuario?: boolean
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    perfilEstudante?: boolean | Usuario$perfilEstudanteArgs<ExtArgs>
    perfilInstituicao?: boolean | Usuario$perfilInstituicaoArgs<ExtArgs>
    postagensBlog?: boolean | Usuario$postagensBlogArgs<ExtArgs>
    matriculas?: boolean | Usuario$matriculasArgs<ExtArgs>
    candidaturas?: boolean | Usuario$candidaturasArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      perfilEstudante: Prisma.$PerfilEstudantePayload<ExtArgs> | null
      perfilInstituicao: Prisma.$PerfilInstituicaoPayload<ExtArgs> | null
      postagensBlog: Prisma.$PostagemBlogPayload<ExtArgs>[]
      matriculas: Prisma.$MatriculaPayload<ExtArgs>[]
      candidaturas: Prisma.$CandidaturaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      publicId: string
      nomeCompleto: string
      email: string
      senha: string
      tipoUsuario: $Enums.UserTypeEnum
      emailConfirmado: boolean
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    perfilEstudante<T extends Usuario$perfilEstudanteArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$perfilEstudanteArgs<ExtArgs>>): Prisma__PerfilEstudanteClient<$Result.GetResult<Prisma.$PerfilEstudantePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    perfilInstituicao<T extends Usuario$perfilInstituicaoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$perfilInstituicaoArgs<ExtArgs>>): Prisma__PerfilInstituicaoClient<$Result.GetResult<Prisma.$PerfilInstituicaoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    postagensBlog<T extends Usuario$postagensBlogArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$postagensBlogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostagemBlogPayload<ExtArgs>, T, "findMany"> | Null>
    matriculas<T extends Usuario$matriculasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$matriculasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "findMany"> | Null>
    candidaturas<T extends Usuario$candidaturasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$candidaturasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidaturaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'BigInt'>
    readonly publicId: FieldRef<"Usuario", 'String'>
    readonly nomeCompleto: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly senha: FieldRef<"Usuario", 'String'>
    readonly tipoUsuario: FieldRef<"Usuario", 'UserTypeEnum'>
    readonly emailConfirmado: FieldRef<"Usuario", 'Boolean'>
    readonly ativo: FieldRef<"Usuario", 'Boolean'>
    readonly criadoEm: FieldRef<"Usuario", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.perfilEstudante
   */
  export type Usuario$perfilEstudanteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilEstudante
     */
    select?: PerfilEstudanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilEstudanteInclude<ExtArgs> | null
    where?: PerfilEstudanteWhereInput
  }

  /**
   * Usuario.perfilInstituicao
   */
  export type Usuario$perfilInstituicaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilInstituicao
     */
    select?: PerfilInstituicaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilInstituicaoInclude<ExtArgs> | null
    where?: PerfilInstituicaoWhereInput
  }

  /**
   * Usuario.postagensBlog
   */
  export type Usuario$postagensBlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostagemBlog
     */
    select?: PostagemBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostagemBlogInclude<ExtArgs> | null
    where?: PostagemBlogWhereInput
    orderBy?: PostagemBlogOrderByWithRelationInput | PostagemBlogOrderByWithRelationInput[]
    cursor?: PostagemBlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostagemBlogScalarFieldEnum | PostagemBlogScalarFieldEnum[]
  }

  /**
   * Usuario.matriculas
   */
  export type Usuario$matriculasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    where?: MatriculaWhereInput
    orderBy?: MatriculaOrderByWithRelationInput | MatriculaOrderByWithRelationInput[]
    cursor?: MatriculaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatriculaScalarFieldEnum | MatriculaScalarFieldEnum[]
  }

  /**
   * Usuario.candidaturas
   */
  export type Usuario$candidaturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidatura
     */
    select?: CandidaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidaturaInclude<ExtArgs> | null
    where?: CandidaturaWhereInput
    orderBy?: CandidaturaOrderByWithRelationInput | CandidaturaOrderByWithRelationInput[]
    cursor?: CandidaturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CandidaturaScalarFieldEnum | CandidaturaScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model PerfilEstudante
   */

  export type AggregatePerfilEstudante = {
    _count: PerfilEstudanteCountAggregateOutputType | null
    _avg: PerfilEstudanteAvgAggregateOutputType | null
    _sum: PerfilEstudanteSumAggregateOutputType | null
    _min: PerfilEstudanteMinAggregateOutputType | null
    _max: PerfilEstudanteMaxAggregateOutputType | null
  }

  export type PerfilEstudanteAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type PerfilEstudanteSumAggregateOutputType = {
    id: bigint | null
    usuarioId: bigint | null
  }

  export type PerfilEstudanteMinAggregateOutputType = {
    id: bigint | null
    usuarioId: bigint | null
    nomeEscola: string | null
    areaInteressePrincipal: string | null
    urlCurriculo: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type PerfilEstudanteMaxAggregateOutputType = {
    id: bigint | null
    usuarioId: bigint | null
    nomeEscola: string | null
    areaInteressePrincipal: string | null
    urlCurriculo: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type PerfilEstudanteCountAggregateOutputType = {
    id: number
    usuarioId: number
    nomeEscola: number
    areaInteressePrincipal: number
    urlCurriculo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type PerfilEstudanteAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type PerfilEstudanteSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type PerfilEstudanteMinAggregateInputType = {
    id?: true
    usuarioId?: true
    nomeEscola?: true
    areaInteressePrincipal?: true
    urlCurriculo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type PerfilEstudanteMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    nomeEscola?: true
    areaInteressePrincipal?: true
    urlCurriculo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type PerfilEstudanteCountAggregateInputType = {
    id?: true
    usuarioId?: true
    nomeEscola?: true
    areaInteressePrincipal?: true
    urlCurriculo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type PerfilEstudanteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerfilEstudante to aggregate.
     */
    where?: PerfilEstudanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerfilEstudantes to fetch.
     */
    orderBy?: PerfilEstudanteOrderByWithRelationInput | PerfilEstudanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerfilEstudanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerfilEstudantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerfilEstudantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerfilEstudantes
    **/
    _count?: true | PerfilEstudanteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerfilEstudanteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerfilEstudanteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerfilEstudanteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerfilEstudanteMaxAggregateInputType
  }

  export type GetPerfilEstudanteAggregateType<T extends PerfilEstudanteAggregateArgs> = {
        [P in keyof T & keyof AggregatePerfilEstudante]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerfilEstudante[P]>
      : GetScalarType<T[P], AggregatePerfilEstudante[P]>
  }




  export type PerfilEstudanteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerfilEstudanteWhereInput
    orderBy?: PerfilEstudanteOrderByWithAggregationInput | PerfilEstudanteOrderByWithAggregationInput[]
    by: PerfilEstudanteScalarFieldEnum[] | PerfilEstudanteScalarFieldEnum
    having?: PerfilEstudanteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerfilEstudanteCountAggregateInputType | true
    _avg?: PerfilEstudanteAvgAggregateInputType
    _sum?: PerfilEstudanteSumAggregateInputType
    _min?: PerfilEstudanteMinAggregateInputType
    _max?: PerfilEstudanteMaxAggregateInputType
  }

  export type PerfilEstudanteGroupByOutputType = {
    id: bigint
    usuarioId: bigint
    nomeEscola: string
    areaInteressePrincipal: string
    urlCurriculo: string | null
    criadoEm: Date
    atualizadoEm: Date
    _count: PerfilEstudanteCountAggregateOutputType | null
    _avg: PerfilEstudanteAvgAggregateOutputType | null
    _sum: PerfilEstudanteSumAggregateOutputType | null
    _min: PerfilEstudanteMinAggregateOutputType | null
    _max: PerfilEstudanteMaxAggregateOutputType | null
  }

  type GetPerfilEstudanteGroupByPayload<T extends PerfilEstudanteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerfilEstudanteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerfilEstudanteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerfilEstudanteGroupByOutputType[P]>
            : GetScalarType<T[P], PerfilEstudanteGroupByOutputType[P]>
        }
      >
    >


  export type PerfilEstudanteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    nomeEscola?: boolean
    areaInteressePrincipal?: boolean
    urlCurriculo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["perfilEstudante"]>

  export type PerfilEstudanteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    nomeEscola?: boolean
    areaInteressePrincipal?: boolean
    urlCurriculo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["perfilEstudante"]>

  export type PerfilEstudanteSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    nomeEscola?: boolean
    areaInteressePrincipal?: boolean
    urlCurriculo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type PerfilEstudanteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type PerfilEstudanteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $PerfilEstudantePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerfilEstudante"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      usuarioId: bigint
      nomeEscola: string
      areaInteressePrincipal: string
      urlCurriculo: string | null
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["perfilEstudante"]>
    composites: {}
  }

  type PerfilEstudanteGetPayload<S extends boolean | null | undefined | PerfilEstudanteDefaultArgs> = $Result.GetResult<Prisma.$PerfilEstudantePayload, S>

  type PerfilEstudanteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PerfilEstudanteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PerfilEstudanteCountAggregateInputType | true
    }

  export interface PerfilEstudanteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerfilEstudante'], meta: { name: 'PerfilEstudante' } }
    /**
     * Find zero or one PerfilEstudante that matches the filter.
     * @param {PerfilEstudanteFindUniqueArgs} args - Arguments to find a PerfilEstudante
     * @example
     * // Get one PerfilEstudante
     * const perfilEstudante = await prisma.perfilEstudante.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerfilEstudanteFindUniqueArgs>(args: SelectSubset<T, PerfilEstudanteFindUniqueArgs<ExtArgs>>): Prisma__PerfilEstudanteClient<$Result.GetResult<Prisma.$PerfilEstudantePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PerfilEstudante that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PerfilEstudanteFindUniqueOrThrowArgs} args - Arguments to find a PerfilEstudante
     * @example
     * // Get one PerfilEstudante
     * const perfilEstudante = await prisma.perfilEstudante.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerfilEstudanteFindUniqueOrThrowArgs>(args: SelectSubset<T, PerfilEstudanteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerfilEstudanteClient<$Result.GetResult<Prisma.$PerfilEstudantePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PerfilEstudante that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilEstudanteFindFirstArgs} args - Arguments to find a PerfilEstudante
     * @example
     * // Get one PerfilEstudante
     * const perfilEstudante = await prisma.perfilEstudante.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerfilEstudanteFindFirstArgs>(args?: SelectSubset<T, PerfilEstudanteFindFirstArgs<ExtArgs>>): Prisma__PerfilEstudanteClient<$Result.GetResult<Prisma.$PerfilEstudantePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PerfilEstudante that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilEstudanteFindFirstOrThrowArgs} args - Arguments to find a PerfilEstudante
     * @example
     * // Get one PerfilEstudante
     * const perfilEstudante = await prisma.perfilEstudante.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerfilEstudanteFindFirstOrThrowArgs>(args?: SelectSubset<T, PerfilEstudanteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerfilEstudanteClient<$Result.GetResult<Prisma.$PerfilEstudantePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PerfilEstudantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilEstudanteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerfilEstudantes
     * const perfilEstudantes = await prisma.perfilEstudante.findMany()
     * 
     * // Get first 10 PerfilEstudantes
     * const perfilEstudantes = await prisma.perfilEstudante.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const perfilEstudanteWithIdOnly = await prisma.perfilEstudante.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerfilEstudanteFindManyArgs>(args?: SelectSubset<T, PerfilEstudanteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerfilEstudantePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PerfilEstudante.
     * @param {PerfilEstudanteCreateArgs} args - Arguments to create a PerfilEstudante.
     * @example
     * // Create one PerfilEstudante
     * const PerfilEstudante = await prisma.perfilEstudante.create({
     *   data: {
     *     // ... data to create a PerfilEstudante
     *   }
     * })
     * 
     */
    create<T extends PerfilEstudanteCreateArgs>(args: SelectSubset<T, PerfilEstudanteCreateArgs<ExtArgs>>): Prisma__PerfilEstudanteClient<$Result.GetResult<Prisma.$PerfilEstudantePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PerfilEstudantes.
     * @param {PerfilEstudanteCreateManyArgs} args - Arguments to create many PerfilEstudantes.
     * @example
     * // Create many PerfilEstudantes
     * const perfilEstudante = await prisma.perfilEstudante.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerfilEstudanteCreateManyArgs>(args?: SelectSubset<T, PerfilEstudanteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerfilEstudantes and returns the data saved in the database.
     * @param {PerfilEstudanteCreateManyAndReturnArgs} args - Arguments to create many PerfilEstudantes.
     * @example
     * // Create many PerfilEstudantes
     * const perfilEstudante = await prisma.perfilEstudante.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerfilEstudantes and only return the `id`
     * const perfilEstudanteWithIdOnly = await prisma.perfilEstudante.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerfilEstudanteCreateManyAndReturnArgs>(args?: SelectSubset<T, PerfilEstudanteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerfilEstudantePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PerfilEstudante.
     * @param {PerfilEstudanteDeleteArgs} args - Arguments to delete one PerfilEstudante.
     * @example
     * // Delete one PerfilEstudante
     * const PerfilEstudante = await prisma.perfilEstudante.delete({
     *   where: {
     *     // ... filter to delete one PerfilEstudante
     *   }
     * })
     * 
     */
    delete<T extends PerfilEstudanteDeleteArgs>(args: SelectSubset<T, PerfilEstudanteDeleteArgs<ExtArgs>>): Prisma__PerfilEstudanteClient<$Result.GetResult<Prisma.$PerfilEstudantePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PerfilEstudante.
     * @param {PerfilEstudanteUpdateArgs} args - Arguments to update one PerfilEstudante.
     * @example
     * // Update one PerfilEstudante
     * const perfilEstudante = await prisma.perfilEstudante.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerfilEstudanteUpdateArgs>(args: SelectSubset<T, PerfilEstudanteUpdateArgs<ExtArgs>>): Prisma__PerfilEstudanteClient<$Result.GetResult<Prisma.$PerfilEstudantePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PerfilEstudantes.
     * @param {PerfilEstudanteDeleteManyArgs} args - Arguments to filter PerfilEstudantes to delete.
     * @example
     * // Delete a few PerfilEstudantes
     * const { count } = await prisma.perfilEstudante.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerfilEstudanteDeleteManyArgs>(args?: SelectSubset<T, PerfilEstudanteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerfilEstudantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilEstudanteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerfilEstudantes
     * const perfilEstudante = await prisma.perfilEstudante.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerfilEstudanteUpdateManyArgs>(args: SelectSubset<T, PerfilEstudanteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerfilEstudante.
     * @param {PerfilEstudanteUpsertArgs} args - Arguments to update or create a PerfilEstudante.
     * @example
     * // Update or create a PerfilEstudante
     * const perfilEstudante = await prisma.perfilEstudante.upsert({
     *   create: {
     *     // ... data to create a PerfilEstudante
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerfilEstudante we want to update
     *   }
     * })
     */
    upsert<T extends PerfilEstudanteUpsertArgs>(args: SelectSubset<T, PerfilEstudanteUpsertArgs<ExtArgs>>): Prisma__PerfilEstudanteClient<$Result.GetResult<Prisma.$PerfilEstudantePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PerfilEstudantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilEstudanteCountArgs} args - Arguments to filter PerfilEstudantes to count.
     * @example
     * // Count the number of PerfilEstudantes
     * const count = await prisma.perfilEstudante.count({
     *   where: {
     *     // ... the filter for the PerfilEstudantes we want to count
     *   }
     * })
    **/
    count<T extends PerfilEstudanteCountArgs>(
      args?: Subset<T, PerfilEstudanteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerfilEstudanteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerfilEstudante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilEstudanteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerfilEstudanteAggregateArgs>(args: Subset<T, PerfilEstudanteAggregateArgs>): Prisma.PrismaPromise<GetPerfilEstudanteAggregateType<T>>

    /**
     * Group by PerfilEstudante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilEstudanteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerfilEstudanteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerfilEstudanteGroupByArgs['orderBy'] }
        : { orderBy?: PerfilEstudanteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerfilEstudanteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerfilEstudanteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerfilEstudante model
   */
  readonly fields: PerfilEstudanteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerfilEstudante.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerfilEstudanteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerfilEstudante model
   */ 
  interface PerfilEstudanteFieldRefs {
    readonly id: FieldRef<"PerfilEstudante", 'BigInt'>
    readonly usuarioId: FieldRef<"PerfilEstudante", 'BigInt'>
    readonly nomeEscola: FieldRef<"PerfilEstudante", 'String'>
    readonly areaInteressePrincipal: FieldRef<"PerfilEstudante", 'String'>
    readonly urlCurriculo: FieldRef<"PerfilEstudante", 'String'>
    readonly criadoEm: FieldRef<"PerfilEstudante", 'DateTime'>
    readonly atualizadoEm: FieldRef<"PerfilEstudante", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerfilEstudante findUnique
   */
  export type PerfilEstudanteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilEstudante
     */
    select?: PerfilEstudanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilEstudanteInclude<ExtArgs> | null
    /**
     * Filter, which PerfilEstudante to fetch.
     */
    where: PerfilEstudanteWhereUniqueInput
  }

  /**
   * PerfilEstudante findUniqueOrThrow
   */
  export type PerfilEstudanteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilEstudante
     */
    select?: PerfilEstudanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilEstudanteInclude<ExtArgs> | null
    /**
     * Filter, which PerfilEstudante to fetch.
     */
    where: PerfilEstudanteWhereUniqueInput
  }

  /**
   * PerfilEstudante findFirst
   */
  export type PerfilEstudanteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilEstudante
     */
    select?: PerfilEstudanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilEstudanteInclude<ExtArgs> | null
    /**
     * Filter, which PerfilEstudante to fetch.
     */
    where?: PerfilEstudanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerfilEstudantes to fetch.
     */
    orderBy?: PerfilEstudanteOrderByWithRelationInput | PerfilEstudanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerfilEstudantes.
     */
    cursor?: PerfilEstudanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerfilEstudantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerfilEstudantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerfilEstudantes.
     */
    distinct?: PerfilEstudanteScalarFieldEnum | PerfilEstudanteScalarFieldEnum[]
  }

  /**
   * PerfilEstudante findFirstOrThrow
   */
  export type PerfilEstudanteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilEstudante
     */
    select?: PerfilEstudanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilEstudanteInclude<ExtArgs> | null
    /**
     * Filter, which PerfilEstudante to fetch.
     */
    where?: PerfilEstudanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerfilEstudantes to fetch.
     */
    orderBy?: PerfilEstudanteOrderByWithRelationInput | PerfilEstudanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerfilEstudantes.
     */
    cursor?: PerfilEstudanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerfilEstudantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerfilEstudantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerfilEstudantes.
     */
    distinct?: PerfilEstudanteScalarFieldEnum | PerfilEstudanteScalarFieldEnum[]
  }

  /**
   * PerfilEstudante findMany
   */
  export type PerfilEstudanteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilEstudante
     */
    select?: PerfilEstudanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilEstudanteInclude<ExtArgs> | null
    /**
     * Filter, which PerfilEstudantes to fetch.
     */
    where?: PerfilEstudanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerfilEstudantes to fetch.
     */
    orderBy?: PerfilEstudanteOrderByWithRelationInput | PerfilEstudanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerfilEstudantes.
     */
    cursor?: PerfilEstudanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerfilEstudantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerfilEstudantes.
     */
    skip?: number
    distinct?: PerfilEstudanteScalarFieldEnum | PerfilEstudanteScalarFieldEnum[]
  }

  /**
   * PerfilEstudante create
   */
  export type PerfilEstudanteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilEstudante
     */
    select?: PerfilEstudanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilEstudanteInclude<ExtArgs> | null
    /**
     * The data needed to create a PerfilEstudante.
     */
    data: XOR<PerfilEstudanteCreateInput, PerfilEstudanteUncheckedCreateInput>
  }

  /**
   * PerfilEstudante createMany
   */
  export type PerfilEstudanteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerfilEstudantes.
     */
    data: PerfilEstudanteCreateManyInput | PerfilEstudanteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerfilEstudante createManyAndReturn
   */
  export type PerfilEstudanteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilEstudante
     */
    select?: PerfilEstudanteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PerfilEstudantes.
     */
    data: PerfilEstudanteCreateManyInput | PerfilEstudanteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilEstudanteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerfilEstudante update
   */
  export type PerfilEstudanteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilEstudante
     */
    select?: PerfilEstudanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilEstudanteInclude<ExtArgs> | null
    /**
     * The data needed to update a PerfilEstudante.
     */
    data: XOR<PerfilEstudanteUpdateInput, PerfilEstudanteUncheckedUpdateInput>
    /**
     * Choose, which PerfilEstudante to update.
     */
    where: PerfilEstudanteWhereUniqueInput
  }

  /**
   * PerfilEstudante updateMany
   */
  export type PerfilEstudanteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerfilEstudantes.
     */
    data: XOR<PerfilEstudanteUpdateManyMutationInput, PerfilEstudanteUncheckedUpdateManyInput>
    /**
     * Filter which PerfilEstudantes to update
     */
    where?: PerfilEstudanteWhereInput
  }

  /**
   * PerfilEstudante upsert
   */
  export type PerfilEstudanteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilEstudante
     */
    select?: PerfilEstudanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilEstudanteInclude<ExtArgs> | null
    /**
     * The filter to search for the PerfilEstudante to update in case it exists.
     */
    where: PerfilEstudanteWhereUniqueInput
    /**
     * In case the PerfilEstudante found by the `where` argument doesn't exist, create a new PerfilEstudante with this data.
     */
    create: XOR<PerfilEstudanteCreateInput, PerfilEstudanteUncheckedCreateInput>
    /**
     * In case the PerfilEstudante was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerfilEstudanteUpdateInput, PerfilEstudanteUncheckedUpdateInput>
  }

  /**
   * PerfilEstudante delete
   */
  export type PerfilEstudanteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilEstudante
     */
    select?: PerfilEstudanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilEstudanteInclude<ExtArgs> | null
    /**
     * Filter which PerfilEstudante to delete.
     */
    where: PerfilEstudanteWhereUniqueInput
  }

  /**
   * PerfilEstudante deleteMany
   */
  export type PerfilEstudanteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerfilEstudantes to delete
     */
    where?: PerfilEstudanteWhereInput
  }

  /**
   * PerfilEstudante without action
   */
  export type PerfilEstudanteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilEstudante
     */
    select?: PerfilEstudanteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilEstudanteInclude<ExtArgs> | null
  }


  /**
   * Model PerfilInstituicao
   */

  export type AggregatePerfilInstituicao = {
    _count: PerfilInstituicaoCountAggregateOutputType | null
    _avg: PerfilInstituicaoAvgAggregateOutputType | null
    _sum: PerfilInstituicaoSumAggregateOutputType | null
    _min: PerfilInstituicaoMinAggregateOutputType | null
    _max: PerfilInstituicaoMaxAggregateOutputType | null
  }

  export type PerfilInstituicaoAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type PerfilInstituicaoSumAggregateOutputType = {
    id: bigint | null
    usuarioId: bigint | null
  }

  export type PerfilInstituicaoMinAggregateOutputType = {
    id: bigint | null
    usuarioId: bigint | null
    nomeInstituicao: string | null
    descricao: string | null
    urlSite: string | null
    urlLogo: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type PerfilInstituicaoMaxAggregateOutputType = {
    id: bigint | null
    usuarioId: bigint | null
    nomeInstituicao: string | null
    descricao: string | null
    urlSite: string | null
    urlLogo: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type PerfilInstituicaoCountAggregateOutputType = {
    id: number
    usuarioId: number
    nomeInstituicao: number
    descricao: number
    urlSite: number
    urlLogo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type PerfilInstituicaoAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type PerfilInstituicaoSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type PerfilInstituicaoMinAggregateInputType = {
    id?: true
    usuarioId?: true
    nomeInstituicao?: true
    descricao?: true
    urlSite?: true
    urlLogo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type PerfilInstituicaoMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    nomeInstituicao?: true
    descricao?: true
    urlSite?: true
    urlLogo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type PerfilInstituicaoCountAggregateInputType = {
    id?: true
    usuarioId?: true
    nomeInstituicao?: true
    descricao?: true
    urlSite?: true
    urlLogo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type PerfilInstituicaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerfilInstituicao to aggregate.
     */
    where?: PerfilInstituicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerfilInstituicaos to fetch.
     */
    orderBy?: PerfilInstituicaoOrderByWithRelationInput | PerfilInstituicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerfilInstituicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerfilInstituicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerfilInstituicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerfilInstituicaos
    **/
    _count?: true | PerfilInstituicaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerfilInstituicaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerfilInstituicaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerfilInstituicaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerfilInstituicaoMaxAggregateInputType
  }

  export type GetPerfilInstituicaoAggregateType<T extends PerfilInstituicaoAggregateArgs> = {
        [P in keyof T & keyof AggregatePerfilInstituicao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerfilInstituicao[P]>
      : GetScalarType<T[P], AggregatePerfilInstituicao[P]>
  }




  export type PerfilInstituicaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerfilInstituicaoWhereInput
    orderBy?: PerfilInstituicaoOrderByWithAggregationInput | PerfilInstituicaoOrderByWithAggregationInput[]
    by: PerfilInstituicaoScalarFieldEnum[] | PerfilInstituicaoScalarFieldEnum
    having?: PerfilInstituicaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerfilInstituicaoCountAggregateInputType | true
    _avg?: PerfilInstituicaoAvgAggregateInputType
    _sum?: PerfilInstituicaoSumAggregateInputType
    _min?: PerfilInstituicaoMinAggregateInputType
    _max?: PerfilInstituicaoMaxAggregateInputType
  }

  export type PerfilInstituicaoGroupByOutputType = {
    id: bigint
    usuarioId: bigint
    nomeInstituicao: string
    descricao: string
    urlSite: string | null
    urlLogo: string | null
    criadoEm: Date
    atualizadoEm: Date
    _count: PerfilInstituicaoCountAggregateOutputType | null
    _avg: PerfilInstituicaoAvgAggregateOutputType | null
    _sum: PerfilInstituicaoSumAggregateOutputType | null
    _min: PerfilInstituicaoMinAggregateOutputType | null
    _max: PerfilInstituicaoMaxAggregateOutputType | null
  }

  type GetPerfilInstituicaoGroupByPayload<T extends PerfilInstituicaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerfilInstituicaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerfilInstituicaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerfilInstituicaoGroupByOutputType[P]>
            : GetScalarType<T[P], PerfilInstituicaoGroupByOutputType[P]>
        }
      >
    >


  export type PerfilInstituicaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    nomeInstituicao?: boolean
    descricao?: boolean
    urlSite?: boolean
    urlLogo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    cursos?: boolean | PerfilInstituicao$cursosArgs<ExtArgs>
    oportunidades?: boolean | PerfilInstituicao$oportunidadesArgs<ExtArgs>
    _count?: boolean | PerfilInstituicaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["perfilInstituicao"]>

  export type PerfilInstituicaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    nomeInstituicao?: boolean
    descricao?: boolean
    urlSite?: boolean
    urlLogo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["perfilInstituicao"]>

  export type PerfilInstituicaoSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    nomeInstituicao?: boolean
    descricao?: boolean
    urlSite?: boolean
    urlLogo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type PerfilInstituicaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    cursos?: boolean | PerfilInstituicao$cursosArgs<ExtArgs>
    oportunidades?: boolean | PerfilInstituicao$oportunidadesArgs<ExtArgs>
    _count?: boolean | PerfilInstituicaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PerfilInstituicaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $PerfilInstituicaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerfilInstituicao"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      cursos: Prisma.$CursoPayload<ExtArgs>[]
      oportunidades: Prisma.$OportunidadePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      usuarioId: bigint
      nomeInstituicao: string
      descricao: string
      urlSite: string | null
      urlLogo: string | null
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["perfilInstituicao"]>
    composites: {}
  }

  type PerfilInstituicaoGetPayload<S extends boolean | null | undefined | PerfilInstituicaoDefaultArgs> = $Result.GetResult<Prisma.$PerfilInstituicaoPayload, S>

  type PerfilInstituicaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PerfilInstituicaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PerfilInstituicaoCountAggregateInputType | true
    }

  export interface PerfilInstituicaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerfilInstituicao'], meta: { name: 'PerfilInstituicao' } }
    /**
     * Find zero or one PerfilInstituicao that matches the filter.
     * @param {PerfilInstituicaoFindUniqueArgs} args - Arguments to find a PerfilInstituicao
     * @example
     * // Get one PerfilInstituicao
     * const perfilInstituicao = await prisma.perfilInstituicao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerfilInstituicaoFindUniqueArgs>(args: SelectSubset<T, PerfilInstituicaoFindUniqueArgs<ExtArgs>>): Prisma__PerfilInstituicaoClient<$Result.GetResult<Prisma.$PerfilInstituicaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PerfilInstituicao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PerfilInstituicaoFindUniqueOrThrowArgs} args - Arguments to find a PerfilInstituicao
     * @example
     * // Get one PerfilInstituicao
     * const perfilInstituicao = await prisma.perfilInstituicao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerfilInstituicaoFindUniqueOrThrowArgs>(args: SelectSubset<T, PerfilInstituicaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerfilInstituicaoClient<$Result.GetResult<Prisma.$PerfilInstituicaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PerfilInstituicao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilInstituicaoFindFirstArgs} args - Arguments to find a PerfilInstituicao
     * @example
     * // Get one PerfilInstituicao
     * const perfilInstituicao = await prisma.perfilInstituicao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerfilInstituicaoFindFirstArgs>(args?: SelectSubset<T, PerfilInstituicaoFindFirstArgs<ExtArgs>>): Prisma__PerfilInstituicaoClient<$Result.GetResult<Prisma.$PerfilInstituicaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PerfilInstituicao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilInstituicaoFindFirstOrThrowArgs} args - Arguments to find a PerfilInstituicao
     * @example
     * // Get one PerfilInstituicao
     * const perfilInstituicao = await prisma.perfilInstituicao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerfilInstituicaoFindFirstOrThrowArgs>(args?: SelectSubset<T, PerfilInstituicaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerfilInstituicaoClient<$Result.GetResult<Prisma.$PerfilInstituicaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PerfilInstituicaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilInstituicaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerfilInstituicaos
     * const perfilInstituicaos = await prisma.perfilInstituicao.findMany()
     * 
     * // Get first 10 PerfilInstituicaos
     * const perfilInstituicaos = await prisma.perfilInstituicao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const perfilInstituicaoWithIdOnly = await prisma.perfilInstituicao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerfilInstituicaoFindManyArgs>(args?: SelectSubset<T, PerfilInstituicaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerfilInstituicaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PerfilInstituicao.
     * @param {PerfilInstituicaoCreateArgs} args - Arguments to create a PerfilInstituicao.
     * @example
     * // Create one PerfilInstituicao
     * const PerfilInstituicao = await prisma.perfilInstituicao.create({
     *   data: {
     *     // ... data to create a PerfilInstituicao
     *   }
     * })
     * 
     */
    create<T extends PerfilInstituicaoCreateArgs>(args: SelectSubset<T, PerfilInstituicaoCreateArgs<ExtArgs>>): Prisma__PerfilInstituicaoClient<$Result.GetResult<Prisma.$PerfilInstituicaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PerfilInstituicaos.
     * @param {PerfilInstituicaoCreateManyArgs} args - Arguments to create many PerfilInstituicaos.
     * @example
     * // Create many PerfilInstituicaos
     * const perfilInstituicao = await prisma.perfilInstituicao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerfilInstituicaoCreateManyArgs>(args?: SelectSubset<T, PerfilInstituicaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerfilInstituicaos and returns the data saved in the database.
     * @param {PerfilInstituicaoCreateManyAndReturnArgs} args - Arguments to create many PerfilInstituicaos.
     * @example
     * // Create many PerfilInstituicaos
     * const perfilInstituicao = await prisma.perfilInstituicao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerfilInstituicaos and only return the `id`
     * const perfilInstituicaoWithIdOnly = await prisma.perfilInstituicao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerfilInstituicaoCreateManyAndReturnArgs>(args?: SelectSubset<T, PerfilInstituicaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerfilInstituicaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PerfilInstituicao.
     * @param {PerfilInstituicaoDeleteArgs} args - Arguments to delete one PerfilInstituicao.
     * @example
     * // Delete one PerfilInstituicao
     * const PerfilInstituicao = await prisma.perfilInstituicao.delete({
     *   where: {
     *     // ... filter to delete one PerfilInstituicao
     *   }
     * })
     * 
     */
    delete<T extends PerfilInstituicaoDeleteArgs>(args: SelectSubset<T, PerfilInstituicaoDeleteArgs<ExtArgs>>): Prisma__PerfilInstituicaoClient<$Result.GetResult<Prisma.$PerfilInstituicaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PerfilInstituicao.
     * @param {PerfilInstituicaoUpdateArgs} args - Arguments to update one PerfilInstituicao.
     * @example
     * // Update one PerfilInstituicao
     * const perfilInstituicao = await prisma.perfilInstituicao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerfilInstituicaoUpdateArgs>(args: SelectSubset<T, PerfilInstituicaoUpdateArgs<ExtArgs>>): Prisma__PerfilInstituicaoClient<$Result.GetResult<Prisma.$PerfilInstituicaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PerfilInstituicaos.
     * @param {PerfilInstituicaoDeleteManyArgs} args - Arguments to filter PerfilInstituicaos to delete.
     * @example
     * // Delete a few PerfilInstituicaos
     * const { count } = await prisma.perfilInstituicao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerfilInstituicaoDeleteManyArgs>(args?: SelectSubset<T, PerfilInstituicaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerfilInstituicaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilInstituicaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerfilInstituicaos
     * const perfilInstituicao = await prisma.perfilInstituicao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerfilInstituicaoUpdateManyArgs>(args: SelectSubset<T, PerfilInstituicaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerfilInstituicao.
     * @param {PerfilInstituicaoUpsertArgs} args - Arguments to update or create a PerfilInstituicao.
     * @example
     * // Update or create a PerfilInstituicao
     * const perfilInstituicao = await prisma.perfilInstituicao.upsert({
     *   create: {
     *     // ... data to create a PerfilInstituicao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerfilInstituicao we want to update
     *   }
     * })
     */
    upsert<T extends PerfilInstituicaoUpsertArgs>(args: SelectSubset<T, PerfilInstituicaoUpsertArgs<ExtArgs>>): Prisma__PerfilInstituicaoClient<$Result.GetResult<Prisma.$PerfilInstituicaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PerfilInstituicaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilInstituicaoCountArgs} args - Arguments to filter PerfilInstituicaos to count.
     * @example
     * // Count the number of PerfilInstituicaos
     * const count = await prisma.perfilInstituicao.count({
     *   where: {
     *     // ... the filter for the PerfilInstituicaos we want to count
     *   }
     * })
    **/
    count<T extends PerfilInstituicaoCountArgs>(
      args?: Subset<T, PerfilInstituicaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerfilInstituicaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerfilInstituicao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilInstituicaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerfilInstituicaoAggregateArgs>(args: Subset<T, PerfilInstituicaoAggregateArgs>): Prisma.PrismaPromise<GetPerfilInstituicaoAggregateType<T>>

    /**
     * Group by PerfilInstituicao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfilInstituicaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerfilInstituicaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerfilInstituicaoGroupByArgs['orderBy'] }
        : { orderBy?: PerfilInstituicaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerfilInstituicaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerfilInstituicaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerfilInstituicao model
   */
  readonly fields: PerfilInstituicaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerfilInstituicao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerfilInstituicaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cursos<T extends PerfilInstituicao$cursosArgs<ExtArgs> = {}>(args?: Subset<T, PerfilInstituicao$cursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findMany"> | Null>
    oportunidades<T extends PerfilInstituicao$oportunidadesArgs<ExtArgs> = {}>(args?: Subset<T, PerfilInstituicao$oportunidadesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OportunidadePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerfilInstituicao model
   */ 
  interface PerfilInstituicaoFieldRefs {
    readonly id: FieldRef<"PerfilInstituicao", 'BigInt'>
    readonly usuarioId: FieldRef<"PerfilInstituicao", 'BigInt'>
    readonly nomeInstituicao: FieldRef<"PerfilInstituicao", 'String'>
    readonly descricao: FieldRef<"PerfilInstituicao", 'String'>
    readonly urlSite: FieldRef<"PerfilInstituicao", 'String'>
    readonly urlLogo: FieldRef<"PerfilInstituicao", 'String'>
    readonly criadoEm: FieldRef<"PerfilInstituicao", 'DateTime'>
    readonly atualizadoEm: FieldRef<"PerfilInstituicao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerfilInstituicao findUnique
   */
  export type PerfilInstituicaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilInstituicao
     */
    select?: PerfilInstituicaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilInstituicaoInclude<ExtArgs> | null
    /**
     * Filter, which PerfilInstituicao to fetch.
     */
    where: PerfilInstituicaoWhereUniqueInput
  }

  /**
   * PerfilInstituicao findUniqueOrThrow
   */
  export type PerfilInstituicaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilInstituicao
     */
    select?: PerfilInstituicaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilInstituicaoInclude<ExtArgs> | null
    /**
     * Filter, which PerfilInstituicao to fetch.
     */
    where: PerfilInstituicaoWhereUniqueInput
  }

  /**
   * PerfilInstituicao findFirst
   */
  export type PerfilInstituicaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilInstituicao
     */
    select?: PerfilInstituicaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilInstituicaoInclude<ExtArgs> | null
    /**
     * Filter, which PerfilInstituicao to fetch.
     */
    where?: PerfilInstituicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerfilInstituicaos to fetch.
     */
    orderBy?: PerfilInstituicaoOrderByWithRelationInput | PerfilInstituicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerfilInstituicaos.
     */
    cursor?: PerfilInstituicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerfilInstituicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerfilInstituicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerfilInstituicaos.
     */
    distinct?: PerfilInstituicaoScalarFieldEnum | PerfilInstituicaoScalarFieldEnum[]
  }

  /**
   * PerfilInstituicao findFirstOrThrow
   */
  export type PerfilInstituicaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilInstituicao
     */
    select?: PerfilInstituicaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilInstituicaoInclude<ExtArgs> | null
    /**
     * Filter, which PerfilInstituicao to fetch.
     */
    where?: PerfilInstituicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerfilInstituicaos to fetch.
     */
    orderBy?: PerfilInstituicaoOrderByWithRelationInput | PerfilInstituicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerfilInstituicaos.
     */
    cursor?: PerfilInstituicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerfilInstituicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerfilInstituicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerfilInstituicaos.
     */
    distinct?: PerfilInstituicaoScalarFieldEnum | PerfilInstituicaoScalarFieldEnum[]
  }

  /**
   * PerfilInstituicao findMany
   */
  export type PerfilInstituicaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilInstituicao
     */
    select?: PerfilInstituicaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilInstituicaoInclude<ExtArgs> | null
    /**
     * Filter, which PerfilInstituicaos to fetch.
     */
    where?: PerfilInstituicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerfilInstituicaos to fetch.
     */
    orderBy?: PerfilInstituicaoOrderByWithRelationInput | PerfilInstituicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerfilInstituicaos.
     */
    cursor?: PerfilInstituicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerfilInstituicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerfilInstituicaos.
     */
    skip?: number
    distinct?: PerfilInstituicaoScalarFieldEnum | PerfilInstituicaoScalarFieldEnum[]
  }

  /**
   * PerfilInstituicao create
   */
  export type PerfilInstituicaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilInstituicao
     */
    select?: PerfilInstituicaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilInstituicaoInclude<ExtArgs> | null
    /**
     * The data needed to create a PerfilInstituicao.
     */
    data: XOR<PerfilInstituicaoCreateInput, PerfilInstituicaoUncheckedCreateInput>
  }

  /**
   * PerfilInstituicao createMany
   */
  export type PerfilInstituicaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerfilInstituicaos.
     */
    data: PerfilInstituicaoCreateManyInput | PerfilInstituicaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerfilInstituicao createManyAndReturn
   */
  export type PerfilInstituicaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilInstituicao
     */
    select?: PerfilInstituicaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PerfilInstituicaos.
     */
    data: PerfilInstituicaoCreateManyInput | PerfilInstituicaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilInstituicaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerfilInstituicao update
   */
  export type PerfilInstituicaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilInstituicao
     */
    select?: PerfilInstituicaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilInstituicaoInclude<ExtArgs> | null
    /**
     * The data needed to update a PerfilInstituicao.
     */
    data: XOR<PerfilInstituicaoUpdateInput, PerfilInstituicaoUncheckedUpdateInput>
    /**
     * Choose, which PerfilInstituicao to update.
     */
    where: PerfilInstituicaoWhereUniqueInput
  }

  /**
   * PerfilInstituicao updateMany
   */
  export type PerfilInstituicaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerfilInstituicaos.
     */
    data: XOR<PerfilInstituicaoUpdateManyMutationInput, PerfilInstituicaoUncheckedUpdateManyInput>
    /**
     * Filter which PerfilInstituicaos to update
     */
    where?: PerfilInstituicaoWhereInput
  }

  /**
   * PerfilInstituicao upsert
   */
  export type PerfilInstituicaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilInstituicao
     */
    select?: PerfilInstituicaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilInstituicaoInclude<ExtArgs> | null
    /**
     * The filter to search for the PerfilInstituicao to update in case it exists.
     */
    where: PerfilInstituicaoWhereUniqueInput
    /**
     * In case the PerfilInstituicao found by the `where` argument doesn't exist, create a new PerfilInstituicao with this data.
     */
    create: XOR<PerfilInstituicaoCreateInput, PerfilInstituicaoUncheckedCreateInput>
    /**
     * In case the PerfilInstituicao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerfilInstituicaoUpdateInput, PerfilInstituicaoUncheckedUpdateInput>
  }

  /**
   * PerfilInstituicao delete
   */
  export type PerfilInstituicaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilInstituicao
     */
    select?: PerfilInstituicaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilInstituicaoInclude<ExtArgs> | null
    /**
     * Filter which PerfilInstituicao to delete.
     */
    where: PerfilInstituicaoWhereUniqueInput
  }

  /**
   * PerfilInstituicao deleteMany
   */
  export type PerfilInstituicaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerfilInstituicaos to delete
     */
    where?: PerfilInstituicaoWhereInput
  }

  /**
   * PerfilInstituicao.cursos
   */
  export type PerfilInstituicao$cursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    where?: CursoWhereInput
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    cursor?: CursoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * PerfilInstituicao.oportunidades
   */
  export type PerfilInstituicao$oportunidadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oportunidade
     */
    select?: OportunidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OportunidadeInclude<ExtArgs> | null
    where?: OportunidadeWhereInput
    orderBy?: OportunidadeOrderByWithRelationInput | OportunidadeOrderByWithRelationInput[]
    cursor?: OportunidadeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OportunidadeScalarFieldEnum | OportunidadeScalarFieldEnum[]
  }

  /**
   * PerfilInstituicao without action
   */
  export type PerfilInstituicaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfilInstituicao
     */
    select?: PerfilInstituicaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerfilInstituicaoInclude<ExtArgs> | null
  }


  /**
   * Model CategoriaCurso
   */

  export type AggregateCategoriaCurso = {
    _count: CategoriaCursoCountAggregateOutputType | null
    _avg: CategoriaCursoAvgAggregateOutputType | null
    _sum: CategoriaCursoSumAggregateOutputType | null
    _min: CategoriaCursoMinAggregateOutputType | null
    _max: CategoriaCursoMaxAggregateOutputType | null
  }

  export type CategoriaCursoAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriaCursoSumAggregateOutputType = {
    id: bigint | null
  }

  export type CategoriaCursoMinAggregateOutputType = {
    id: bigint | null
    nome: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type CategoriaCursoMaxAggregateOutputType = {
    id: bigint | null
    nome: string | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type CategoriaCursoCountAggregateOutputType = {
    id: number
    nome: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type CategoriaCursoAvgAggregateInputType = {
    id?: true
  }

  export type CategoriaCursoSumAggregateInputType = {
    id?: true
  }

  export type CategoriaCursoMinAggregateInputType = {
    id?: true
    nome?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type CategoriaCursoMaxAggregateInputType = {
    id?: true
    nome?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type CategoriaCursoCountAggregateInputType = {
    id?: true
    nome?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type CategoriaCursoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoriaCurso to aggregate.
     */
    where?: CategoriaCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriaCursos to fetch.
     */
    orderBy?: CategoriaCursoOrderByWithRelationInput | CategoriaCursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriaCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriaCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriaCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CategoriaCursos
    **/
    _count?: true | CategoriaCursoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaCursoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaCursoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaCursoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaCursoMaxAggregateInputType
  }

  export type GetCategoriaCursoAggregateType<T extends CategoriaCursoAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoriaCurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoriaCurso[P]>
      : GetScalarType<T[P], AggregateCategoriaCurso[P]>
  }




  export type CategoriaCursoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaCursoWhereInput
    orderBy?: CategoriaCursoOrderByWithAggregationInput | CategoriaCursoOrderByWithAggregationInput[]
    by: CategoriaCursoScalarFieldEnum[] | CategoriaCursoScalarFieldEnum
    having?: CategoriaCursoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaCursoCountAggregateInputType | true
    _avg?: CategoriaCursoAvgAggregateInputType
    _sum?: CategoriaCursoSumAggregateInputType
    _min?: CategoriaCursoMinAggregateInputType
    _max?: CategoriaCursoMaxAggregateInputType
  }

  export type CategoriaCursoGroupByOutputType = {
    id: bigint
    nome: string
    criadoEm: Date
    atualizadoEm: Date
    _count: CategoriaCursoCountAggregateOutputType | null
    _avg: CategoriaCursoAvgAggregateOutputType | null
    _sum: CategoriaCursoSumAggregateOutputType | null
    _min: CategoriaCursoMinAggregateOutputType | null
    _max: CategoriaCursoMaxAggregateOutputType | null
  }

  type GetCategoriaCursoGroupByPayload<T extends CategoriaCursoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriaCursoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaCursoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaCursoGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaCursoGroupByOutputType[P]>
        }
      >
    >


  export type CategoriaCursoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    cursos?: boolean | CategoriaCurso$cursosArgs<ExtArgs>
    oportunidadesRelacionadas?: boolean | CategoriaCurso$oportunidadesRelacionadasArgs<ExtArgs>
    _count?: boolean | CategoriaCursoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoriaCurso"]>

  export type CategoriaCursoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["categoriaCurso"]>

  export type CategoriaCursoSelectScalar = {
    id?: boolean
    nome?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type CategoriaCursoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | CategoriaCurso$cursosArgs<ExtArgs>
    oportunidadesRelacionadas?: boolean | CategoriaCurso$oportunidadesRelacionadasArgs<ExtArgs>
    _count?: boolean | CategoriaCursoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoriaCursoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoriaCursoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CategoriaCurso"
    objects: {
      cursos: Prisma.$CursoCategoriaPayload<ExtArgs>[]
      oportunidadesRelacionadas: Prisma.$OportunidadePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      nome: string
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["categoriaCurso"]>
    composites: {}
  }

  type CategoriaCursoGetPayload<S extends boolean | null | undefined | CategoriaCursoDefaultArgs> = $Result.GetResult<Prisma.$CategoriaCursoPayload, S>

  type CategoriaCursoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoriaCursoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoriaCursoCountAggregateInputType | true
    }

  export interface CategoriaCursoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CategoriaCurso'], meta: { name: 'CategoriaCurso' } }
    /**
     * Find zero or one CategoriaCurso that matches the filter.
     * @param {CategoriaCursoFindUniqueArgs} args - Arguments to find a CategoriaCurso
     * @example
     * // Get one CategoriaCurso
     * const categoriaCurso = await prisma.categoriaCurso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoriaCursoFindUniqueArgs>(args: SelectSubset<T, CategoriaCursoFindUniqueArgs<ExtArgs>>): Prisma__CategoriaCursoClient<$Result.GetResult<Prisma.$CategoriaCursoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CategoriaCurso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoriaCursoFindUniqueOrThrowArgs} args - Arguments to find a CategoriaCurso
     * @example
     * // Get one CategoriaCurso
     * const categoriaCurso = await prisma.categoriaCurso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoriaCursoFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoriaCursoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoriaCursoClient<$Result.GetResult<Prisma.$CategoriaCursoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CategoriaCurso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCursoFindFirstArgs} args - Arguments to find a CategoriaCurso
     * @example
     * // Get one CategoriaCurso
     * const categoriaCurso = await prisma.categoriaCurso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoriaCursoFindFirstArgs>(args?: SelectSubset<T, CategoriaCursoFindFirstArgs<ExtArgs>>): Prisma__CategoriaCursoClient<$Result.GetResult<Prisma.$CategoriaCursoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CategoriaCurso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCursoFindFirstOrThrowArgs} args - Arguments to find a CategoriaCurso
     * @example
     * // Get one CategoriaCurso
     * const categoriaCurso = await prisma.categoriaCurso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoriaCursoFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoriaCursoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoriaCursoClient<$Result.GetResult<Prisma.$CategoriaCursoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CategoriaCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCursoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoriaCursos
     * const categoriaCursos = await prisma.categoriaCurso.findMany()
     * 
     * // Get first 10 CategoriaCursos
     * const categoriaCursos = await prisma.categoriaCurso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriaCursoWithIdOnly = await prisma.categoriaCurso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoriaCursoFindManyArgs>(args?: SelectSubset<T, CategoriaCursoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaCursoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CategoriaCurso.
     * @param {CategoriaCursoCreateArgs} args - Arguments to create a CategoriaCurso.
     * @example
     * // Create one CategoriaCurso
     * const CategoriaCurso = await prisma.categoriaCurso.create({
     *   data: {
     *     // ... data to create a CategoriaCurso
     *   }
     * })
     * 
     */
    create<T extends CategoriaCursoCreateArgs>(args: SelectSubset<T, CategoriaCursoCreateArgs<ExtArgs>>): Prisma__CategoriaCursoClient<$Result.GetResult<Prisma.$CategoriaCursoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CategoriaCursos.
     * @param {CategoriaCursoCreateManyArgs} args - Arguments to create many CategoriaCursos.
     * @example
     * // Create many CategoriaCursos
     * const categoriaCurso = await prisma.categoriaCurso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoriaCursoCreateManyArgs>(args?: SelectSubset<T, CategoriaCursoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CategoriaCursos and returns the data saved in the database.
     * @param {CategoriaCursoCreateManyAndReturnArgs} args - Arguments to create many CategoriaCursos.
     * @example
     * // Create many CategoriaCursos
     * const categoriaCurso = await prisma.categoriaCurso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CategoriaCursos and only return the `id`
     * const categoriaCursoWithIdOnly = await prisma.categoriaCurso.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoriaCursoCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoriaCursoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaCursoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CategoriaCurso.
     * @param {CategoriaCursoDeleteArgs} args - Arguments to delete one CategoriaCurso.
     * @example
     * // Delete one CategoriaCurso
     * const CategoriaCurso = await prisma.categoriaCurso.delete({
     *   where: {
     *     // ... filter to delete one CategoriaCurso
     *   }
     * })
     * 
     */
    delete<T extends CategoriaCursoDeleteArgs>(args: SelectSubset<T, CategoriaCursoDeleteArgs<ExtArgs>>): Prisma__CategoriaCursoClient<$Result.GetResult<Prisma.$CategoriaCursoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CategoriaCurso.
     * @param {CategoriaCursoUpdateArgs} args - Arguments to update one CategoriaCurso.
     * @example
     * // Update one CategoriaCurso
     * const categoriaCurso = await prisma.categoriaCurso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoriaCursoUpdateArgs>(args: SelectSubset<T, CategoriaCursoUpdateArgs<ExtArgs>>): Prisma__CategoriaCursoClient<$Result.GetResult<Prisma.$CategoriaCursoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CategoriaCursos.
     * @param {CategoriaCursoDeleteManyArgs} args - Arguments to filter CategoriaCursos to delete.
     * @example
     * // Delete a few CategoriaCursos
     * const { count } = await prisma.categoriaCurso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoriaCursoDeleteManyArgs>(args?: SelectSubset<T, CategoriaCursoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoriaCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoriaCursos
     * const categoriaCurso = await prisma.categoriaCurso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoriaCursoUpdateManyArgs>(args: SelectSubset<T, CategoriaCursoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CategoriaCurso.
     * @param {CategoriaCursoUpsertArgs} args - Arguments to update or create a CategoriaCurso.
     * @example
     * // Update or create a CategoriaCurso
     * const categoriaCurso = await prisma.categoriaCurso.upsert({
     *   create: {
     *     // ... data to create a CategoriaCurso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoriaCurso we want to update
     *   }
     * })
     */
    upsert<T extends CategoriaCursoUpsertArgs>(args: SelectSubset<T, CategoriaCursoUpsertArgs<ExtArgs>>): Prisma__CategoriaCursoClient<$Result.GetResult<Prisma.$CategoriaCursoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CategoriaCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCursoCountArgs} args - Arguments to filter CategoriaCursos to count.
     * @example
     * // Count the number of CategoriaCursos
     * const count = await prisma.categoriaCurso.count({
     *   where: {
     *     // ... the filter for the CategoriaCursos we want to count
     *   }
     * })
    **/
    count<T extends CategoriaCursoCountArgs>(
      args?: Subset<T, CategoriaCursoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCursoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoriaCurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaCursoAggregateArgs>(args: Subset<T, CategoriaCursoAggregateArgs>): Prisma.PrismaPromise<GetCategoriaCursoAggregateType<T>>

    /**
     * Group by CategoriaCurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriaCursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriaCursoGroupByArgs['orderBy'] }
        : { orderBy?: CategoriaCursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriaCursoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaCursoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CategoriaCurso model
   */
  readonly fields: CategoriaCursoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CategoriaCurso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriaCursoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cursos<T extends CategoriaCurso$cursosArgs<ExtArgs> = {}>(args?: Subset<T, CategoriaCurso$cursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoCategoriaPayload<ExtArgs>, T, "findMany"> | Null>
    oportunidadesRelacionadas<T extends CategoriaCurso$oportunidadesRelacionadasArgs<ExtArgs> = {}>(args?: Subset<T, CategoriaCurso$oportunidadesRelacionadasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OportunidadePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CategoriaCurso model
   */ 
  interface CategoriaCursoFieldRefs {
    readonly id: FieldRef<"CategoriaCurso", 'BigInt'>
    readonly nome: FieldRef<"CategoriaCurso", 'String'>
    readonly criadoEm: FieldRef<"CategoriaCurso", 'DateTime'>
    readonly atualizadoEm: FieldRef<"CategoriaCurso", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CategoriaCurso findUnique
   */
  export type CategoriaCursoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCurso
     */
    select?: CategoriaCursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaCursoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriaCurso to fetch.
     */
    where: CategoriaCursoWhereUniqueInput
  }

  /**
   * CategoriaCurso findUniqueOrThrow
   */
  export type CategoriaCursoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCurso
     */
    select?: CategoriaCursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaCursoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriaCurso to fetch.
     */
    where: CategoriaCursoWhereUniqueInput
  }

  /**
   * CategoriaCurso findFirst
   */
  export type CategoriaCursoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCurso
     */
    select?: CategoriaCursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaCursoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriaCurso to fetch.
     */
    where?: CategoriaCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriaCursos to fetch.
     */
    orderBy?: CategoriaCursoOrderByWithRelationInput | CategoriaCursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoriaCursos.
     */
    cursor?: CategoriaCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriaCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriaCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoriaCursos.
     */
    distinct?: CategoriaCursoScalarFieldEnum | CategoriaCursoScalarFieldEnum[]
  }

  /**
   * CategoriaCurso findFirstOrThrow
   */
  export type CategoriaCursoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCurso
     */
    select?: CategoriaCursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaCursoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriaCurso to fetch.
     */
    where?: CategoriaCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriaCursos to fetch.
     */
    orderBy?: CategoriaCursoOrderByWithRelationInput | CategoriaCursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CategoriaCursos.
     */
    cursor?: CategoriaCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriaCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriaCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CategoriaCursos.
     */
    distinct?: CategoriaCursoScalarFieldEnum | CategoriaCursoScalarFieldEnum[]
  }

  /**
   * CategoriaCurso findMany
   */
  export type CategoriaCursoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCurso
     */
    select?: CategoriaCursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaCursoInclude<ExtArgs> | null
    /**
     * Filter, which CategoriaCursos to fetch.
     */
    where?: CategoriaCursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CategoriaCursos to fetch.
     */
    orderBy?: CategoriaCursoOrderByWithRelationInput | CategoriaCursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CategoriaCursos.
     */
    cursor?: CategoriaCursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CategoriaCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CategoriaCursos.
     */
    skip?: number
    distinct?: CategoriaCursoScalarFieldEnum | CategoriaCursoScalarFieldEnum[]
  }

  /**
   * CategoriaCurso create
   */
  export type CategoriaCursoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCurso
     */
    select?: CategoriaCursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaCursoInclude<ExtArgs> | null
    /**
     * The data needed to create a CategoriaCurso.
     */
    data: XOR<CategoriaCursoCreateInput, CategoriaCursoUncheckedCreateInput>
  }

  /**
   * CategoriaCurso createMany
   */
  export type CategoriaCursoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CategoriaCursos.
     */
    data: CategoriaCursoCreateManyInput | CategoriaCursoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CategoriaCurso createManyAndReturn
   */
  export type CategoriaCursoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCurso
     */
    select?: CategoriaCursoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CategoriaCursos.
     */
    data: CategoriaCursoCreateManyInput | CategoriaCursoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CategoriaCurso update
   */
  export type CategoriaCursoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCurso
     */
    select?: CategoriaCursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaCursoInclude<ExtArgs> | null
    /**
     * The data needed to update a CategoriaCurso.
     */
    data: XOR<CategoriaCursoUpdateInput, CategoriaCursoUncheckedUpdateInput>
    /**
     * Choose, which CategoriaCurso to update.
     */
    where: CategoriaCursoWhereUniqueInput
  }

  /**
   * CategoriaCurso updateMany
   */
  export type CategoriaCursoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CategoriaCursos.
     */
    data: XOR<CategoriaCursoUpdateManyMutationInput, CategoriaCursoUncheckedUpdateManyInput>
    /**
     * Filter which CategoriaCursos to update
     */
    where?: CategoriaCursoWhereInput
  }

  /**
   * CategoriaCurso upsert
   */
  export type CategoriaCursoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCurso
     */
    select?: CategoriaCursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaCursoInclude<ExtArgs> | null
    /**
     * The filter to search for the CategoriaCurso to update in case it exists.
     */
    where: CategoriaCursoWhereUniqueInput
    /**
     * In case the CategoriaCurso found by the `where` argument doesn't exist, create a new CategoriaCurso with this data.
     */
    create: XOR<CategoriaCursoCreateInput, CategoriaCursoUncheckedCreateInput>
    /**
     * In case the CategoriaCurso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriaCursoUpdateInput, CategoriaCursoUncheckedUpdateInput>
  }

  /**
   * CategoriaCurso delete
   */
  export type CategoriaCursoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCurso
     */
    select?: CategoriaCursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaCursoInclude<ExtArgs> | null
    /**
     * Filter which CategoriaCurso to delete.
     */
    where: CategoriaCursoWhereUniqueInput
  }

  /**
   * CategoriaCurso deleteMany
   */
  export type CategoriaCursoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CategoriaCursos to delete
     */
    where?: CategoriaCursoWhereInput
  }

  /**
   * CategoriaCurso.cursos
   */
  export type CategoriaCurso$cursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCategoria
     */
    select?: CursoCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoCategoriaInclude<ExtArgs> | null
    where?: CursoCategoriaWhereInput
    orderBy?: CursoCategoriaOrderByWithRelationInput | CursoCategoriaOrderByWithRelationInput[]
    cursor?: CursoCategoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CursoCategoriaScalarFieldEnum | CursoCategoriaScalarFieldEnum[]
  }

  /**
   * CategoriaCurso.oportunidadesRelacionadas
   */
  export type CategoriaCurso$oportunidadesRelacionadasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oportunidade
     */
    select?: OportunidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OportunidadeInclude<ExtArgs> | null
    where?: OportunidadeWhereInput
    orderBy?: OportunidadeOrderByWithRelationInput | OportunidadeOrderByWithRelationInput[]
    cursor?: OportunidadeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OportunidadeScalarFieldEnum | OportunidadeScalarFieldEnum[]
  }

  /**
   * CategoriaCurso without action
   */
  export type CategoriaCursoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCurso
     */
    select?: CategoriaCursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaCursoInclude<ExtArgs> | null
  }


  /**
   * Model Curso
   */

  export type AggregateCurso = {
    _count: CursoCountAggregateOutputType | null
    _avg: CursoAvgAggregateOutputType | null
    _sum: CursoSumAggregateOutputType | null
    _min: CursoMinAggregateOutputType | null
    _max: CursoMaxAggregateOutputType | null
  }

  export type CursoAvgAggregateOutputType = {
    id: number | null
    instituicaoId: number | null
    cargaHorariaHoras: number | null
  }

  export type CursoSumAggregateOutputType = {
    id: bigint | null
    instituicaoId: bigint | null
    cargaHorariaHoras: number | null
  }

  export type CursoMinAggregateOutputType = {
    id: bigint | null
    instituicaoId: bigint | null
    titulo: string | null
    descricao: string | null
    modalidade: $Enums.CourseModalityEnum | null
    nivel: $Enums.CourseLevelEnum | null
    cargaHorariaHoras: number | null
    localizacao: string | null
    requisitos: string | null
    linkInscricao: string | null
    estaAtivo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type CursoMaxAggregateOutputType = {
    id: bigint | null
    instituicaoId: bigint | null
    titulo: string | null
    descricao: string | null
    modalidade: $Enums.CourseModalityEnum | null
    nivel: $Enums.CourseLevelEnum | null
    cargaHorariaHoras: number | null
    localizacao: string | null
    requisitos: string | null
    linkInscricao: string | null
    estaAtivo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type CursoCountAggregateOutputType = {
    id: number
    instituicaoId: number
    titulo: number
    descricao: number
    modalidade: number
    nivel: number
    cargaHorariaHoras: number
    localizacao: number
    requisitos: number
    linkInscricao: number
    estaAtivo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type CursoAvgAggregateInputType = {
    id?: true
    instituicaoId?: true
    cargaHorariaHoras?: true
  }

  export type CursoSumAggregateInputType = {
    id?: true
    instituicaoId?: true
    cargaHorariaHoras?: true
  }

  export type CursoMinAggregateInputType = {
    id?: true
    instituicaoId?: true
    titulo?: true
    descricao?: true
    modalidade?: true
    nivel?: true
    cargaHorariaHoras?: true
    localizacao?: true
    requisitos?: true
    linkInscricao?: true
    estaAtivo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type CursoMaxAggregateInputType = {
    id?: true
    instituicaoId?: true
    titulo?: true
    descricao?: true
    modalidade?: true
    nivel?: true
    cargaHorariaHoras?: true
    localizacao?: true
    requisitos?: true
    linkInscricao?: true
    estaAtivo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type CursoCountAggregateInputType = {
    id?: true
    instituicaoId?: true
    titulo?: true
    descricao?: true
    modalidade?: true
    nivel?: true
    cargaHorariaHoras?: true
    localizacao?: true
    requisitos?: true
    linkInscricao?: true
    estaAtivo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type CursoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Curso to aggregate.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cursos
    **/
    _count?: true | CursoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CursoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CursoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CursoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CursoMaxAggregateInputType
  }

  export type GetCursoAggregateType<T extends CursoAggregateArgs> = {
        [P in keyof T & keyof AggregateCurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurso[P]>
      : GetScalarType<T[P], AggregateCurso[P]>
  }




  export type CursoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoWhereInput
    orderBy?: CursoOrderByWithAggregationInput | CursoOrderByWithAggregationInput[]
    by: CursoScalarFieldEnum[] | CursoScalarFieldEnum
    having?: CursoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CursoCountAggregateInputType | true
    _avg?: CursoAvgAggregateInputType
    _sum?: CursoSumAggregateInputType
    _min?: CursoMinAggregateInputType
    _max?: CursoMaxAggregateInputType
  }

  export type CursoGroupByOutputType = {
    id: bigint
    instituicaoId: bigint
    titulo: string
    descricao: string
    modalidade: $Enums.CourseModalityEnum
    nivel: $Enums.CourseLevelEnum
    cargaHorariaHoras: number
    localizacao: string | null
    requisitos: string
    linkInscricao: string
    estaAtivo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: CursoCountAggregateOutputType | null
    _avg: CursoAvgAggregateOutputType | null
    _sum: CursoSumAggregateOutputType | null
    _min: CursoMinAggregateOutputType | null
    _max: CursoMaxAggregateOutputType | null
  }

  type GetCursoGroupByPayload<T extends CursoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CursoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CursoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CursoGroupByOutputType[P]>
            : GetScalarType<T[P], CursoGroupByOutputType[P]>
        }
      >
    >


  export type CursoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instituicaoId?: boolean
    titulo?: boolean
    descricao?: boolean
    modalidade?: boolean
    nivel?: boolean
    cargaHorariaHoras?: boolean
    localizacao?: boolean
    requisitos?: boolean
    linkInscricao?: boolean
    estaAtivo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    instituicao?: boolean | PerfilInstituicaoDefaultArgs<ExtArgs>
    categorias?: boolean | Curso$categoriasArgs<ExtArgs>
    matriculas?: boolean | Curso$matriculasArgs<ExtArgs>
    _count?: boolean | CursoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["curso"]>

  export type CursoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instituicaoId?: boolean
    titulo?: boolean
    descricao?: boolean
    modalidade?: boolean
    nivel?: boolean
    cargaHorariaHoras?: boolean
    localizacao?: boolean
    requisitos?: boolean
    linkInscricao?: boolean
    estaAtivo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    instituicao?: boolean | PerfilInstituicaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["curso"]>

  export type CursoSelectScalar = {
    id?: boolean
    instituicaoId?: boolean
    titulo?: boolean
    descricao?: boolean
    modalidade?: boolean
    nivel?: boolean
    cargaHorariaHoras?: boolean
    localizacao?: boolean
    requisitos?: boolean
    linkInscricao?: boolean
    estaAtivo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type CursoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instituicao?: boolean | PerfilInstituicaoDefaultArgs<ExtArgs>
    categorias?: boolean | Curso$categoriasArgs<ExtArgs>
    matriculas?: boolean | Curso$matriculasArgs<ExtArgs>
    _count?: boolean | CursoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CursoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instituicao?: boolean | PerfilInstituicaoDefaultArgs<ExtArgs>
  }

  export type $CursoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Curso"
    objects: {
      instituicao: Prisma.$PerfilInstituicaoPayload<ExtArgs>
      categorias: Prisma.$CursoCategoriaPayload<ExtArgs>[]
      matriculas: Prisma.$MatriculaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      instituicaoId: bigint
      titulo: string
      descricao: string
      modalidade: $Enums.CourseModalityEnum
      nivel: $Enums.CourseLevelEnum
      cargaHorariaHoras: number
      localizacao: string | null
      requisitos: string
      linkInscricao: string
      estaAtivo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["curso"]>
    composites: {}
  }

  type CursoGetPayload<S extends boolean | null | undefined | CursoDefaultArgs> = $Result.GetResult<Prisma.$CursoPayload, S>

  type CursoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CursoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CursoCountAggregateInputType | true
    }

  export interface CursoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Curso'], meta: { name: 'Curso' } }
    /**
     * Find zero or one Curso that matches the filter.
     * @param {CursoFindUniqueArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CursoFindUniqueArgs>(args: SelectSubset<T, CursoFindUniqueArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Curso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CursoFindUniqueOrThrowArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CursoFindUniqueOrThrowArgs>(args: SelectSubset<T, CursoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Curso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindFirstArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CursoFindFirstArgs>(args?: SelectSubset<T, CursoFindFirstArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Curso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindFirstOrThrowArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CursoFindFirstOrThrowArgs>(args?: SelectSubset<T, CursoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cursos
     * const cursos = await prisma.curso.findMany()
     * 
     * // Get first 10 Cursos
     * const cursos = await prisma.curso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cursoWithIdOnly = await prisma.curso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CursoFindManyArgs>(args?: SelectSubset<T, CursoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Curso.
     * @param {CursoCreateArgs} args - Arguments to create a Curso.
     * @example
     * // Create one Curso
     * const Curso = await prisma.curso.create({
     *   data: {
     *     // ... data to create a Curso
     *   }
     * })
     * 
     */
    create<T extends CursoCreateArgs>(args: SelectSubset<T, CursoCreateArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cursos.
     * @param {CursoCreateManyArgs} args - Arguments to create many Cursos.
     * @example
     * // Create many Cursos
     * const curso = await prisma.curso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CursoCreateManyArgs>(args?: SelectSubset<T, CursoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cursos and returns the data saved in the database.
     * @param {CursoCreateManyAndReturnArgs} args - Arguments to create many Cursos.
     * @example
     * // Create many Cursos
     * const curso = await prisma.curso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cursos and only return the `id`
     * const cursoWithIdOnly = await prisma.curso.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CursoCreateManyAndReturnArgs>(args?: SelectSubset<T, CursoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Curso.
     * @param {CursoDeleteArgs} args - Arguments to delete one Curso.
     * @example
     * // Delete one Curso
     * const Curso = await prisma.curso.delete({
     *   where: {
     *     // ... filter to delete one Curso
     *   }
     * })
     * 
     */
    delete<T extends CursoDeleteArgs>(args: SelectSubset<T, CursoDeleteArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Curso.
     * @param {CursoUpdateArgs} args - Arguments to update one Curso.
     * @example
     * // Update one Curso
     * const curso = await prisma.curso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CursoUpdateArgs>(args: SelectSubset<T, CursoUpdateArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cursos.
     * @param {CursoDeleteManyArgs} args - Arguments to filter Cursos to delete.
     * @example
     * // Delete a few Cursos
     * const { count } = await prisma.curso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CursoDeleteManyArgs>(args?: SelectSubset<T, CursoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cursos
     * const curso = await prisma.curso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CursoUpdateManyArgs>(args: SelectSubset<T, CursoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Curso.
     * @param {CursoUpsertArgs} args - Arguments to update or create a Curso.
     * @example
     * // Update or create a Curso
     * const curso = await prisma.curso.upsert({
     *   create: {
     *     // ... data to create a Curso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Curso we want to update
     *   }
     * })
     */
    upsert<T extends CursoUpsertArgs>(args: SelectSubset<T, CursoUpsertArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoCountArgs} args - Arguments to filter Cursos to count.
     * @example
     * // Count the number of Cursos
     * const count = await prisma.curso.count({
     *   where: {
     *     // ... the filter for the Cursos we want to count
     *   }
     * })
    **/
    count<T extends CursoCountArgs>(
      args?: Subset<T, CursoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CursoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Curso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CursoAggregateArgs>(args: Subset<T, CursoAggregateArgs>): Prisma.PrismaPromise<GetCursoAggregateType<T>>

    /**
     * Group by Curso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CursoGroupByArgs['orderBy'] }
        : { orderBy?: CursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CursoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCursoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Curso model
   */
  readonly fields: CursoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Curso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CursoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instituicao<T extends PerfilInstituicaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PerfilInstituicaoDefaultArgs<ExtArgs>>): Prisma__PerfilInstituicaoClient<$Result.GetResult<Prisma.$PerfilInstituicaoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    categorias<T extends Curso$categoriasArgs<ExtArgs> = {}>(args?: Subset<T, Curso$categoriasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoCategoriaPayload<ExtArgs>, T, "findMany"> | Null>
    matriculas<T extends Curso$matriculasArgs<ExtArgs> = {}>(args?: Subset<T, Curso$matriculasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Curso model
   */ 
  interface CursoFieldRefs {
    readonly id: FieldRef<"Curso", 'BigInt'>
    readonly instituicaoId: FieldRef<"Curso", 'BigInt'>
    readonly titulo: FieldRef<"Curso", 'String'>
    readonly descricao: FieldRef<"Curso", 'String'>
    readonly modalidade: FieldRef<"Curso", 'CourseModalityEnum'>
    readonly nivel: FieldRef<"Curso", 'CourseLevelEnum'>
    readonly cargaHorariaHoras: FieldRef<"Curso", 'Int'>
    readonly localizacao: FieldRef<"Curso", 'String'>
    readonly requisitos: FieldRef<"Curso", 'String'>
    readonly linkInscricao: FieldRef<"Curso", 'String'>
    readonly estaAtivo: FieldRef<"Curso", 'Boolean'>
    readonly criadoEm: FieldRef<"Curso", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Curso", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Curso findUnique
   */
  export type CursoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso findUniqueOrThrow
   */
  export type CursoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso findFirst
   */
  export type CursoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cursos.
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cursos.
     */
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Curso findFirstOrThrow
   */
  export type CursoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cursos.
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cursos.
     */
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Curso findMany
   */
  export type CursoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Cursos to fetch.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cursos.
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Curso create
   */
  export type CursoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * The data needed to create a Curso.
     */
    data: XOR<CursoCreateInput, CursoUncheckedCreateInput>
  }

  /**
   * Curso createMany
   */
  export type CursoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cursos.
     */
    data: CursoCreateManyInput | CursoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Curso createManyAndReturn
   */
  export type CursoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cursos.
     */
    data: CursoCreateManyInput | CursoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Curso update
   */
  export type CursoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * The data needed to update a Curso.
     */
    data: XOR<CursoUpdateInput, CursoUncheckedUpdateInput>
    /**
     * Choose, which Curso to update.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso updateMany
   */
  export type CursoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cursos.
     */
    data: XOR<CursoUpdateManyMutationInput, CursoUncheckedUpdateManyInput>
    /**
     * Filter which Cursos to update
     */
    where?: CursoWhereInput
  }

  /**
   * Curso upsert
   */
  export type CursoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * The filter to search for the Curso to update in case it exists.
     */
    where: CursoWhereUniqueInput
    /**
     * In case the Curso found by the `where` argument doesn't exist, create a new Curso with this data.
     */
    create: XOR<CursoCreateInput, CursoUncheckedCreateInput>
    /**
     * In case the Curso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CursoUpdateInput, CursoUncheckedUpdateInput>
  }

  /**
   * Curso delete
   */
  export type CursoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter which Curso to delete.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso deleteMany
   */
  export type CursoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cursos to delete
     */
    where?: CursoWhereInput
  }

  /**
   * Curso.categorias
   */
  export type Curso$categoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCategoria
     */
    select?: CursoCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoCategoriaInclude<ExtArgs> | null
    where?: CursoCategoriaWhereInput
    orderBy?: CursoCategoriaOrderByWithRelationInput | CursoCategoriaOrderByWithRelationInput[]
    cursor?: CursoCategoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CursoCategoriaScalarFieldEnum | CursoCategoriaScalarFieldEnum[]
  }

  /**
   * Curso.matriculas
   */
  export type Curso$matriculasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    where?: MatriculaWhereInput
    orderBy?: MatriculaOrderByWithRelationInput | MatriculaOrderByWithRelationInput[]
    cursor?: MatriculaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatriculaScalarFieldEnum | MatriculaScalarFieldEnum[]
  }

  /**
   * Curso without action
   */
  export type CursoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
  }


  /**
   * Model CursoCategoria
   */

  export type AggregateCursoCategoria = {
    _count: CursoCategoriaCountAggregateOutputType | null
    _avg: CursoCategoriaAvgAggregateOutputType | null
    _sum: CursoCategoriaSumAggregateOutputType | null
    _min: CursoCategoriaMinAggregateOutputType | null
    _max: CursoCategoriaMaxAggregateOutputType | null
  }

  export type CursoCategoriaAvgAggregateOutputType = {
    cursoId: number | null
    categoriaId: number | null
  }

  export type CursoCategoriaSumAggregateOutputType = {
    cursoId: bigint | null
    categoriaId: bigint | null
  }

  export type CursoCategoriaMinAggregateOutputType = {
    cursoId: bigint | null
    categoriaId: bigint | null
  }

  export type CursoCategoriaMaxAggregateOutputType = {
    cursoId: bigint | null
    categoriaId: bigint | null
  }

  export type CursoCategoriaCountAggregateOutputType = {
    cursoId: number
    categoriaId: number
    _all: number
  }


  export type CursoCategoriaAvgAggregateInputType = {
    cursoId?: true
    categoriaId?: true
  }

  export type CursoCategoriaSumAggregateInputType = {
    cursoId?: true
    categoriaId?: true
  }

  export type CursoCategoriaMinAggregateInputType = {
    cursoId?: true
    categoriaId?: true
  }

  export type CursoCategoriaMaxAggregateInputType = {
    cursoId?: true
    categoriaId?: true
  }

  export type CursoCategoriaCountAggregateInputType = {
    cursoId?: true
    categoriaId?: true
    _all?: true
  }

  export type CursoCategoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CursoCategoria to aggregate.
     */
    where?: CursoCategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursoCategorias to fetch.
     */
    orderBy?: CursoCategoriaOrderByWithRelationInput | CursoCategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CursoCategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursoCategorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursoCategorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CursoCategorias
    **/
    _count?: true | CursoCategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CursoCategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CursoCategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CursoCategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CursoCategoriaMaxAggregateInputType
  }

  export type GetCursoCategoriaAggregateType<T extends CursoCategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateCursoCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCursoCategoria[P]>
      : GetScalarType<T[P], AggregateCursoCategoria[P]>
  }




  export type CursoCategoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoCategoriaWhereInput
    orderBy?: CursoCategoriaOrderByWithAggregationInput | CursoCategoriaOrderByWithAggregationInput[]
    by: CursoCategoriaScalarFieldEnum[] | CursoCategoriaScalarFieldEnum
    having?: CursoCategoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CursoCategoriaCountAggregateInputType | true
    _avg?: CursoCategoriaAvgAggregateInputType
    _sum?: CursoCategoriaSumAggregateInputType
    _min?: CursoCategoriaMinAggregateInputType
    _max?: CursoCategoriaMaxAggregateInputType
  }

  export type CursoCategoriaGroupByOutputType = {
    cursoId: bigint
    categoriaId: bigint
    _count: CursoCategoriaCountAggregateOutputType | null
    _avg: CursoCategoriaAvgAggregateOutputType | null
    _sum: CursoCategoriaSumAggregateOutputType | null
    _min: CursoCategoriaMinAggregateOutputType | null
    _max: CursoCategoriaMaxAggregateOutputType | null
  }

  type GetCursoCategoriaGroupByPayload<T extends CursoCategoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CursoCategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CursoCategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CursoCategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CursoCategoriaGroupByOutputType[P]>
        }
      >
    >


  export type CursoCategoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cursoId?: boolean
    categoriaId?: boolean
    curso?: boolean | CursoDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaCursoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cursoCategoria"]>

  export type CursoCategoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cursoId?: boolean
    categoriaId?: boolean
    curso?: boolean | CursoDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaCursoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cursoCategoria"]>

  export type CursoCategoriaSelectScalar = {
    cursoId?: boolean
    categoriaId?: boolean
  }

  export type CursoCategoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | CursoDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaCursoDefaultArgs<ExtArgs>
  }
  export type CursoCategoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | CursoDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaCursoDefaultArgs<ExtArgs>
  }

  export type $CursoCategoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CursoCategoria"
    objects: {
      curso: Prisma.$CursoPayload<ExtArgs>
      categoria: Prisma.$CategoriaCursoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cursoId: bigint
      categoriaId: bigint
    }, ExtArgs["result"]["cursoCategoria"]>
    composites: {}
  }

  type CursoCategoriaGetPayload<S extends boolean | null | undefined | CursoCategoriaDefaultArgs> = $Result.GetResult<Prisma.$CursoCategoriaPayload, S>

  type CursoCategoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CursoCategoriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CursoCategoriaCountAggregateInputType | true
    }

  export interface CursoCategoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CursoCategoria'], meta: { name: 'CursoCategoria' } }
    /**
     * Find zero or one CursoCategoria that matches the filter.
     * @param {CursoCategoriaFindUniqueArgs} args - Arguments to find a CursoCategoria
     * @example
     * // Get one CursoCategoria
     * const cursoCategoria = await prisma.cursoCategoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CursoCategoriaFindUniqueArgs>(args: SelectSubset<T, CursoCategoriaFindUniqueArgs<ExtArgs>>): Prisma__CursoCategoriaClient<$Result.GetResult<Prisma.$CursoCategoriaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CursoCategoria that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CursoCategoriaFindUniqueOrThrowArgs} args - Arguments to find a CursoCategoria
     * @example
     * // Get one CursoCategoria
     * const cursoCategoria = await prisma.cursoCategoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CursoCategoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, CursoCategoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CursoCategoriaClient<$Result.GetResult<Prisma.$CursoCategoriaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CursoCategoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoCategoriaFindFirstArgs} args - Arguments to find a CursoCategoria
     * @example
     * // Get one CursoCategoria
     * const cursoCategoria = await prisma.cursoCategoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CursoCategoriaFindFirstArgs>(args?: SelectSubset<T, CursoCategoriaFindFirstArgs<ExtArgs>>): Prisma__CursoCategoriaClient<$Result.GetResult<Prisma.$CursoCategoriaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CursoCategoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoCategoriaFindFirstOrThrowArgs} args - Arguments to find a CursoCategoria
     * @example
     * // Get one CursoCategoria
     * const cursoCategoria = await prisma.cursoCategoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CursoCategoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, CursoCategoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CursoCategoriaClient<$Result.GetResult<Prisma.$CursoCategoriaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CursoCategorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoCategoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CursoCategorias
     * const cursoCategorias = await prisma.cursoCategoria.findMany()
     * 
     * // Get first 10 CursoCategorias
     * const cursoCategorias = await prisma.cursoCategoria.findMany({ take: 10 })
     * 
     * // Only select the `cursoId`
     * const cursoCategoriaWithCursoIdOnly = await prisma.cursoCategoria.findMany({ select: { cursoId: true } })
     * 
     */
    findMany<T extends CursoCategoriaFindManyArgs>(args?: SelectSubset<T, CursoCategoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoCategoriaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CursoCategoria.
     * @param {CursoCategoriaCreateArgs} args - Arguments to create a CursoCategoria.
     * @example
     * // Create one CursoCategoria
     * const CursoCategoria = await prisma.cursoCategoria.create({
     *   data: {
     *     // ... data to create a CursoCategoria
     *   }
     * })
     * 
     */
    create<T extends CursoCategoriaCreateArgs>(args: SelectSubset<T, CursoCategoriaCreateArgs<ExtArgs>>): Prisma__CursoCategoriaClient<$Result.GetResult<Prisma.$CursoCategoriaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CursoCategorias.
     * @param {CursoCategoriaCreateManyArgs} args - Arguments to create many CursoCategorias.
     * @example
     * // Create many CursoCategorias
     * const cursoCategoria = await prisma.cursoCategoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CursoCategoriaCreateManyArgs>(args?: SelectSubset<T, CursoCategoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CursoCategorias and returns the data saved in the database.
     * @param {CursoCategoriaCreateManyAndReturnArgs} args - Arguments to create many CursoCategorias.
     * @example
     * // Create many CursoCategorias
     * const cursoCategoria = await prisma.cursoCategoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CursoCategorias and only return the `cursoId`
     * const cursoCategoriaWithCursoIdOnly = await prisma.cursoCategoria.createManyAndReturn({ 
     *   select: { cursoId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CursoCategoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, CursoCategoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoCategoriaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CursoCategoria.
     * @param {CursoCategoriaDeleteArgs} args - Arguments to delete one CursoCategoria.
     * @example
     * // Delete one CursoCategoria
     * const CursoCategoria = await prisma.cursoCategoria.delete({
     *   where: {
     *     // ... filter to delete one CursoCategoria
     *   }
     * })
     * 
     */
    delete<T extends CursoCategoriaDeleteArgs>(args: SelectSubset<T, CursoCategoriaDeleteArgs<ExtArgs>>): Prisma__CursoCategoriaClient<$Result.GetResult<Prisma.$CursoCategoriaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CursoCategoria.
     * @param {CursoCategoriaUpdateArgs} args - Arguments to update one CursoCategoria.
     * @example
     * // Update one CursoCategoria
     * const cursoCategoria = await prisma.cursoCategoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CursoCategoriaUpdateArgs>(args: SelectSubset<T, CursoCategoriaUpdateArgs<ExtArgs>>): Prisma__CursoCategoriaClient<$Result.GetResult<Prisma.$CursoCategoriaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CursoCategorias.
     * @param {CursoCategoriaDeleteManyArgs} args - Arguments to filter CursoCategorias to delete.
     * @example
     * // Delete a few CursoCategorias
     * const { count } = await prisma.cursoCategoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CursoCategoriaDeleteManyArgs>(args?: SelectSubset<T, CursoCategoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CursoCategorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoCategoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CursoCategorias
     * const cursoCategoria = await prisma.cursoCategoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CursoCategoriaUpdateManyArgs>(args: SelectSubset<T, CursoCategoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CursoCategoria.
     * @param {CursoCategoriaUpsertArgs} args - Arguments to update or create a CursoCategoria.
     * @example
     * // Update or create a CursoCategoria
     * const cursoCategoria = await prisma.cursoCategoria.upsert({
     *   create: {
     *     // ... data to create a CursoCategoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CursoCategoria we want to update
     *   }
     * })
     */
    upsert<T extends CursoCategoriaUpsertArgs>(args: SelectSubset<T, CursoCategoriaUpsertArgs<ExtArgs>>): Prisma__CursoCategoriaClient<$Result.GetResult<Prisma.$CursoCategoriaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CursoCategorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoCategoriaCountArgs} args - Arguments to filter CursoCategorias to count.
     * @example
     * // Count the number of CursoCategorias
     * const count = await prisma.cursoCategoria.count({
     *   where: {
     *     // ... the filter for the CursoCategorias we want to count
     *   }
     * })
    **/
    count<T extends CursoCategoriaCountArgs>(
      args?: Subset<T, CursoCategoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CursoCategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CursoCategoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoCategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CursoCategoriaAggregateArgs>(args: Subset<T, CursoCategoriaAggregateArgs>): Prisma.PrismaPromise<GetCursoCategoriaAggregateType<T>>

    /**
     * Group by CursoCategoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoCategoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CursoCategoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CursoCategoriaGroupByArgs['orderBy'] }
        : { orderBy?: CursoCategoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CursoCategoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCursoCategoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CursoCategoria model
   */
  readonly fields: CursoCategoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CursoCategoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CursoCategoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    curso<T extends CursoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CursoDefaultArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    categoria<T extends CategoriaCursoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoriaCursoDefaultArgs<ExtArgs>>): Prisma__CategoriaCursoClient<$Result.GetResult<Prisma.$CategoriaCursoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CursoCategoria model
   */ 
  interface CursoCategoriaFieldRefs {
    readonly cursoId: FieldRef<"CursoCategoria", 'BigInt'>
    readonly categoriaId: FieldRef<"CursoCategoria", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * CursoCategoria findUnique
   */
  export type CursoCategoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCategoria
     */
    select?: CursoCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which CursoCategoria to fetch.
     */
    where: CursoCategoriaWhereUniqueInput
  }

  /**
   * CursoCategoria findUniqueOrThrow
   */
  export type CursoCategoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCategoria
     */
    select?: CursoCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which CursoCategoria to fetch.
     */
    where: CursoCategoriaWhereUniqueInput
  }

  /**
   * CursoCategoria findFirst
   */
  export type CursoCategoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCategoria
     */
    select?: CursoCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which CursoCategoria to fetch.
     */
    where?: CursoCategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursoCategorias to fetch.
     */
    orderBy?: CursoCategoriaOrderByWithRelationInput | CursoCategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CursoCategorias.
     */
    cursor?: CursoCategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursoCategorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursoCategorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CursoCategorias.
     */
    distinct?: CursoCategoriaScalarFieldEnum | CursoCategoriaScalarFieldEnum[]
  }

  /**
   * CursoCategoria findFirstOrThrow
   */
  export type CursoCategoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCategoria
     */
    select?: CursoCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which CursoCategoria to fetch.
     */
    where?: CursoCategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursoCategorias to fetch.
     */
    orderBy?: CursoCategoriaOrderByWithRelationInput | CursoCategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CursoCategorias.
     */
    cursor?: CursoCategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursoCategorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursoCategorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CursoCategorias.
     */
    distinct?: CursoCategoriaScalarFieldEnum | CursoCategoriaScalarFieldEnum[]
  }

  /**
   * CursoCategoria findMany
   */
  export type CursoCategoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCategoria
     */
    select?: CursoCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoCategoriaInclude<ExtArgs> | null
    /**
     * Filter, which CursoCategorias to fetch.
     */
    where?: CursoCategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursoCategorias to fetch.
     */
    orderBy?: CursoCategoriaOrderByWithRelationInput | CursoCategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CursoCategorias.
     */
    cursor?: CursoCategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursoCategorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursoCategorias.
     */
    skip?: number
    distinct?: CursoCategoriaScalarFieldEnum | CursoCategoriaScalarFieldEnum[]
  }

  /**
   * CursoCategoria create
   */
  export type CursoCategoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCategoria
     */
    select?: CursoCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoCategoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a CursoCategoria.
     */
    data: XOR<CursoCategoriaCreateInput, CursoCategoriaUncheckedCreateInput>
  }

  /**
   * CursoCategoria createMany
   */
  export type CursoCategoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CursoCategorias.
     */
    data: CursoCategoriaCreateManyInput | CursoCategoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CursoCategoria createManyAndReturn
   */
  export type CursoCategoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCategoria
     */
    select?: CursoCategoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CursoCategorias.
     */
    data: CursoCategoriaCreateManyInput | CursoCategoriaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoCategoriaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CursoCategoria update
   */
  export type CursoCategoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCategoria
     */
    select?: CursoCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoCategoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a CursoCategoria.
     */
    data: XOR<CursoCategoriaUpdateInput, CursoCategoriaUncheckedUpdateInput>
    /**
     * Choose, which CursoCategoria to update.
     */
    where: CursoCategoriaWhereUniqueInput
  }

  /**
   * CursoCategoria updateMany
   */
  export type CursoCategoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CursoCategorias.
     */
    data: XOR<CursoCategoriaUpdateManyMutationInput, CursoCategoriaUncheckedUpdateManyInput>
    /**
     * Filter which CursoCategorias to update
     */
    where?: CursoCategoriaWhereInput
  }

  /**
   * CursoCategoria upsert
   */
  export type CursoCategoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCategoria
     */
    select?: CursoCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoCategoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the CursoCategoria to update in case it exists.
     */
    where: CursoCategoriaWhereUniqueInput
    /**
     * In case the CursoCategoria found by the `where` argument doesn't exist, create a new CursoCategoria with this data.
     */
    create: XOR<CursoCategoriaCreateInput, CursoCategoriaUncheckedCreateInput>
    /**
     * In case the CursoCategoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CursoCategoriaUpdateInput, CursoCategoriaUncheckedUpdateInput>
  }

  /**
   * CursoCategoria delete
   */
  export type CursoCategoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCategoria
     */
    select?: CursoCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoCategoriaInclude<ExtArgs> | null
    /**
     * Filter which CursoCategoria to delete.
     */
    where: CursoCategoriaWhereUniqueInput
  }

  /**
   * CursoCategoria deleteMany
   */
  export type CursoCategoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CursoCategorias to delete
     */
    where?: CursoCategoriaWhereInput
  }

  /**
   * CursoCategoria without action
   */
  export type CursoCategoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCategoria
     */
    select?: CursoCategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoCategoriaInclude<ExtArgs> | null
  }


  /**
   * Model Oportunidade
   */

  export type AggregateOportunidade = {
    _count: OportunidadeCountAggregateOutputType | null
    _avg: OportunidadeAvgAggregateOutputType | null
    _sum: OportunidadeSumAggregateOutputType | null
    _min: OportunidadeMinAggregateOutputType | null
    _max: OportunidadeMaxAggregateOutputType | null
  }

  export type OportunidadeAvgAggregateOutputType = {
    id: number | null
    instituicaoId: number | null
    categoriaCursoRelacionadaId: number | null
  }

  export type OportunidadeSumAggregateOutputType = {
    id: bigint | null
    instituicaoId: bigint | null
    categoriaCursoRelacionadaId: bigint | null
  }

  export type OportunidadeMinAggregateOutputType = {
    id: bigint | null
    instituicaoId: bigint | null
    titulo: string | null
    descricao: string | null
    requisitos: string | null
    categoriaCursoRelacionadaId: bigint | null
    estaAtivo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type OportunidadeMaxAggregateOutputType = {
    id: bigint | null
    instituicaoId: bigint | null
    titulo: string | null
    descricao: string | null
    requisitos: string | null
    categoriaCursoRelacionadaId: bigint | null
    estaAtivo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type OportunidadeCountAggregateOutputType = {
    id: number
    instituicaoId: number
    titulo: number
    descricao: number
    requisitos: number
    categoriaCursoRelacionadaId: number
    estaAtivo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type OportunidadeAvgAggregateInputType = {
    id?: true
    instituicaoId?: true
    categoriaCursoRelacionadaId?: true
  }

  export type OportunidadeSumAggregateInputType = {
    id?: true
    instituicaoId?: true
    categoriaCursoRelacionadaId?: true
  }

  export type OportunidadeMinAggregateInputType = {
    id?: true
    instituicaoId?: true
    titulo?: true
    descricao?: true
    requisitos?: true
    categoriaCursoRelacionadaId?: true
    estaAtivo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type OportunidadeMaxAggregateInputType = {
    id?: true
    instituicaoId?: true
    titulo?: true
    descricao?: true
    requisitos?: true
    categoriaCursoRelacionadaId?: true
    estaAtivo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type OportunidadeCountAggregateInputType = {
    id?: true
    instituicaoId?: true
    titulo?: true
    descricao?: true
    requisitos?: true
    categoriaCursoRelacionadaId?: true
    estaAtivo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type OportunidadeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Oportunidade to aggregate.
     */
    where?: OportunidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Oportunidades to fetch.
     */
    orderBy?: OportunidadeOrderByWithRelationInput | OportunidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OportunidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Oportunidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Oportunidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Oportunidades
    **/
    _count?: true | OportunidadeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OportunidadeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OportunidadeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OportunidadeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OportunidadeMaxAggregateInputType
  }

  export type GetOportunidadeAggregateType<T extends OportunidadeAggregateArgs> = {
        [P in keyof T & keyof AggregateOportunidade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOportunidade[P]>
      : GetScalarType<T[P], AggregateOportunidade[P]>
  }




  export type OportunidadeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OportunidadeWhereInput
    orderBy?: OportunidadeOrderByWithAggregationInput | OportunidadeOrderByWithAggregationInput[]
    by: OportunidadeScalarFieldEnum[] | OportunidadeScalarFieldEnum
    having?: OportunidadeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OportunidadeCountAggregateInputType | true
    _avg?: OportunidadeAvgAggregateInputType
    _sum?: OportunidadeSumAggregateInputType
    _min?: OportunidadeMinAggregateInputType
    _max?: OportunidadeMaxAggregateInputType
  }

  export type OportunidadeGroupByOutputType = {
    id: bigint
    instituicaoId: bigint
    titulo: string
    descricao: string
    requisitos: string
    categoriaCursoRelacionadaId: bigint | null
    estaAtivo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: OportunidadeCountAggregateOutputType | null
    _avg: OportunidadeAvgAggregateOutputType | null
    _sum: OportunidadeSumAggregateOutputType | null
    _min: OportunidadeMinAggregateOutputType | null
    _max: OportunidadeMaxAggregateOutputType | null
  }

  type GetOportunidadeGroupByPayload<T extends OportunidadeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OportunidadeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OportunidadeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OportunidadeGroupByOutputType[P]>
            : GetScalarType<T[P], OportunidadeGroupByOutputType[P]>
        }
      >
    >


  export type OportunidadeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instituicaoId?: boolean
    titulo?: boolean
    descricao?: boolean
    requisitos?: boolean
    categoriaCursoRelacionadaId?: boolean
    estaAtivo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    instituicao?: boolean | PerfilInstituicaoDefaultArgs<ExtArgs>
    categoriaCursoRelacionada?: boolean | Oportunidade$categoriaCursoRelacionadaArgs<ExtArgs>
    candidaturas?: boolean | Oportunidade$candidaturasArgs<ExtArgs>
    _count?: boolean | OportunidadeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oportunidade"]>

  export type OportunidadeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instituicaoId?: boolean
    titulo?: boolean
    descricao?: boolean
    requisitos?: boolean
    categoriaCursoRelacionadaId?: boolean
    estaAtivo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    instituicao?: boolean | PerfilInstituicaoDefaultArgs<ExtArgs>
    categoriaCursoRelacionada?: boolean | Oportunidade$categoriaCursoRelacionadaArgs<ExtArgs>
  }, ExtArgs["result"]["oportunidade"]>

  export type OportunidadeSelectScalar = {
    id?: boolean
    instituicaoId?: boolean
    titulo?: boolean
    descricao?: boolean
    requisitos?: boolean
    categoriaCursoRelacionadaId?: boolean
    estaAtivo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type OportunidadeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instituicao?: boolean | PerfilInstituicaoDefaultArgs<ExtArgs>
    categoriaCursoRelacionada?: boolean | Oportunidade$categoriaCursoRelacionadaArgs<ExtArgs>
    candidaturas?: boolean | Oportunidade$candidaturasArgs<ExtArgs>
    _count?: boolean | OportunidadeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OportunidadeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instituicao?: boolean | PerfilInstituicaoDefaultArgs<ExtArgs>
    categoriaCursoRelacionada?: boolean | Oportunidade$categoriaCursoRelacionadaArgs<ExtArgs>
  }

  export type $OportunidadePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Oportunidade"
    objects: {
      instituicao: Prisma.$PerfilInstituicaoPayload<ExtArgs>
      categoriaCursoRelacionada: Prisma.$CategoriaCursoPayload<ExtArgs> | null
      candidaturas: Prisma.$CandidaturaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      instituicaoId: bigint
      titulo: string
      descricao: string
      requisitos: string
      categoriaCursoRelacionadaId: bigint | null
      estaAtivo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["oportunidade"]>
    composites: {}
  }

  type OportunidadeGetPayload<S extends boolean | null | undefined | OportunidadeDefaultArgs> = $Result.GetResult<Prisma.$OportunidadePayload, S>

  type OportunidadeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OportunidadeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OportunidadeCountAggregateInputType | true
    }

  export interface OportunidadeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Oportunidade'], meta: { name: 'Oportunidade' } }
    /**
     * Find zero or one Oportunidade that matches the filter.
     * @param {OportunidadeFindUniqueArgs} args - Arguments to find a Oportunidade
     * @example
     * // Get one Oportunidade
     * const oportunidade = await prisma.oportunidade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OportunidadeFindUniqueArgs>(args: SelectSubset<T, OportunidadeFindUniqueArgs<ExtArgs>>): Prisma__OportunidadeClient<$Result.GetResult<Prisma.$OportunidadePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Oportunidade that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OportunidadeFindUniqueOrThrowArgs} args - Arguments to find a Oportunidade
     * @example
     * // Get one Oportunidade
     * const oportunidade = await prisma.oportunidade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OportunidadeFindUniqueOrThrowArgs>(args: SelectSubset<T, OportunidadeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OportunidadeClient<$Result.GetResult<Prisma.$OportunidadePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Oportunidade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OportunidadeFindFirstArgs} args - Arguments to find a Oportunidade
     * @example
     * // Get one Oportunidade
     * const oportunidade = await prisma.oportunidade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OportunidadeFindFirstArgs>(args?: SelectSubset<T, OportunidadeFindFirstArgs<ExtArgs>>): Prisma__OportunidadeClient<$Result.GetResult<Prisma.$OportunidadePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Oportunidade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OportunidadeFindFirstOrThrowArgs} args - Arguments to find a Oportunidade
     * @example
     * // Get one Oportunidade
     * const oportunidade = await prisma.oportunidade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OportunidadeFindFirstOrThrowArgs>(args?: SelectSubset<T, OportunidadeFindFirstOrThrowArgs<ExtArgs>>): Prisma__OportunidadeClient<$Result.GetResult<Prisma.$OportunidadePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Oportunidades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OportunidadeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Oportunidades
     * const oportunidades = await prisma.oportunidade.findMany()
     * 
     * // Get first 10 Oportunidades
     * const oportunidades = await prisma.oportunidade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oportunidadeWithIdOnly = await prisma.oportunidade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OportunidadeFindManyArgs>(args?: SelectSubset<T, OportunidadeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OportunidadePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Oportunidade.
     * @param {OportunidadeCreateArgs} args - Arguments to create a Oportunidade.
     * @example
     * // Create one Oportunidade
     * const Oportunidade = await prisma.oportunidade.create({
     *   data: {
     *     // ... data to create a Oportunidade
     *   }
     * })
     * 
     */
    create<T extends OportunidadeCreateArgs>(args: SelectSubset<T, OportunidadeCreateArgs<ExtArgs>>): Prisma__OportunidadeClient<$Result.GetResult<Prisma.$OportunidadePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Oportunidades.
     * @param {OportunidadeCreateManyArgs} args - Arguments to create many Oportunidades.
     * @example
     * // Create many Oportunidades
     * const oportunidade = await prisma.oportunidade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OportunidadeCreateManyArgs>(args?: SelectSubset<T, OportunidadeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Oportunidades and returns the data saved in the database.
     * @param {OportunidadeCreateManyAndReturnArgs} args - Arguments to create many Oportunidades.
     * @example
     * // Create many Oportunidades
     * const oportunidade = await prisma.oportunidade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Oportunidades and only return the `id`
     * const oportunidadeWithIdOnly = await prisma.oportunidade.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OportunidadeCreateManyAndReturnArgs>(args?: SelectSubset<T, OportunidadeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OportunidadePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Oportunidade.
     * @param {OportunidadeDeleteArgs} args - Arguments to delete one Oportunidade.
     * @example
     * // Delete one Oportunidade
     * const Oportunidade = await prisma.oportunidade.delete({
     *   where: {
     *     // ... filter to delete one Oportunidade
     *   }
     * })
     * 
     */
    delete<T extends OportunidadeDeleteArgs>(args: SelectSubset<T, OportunidadeDeleteArgs<ExtArgs>>): Prisma__OportunidadeClient<$Result.GetResult<Prisma.$OportunidadePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Oportunidade.
     * @param {OportunidadeUpdateArgs} args - Arguments to update one Oportunidade.
     * @example
     * // Update one Oportunidade
     * const oportunidade = await prisma.oportunidade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OportunidadeUpdateArgs>(args: SelectSubset<T, OportunidadeUpdateArgs<ExtArgs>>): Prisma__OportunidadeClient<$Result.GetResult<Prisma.$OportunidadePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Oportunidades.
     * @param {OportunidadeDeleteManyArgs} args - Arguments to filter Oportunidades to delete.
     * @example
     * // Delete a few Oportunidades
     * const { count } = await prisma.oportunidade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OportunidadeDeleteManyArgs>(args?: SelectSubset<T, OportunidadeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Oportunidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OportunidadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Oportunidades
     * const oportunidade = await prisma.oportunidade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OportunidadeUpdateManyArgs>(args: SelectSubset<T, OportunidadeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Oportunidade.
     * @param {OportunidadeUpsertArgs} args - Arguments to update or create a Oportunidade.
     * @example
     * // Update or create a Oportunidade
     * const oportunidade = await prisma.oportunidade.upsert({
     *   create: {
     *     // ... data to create a Oportunidade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Oportunidade we want to update
     *   }
     * })
     */
    upsert<T extends OportunidadeUpsertArgs>(args: SelectSubset<T, OportunidadeUpsertArgs<ExtArgs>>): Prisma__OportunidadeClient<$Result.GetResult<Prisma.$OportunidadePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Oportunidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OportunidadeCountArgs} args - Arguments to filter Oportunidades to count.
     * @example
     * // Count the number of Oportunidades
     * const count = await prisma.oportunidade.count({
     *   where: {
     *     // ... the filter for the Oportunidades we want to count
     *   }
     * })
    **/
    count<T extends OportunidadeCountArgs>(
      args?: Subset<T, OportunidadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OportunidadeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Oportunidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OportunidadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OportunidadeAggregateArgs>(args: Subset<T, OportunidadeAggregateArgs>): Prisma.PrismaPromise<GetOportunidadeAggregateType<T>>

    /**
     * Group by Oportunidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OportunidadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OportunidadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OportunidadeGroupByArgs['orderBy'] }
        : { orderBy?: OportunidadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OportunidadeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOportunidadeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Oportunidade model
   */
  readonly fields: OportunidadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Oportunidade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OportunidadeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instituicao<T extends PerfilInstituicaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PerfilInstituicaoDefaultArgs<ExtArgs>>): Prisma__PerfilInstituicaoClient<$Result.GetResult<Prisma.$PerfilInstituicaoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    categoriaCursoRelacionada<T extends Oportunidade$categoriaCursoRelacionadaArgs<ExtArgs> = {}>(args?: Subset<T, Oportunidade$categoriaCursoRelacionadaArgs<ExtArgs>>): Prisma__CategoriaCursoClient<$Result.GetResult<Prisma.$CategoriaCursoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    candidaturas<T extends Oportunidade$candidaturasArgs<ExtArgs> = {}>(args?: Subset<T, Oportunidade$candidaturasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidaturaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Oportunidade model
   */ 
  interface OportunidadeFieldRefs {
    readonly id: FieldRef<"Oportunidade", 'BigInt'>
    readonly instituicaoId: FieldRef<"Oportunidade", 'BigInt'>
    readonly titulo: FieldRef<"Oportunidade", 'String'>
    readonly descricao: FieldRef<"Oportunidade", 'String'>
    readonly requisitos: FieldRef<"Oportunidade", 'String'>
    readonly categoriaCursoRelacionadaId: FieldRef<"Oportunidade", 'BigInt'>
    readonly estaAtivo: FieldRef<"Oportunidade", 'Boolean'>
    readonly criadoEm: FieldRef<"Oportunidade", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Oportunidade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Oportunidade findUnique
   */
  export type OportunidadeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oportunidade
     */
    select?: OportunidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OportunidadeInclude<ExtArgs> | null
    /**
     * Filter, which Oportunidade to fetch.
     */
    where: OportunidadeWhereUniqueInput
  }

  /**
   * Oportunidade findUniqueOrThrow
   */
  export type OportunidadeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oportunidade
     */
    select?: OportunidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OportunidadeInclude<ExtArgs> | null
    /**
     * Filter, which Oportunidade to fetch.
     */
    where: OportunidadeWhereUniqueInput
  }

  /**
   * Oportunidade findFirst
   */
  export type OportunidadeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oportunidade
     */
    select?: OportunidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OportunidadeInclude<ExtArgs> | null
    /**
     * Filter, which Oportunidade to fetch.
     */
    where?: OportunidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Oportunidades to fetch.
     */
    orderBy?: OportunidadeOrderByWithRelationInput | OportunidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Oportunidades.
     */
    cursor?: OportunidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Oportunidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Oportunidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Oportunidades.
     */
    distinct?: OportunidadeScalarFieldEnum | OportunidadeScalarFieldEnum[]
  }

  /**
   * Oportunidade findFirstOrThrow
   */
  export type OportunidadeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oportunidade
     */
    select?: OportunidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OportunidadeInclude<ExtArgs> | null
    /**
     * Filter, which Oportunidade to fetch.
     */
    where?: OportunidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Oportunidades to fetch.
     */
    orderBy?: OportunidadeOrderByWithRelationInput | OportunidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Oportunidades.
     */
    cursor?: OportunidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Oportunidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Oportunidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Oportunidades.
     */
    distinct?: OportunidadeScalarFieldEnum | OportunidadeScalarFieldEnum[]
  }

  /**
   * Oportunidade findMany
   */
  export type OportunidadeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oportunidade
     */
    select?: OportunidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OportunidadeInclude<ExtArgs> | null
    /**
     * Filter, which Oportunidades to fetch.
     */
    where?: OportunidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Oportunidades to fetch.
     */
    orderBy?: OportunidadeOrderByWithRelationInput | OportunidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Oportunidades.
     */
    cursor?: OportunidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Oportunidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Oportunidades.
     */
    skip?: number
    distinct?: OportunidadeScalarFieldEnum | OportunidadeScalarFieldEnum[]
  }

  /**
   * Oportunidade create
   */
  export type OportunidadeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oportunidade
     */
    select?: OportunidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OportunidadeInclude<ExtArgs> | null
    /**
     * The data needed to create a Oportunidade.
     */
    data: XOR<OportunidadeCreateInput, OportunidadeUncheckedCreateInput>
  }

  /**
   * Oportunidade createMany
   */
  export type OportunidadeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Oportunidades.
     */
    data: OportunidadeCreateManyInput | OportunidadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Oportunidade createManyAndReturn
   */
  export type OportunidadeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oportunidade
     */
    select?: OportunidadeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Oportunidades.
     */
    data: OportunidadeCreateManyInput | OportunidadeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OportunidadeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Oportunidade update
   */
  export type OportunidadeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oportunidade
     */
    select?: OportunidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OportunidadeInclude<ExtArgs> | null
    /**
     * The data needed to update a Oportunidade.
     */
    data: XOR<OportunidadeUpdateInput, OportunidadeUncheckedUpdateInput>
    /**
     * Choose, which Oportunidade to update.
     */
    where: OportunidadeWhereUniqueInput
  }

  /**
   * Oportunidade updateMany
   */
  export type OportunidadeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Oportunidades.
     */
    data: XOR<OportunidadeUpdateManyMutationInput, OportunidadeUncheckedUpdateManyInput>
    /**
     * Filter which Oportunidades to update
     */
    where?: OportunidadeWhereInput
  }

  /**
   * Oportunidade upsert
   */
  export type OportunidadeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oportunidade
     */
    select?: OportunidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OportunidadeInclude<ExtArgs> | null
    /**
     * The filter to search for the Oportunidade to update in case it exists.
     */
    where: OportunidadeWhereUniqueInput
    /**
     * In case the Oportunidade found by the `where` argument doesn't exist, create a new Oportunidade with this data.
     */
    create: XOR<OportunidadeCreateInput, OportunidadeUncheckedCreateInput>
    /**
     * In case the Oportunidade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OportunidadeUpdateInput, OportunidadeUncheckedUpdateInput>
  }

  /**
   * Oportunidade delete
   */
  export type OportunidadeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oportunidade
     */
    select?: OportunidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OportunidadeInclude<ExtArgs> | null
    /**
     * Filter which Oportunidade to delete.
     */
    where: OportunidadeWhereUniqueInput
  }

  /**
   * Oportunidade deleteMany
   */
  export type OportunidadeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Oportunidades to delete
     */
    where?: OportunidadeWhereInput
  }

  /**
   * Oportunidade.categoriaCursoRelacionada
   */
  export type Oportunidade$categoriaCursoRelacionadaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCurso
     */
    select?: CategoriaCursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaCursoInclude<ExtArgs> | null
    where?: CategoriaCursoWhereInput
  }

  /**
   * Oportunidade.candidaturas
   */
  export type Oportunidade$candidaturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidatura
     */
    select?: CandidaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidaturaInclude<ExtArgs> | null
    where?: CandidaturaWhereInput
    orderBy?: CandidaturaOrderByWithRelationInput | CandidaturaOrderByWithRelationInput[]
    cursor?: CandidaturaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CandidaturaScalarFieldEnum | CandidaturaScalarFieldEnum[]
  }

  /**
   * Oportunidade without action
   */
  export type OportunidadeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Oportunidade
     */
    select?: OportunidadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OportunidadeInclude<ExtArgs> | null
  }


  /**
   * Model PostagemBlog
   */

  export type AggregatePostagemBlog = {
    _count: PostagemBlogCountAggregateOutputType | null
    _avg: PostagemBlogAvgAggregateOutputType | null
    _sum: PostagemBlogSumAggregateOutputType | null
    _min: PostagemBlogMinAggregateOutputType | null
    _max: PostagemBlogMaxAggregateOutputType | null
  }

  export type PostagemBlogAvgAggregateOutputType = {
    id: number | null
    autorId: number | null
  }

  export type PostagemBlogSumAggregateOutputType = {
    id: bigint | null
    autorId: bigint | null
  }

  export type PostagemBlogMinAggregateOutputType = {
    id: bigint | null
    autorId: bigint | null
    titulo: string | null
    conteudo: string | null
    slug: string | null
    publicadoEm: Date | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type PostagemBlogMaxAggregateOutputType = {
    id: bigint | null
    autorId: bigint | null
    titulo: string | null
    conteudo: string | null
    slug: string | null
    publicadoEm: Date | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type PostagemBlogCountAggregateOutputType = {
    id: number
    autorId: number
    titulo: number
    conteudo: number
    slug: number
    publicadoEm: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type PostagemBlogAvgAggregateInputType = {
    id?: true
    autorId?: true
  }

  export type PostagemBlogSumAggregateInputType = {
    id?: true
    autorId?: true
  }

  export type PostagemBlogMinAggregateInputType = {
    id?: true
    autorId?: true
    titulo?: true
    conteudo?: true
    slug?: true
    publicadoEm?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type PostagemBlogMaxAggregateInputType = {
    id?: true
    autorId?: true
    titulo?: true
    conteudo?: true
    slug?: true
    publicadoEm?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type PostagemBlogCountAggregateInputType = {
    id?: true
    autorId?: true
    titulo?: true
    conteudo?: true
    slug?: true
    publicadoEm?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type PostagemBlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostagemBlog to aggregate.
     */
    where?: PostagemBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostagemBlogs to fetch.
     */
    orderBy?: PostagemBlogOrderByWithRelationInput | PostagemBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostagemBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostagemBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostagemBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostagemBlogs
    **/
    _count?: true | PostagemBlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostagemBlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostagemBlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostagemBlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostagemBlogMaxAggregateInputType
  }

  export type GetPostagemBlogAggregateType<T extends PostagemBlogAggregateArgs> = {
        [P in keyof T & keyof AggregatePostagemBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostagemBlog[P]>
      : GetScalarType<T[P], AggregatePostagemBlog[P]>
  }




  export type PostagemBlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostagemBlogWhereInput
    orderBy?: PostagemBlogOrderByWithAggregationInput | PostagemBlogOrderByWithAggregationInput[]
    by: PostagemBlogScalarFieldEnum[] | PostagemBlogScalarFieldEnum
    having?: PostagemBlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostagemBlogCountAggregateInputType | true
    _avg?: PostagemBlogAvgAggregateInputType
    _sum?: PostagemBlogSumAggregateInputType
    _min?: PostagemBlogMinAggregateInputType
    _max?: PostagemBlogMaxAggregateInputType
  }

  export type PostagemBlogGroupByOutputType = {
    id: bigint
    autorId: bigint
    titulo: string
    conteudo: string
    slug: string
    publicadoEm: Date | null
    criadoEm: Date
    atualizadoEm: Date
    _count: PostagemBlogCountAggregateOutputType | null
    _avg: PostagemBlogAvgAggregateOutputType | null
    _sum: PostagemBlogSumAggregateOutputType | null
    _min: PostagemBlogMinAggregateOutputType | null
    _max: PostagemBlogMaxAggregateOutputType | null
  }

  type GetPostagemBlogGroupByPayload<T extends PostagemBlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostagemBlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostagemBlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostagemBlogGroupByOutputType[P]>
            : GetScalarType<T[P], PostagemBlogGroupByOutputType[P]>
        }
      >
    >


  export type PostagemBlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    autorId?: boolean
    titulo?: boolean
    conteudo?: boolean
    slug?: boolean
    publicadoEm?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    autor?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postagemBlog"]>

  export type PostagemBlogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    autorId?: boolean
    titulo?: boolean
    conteudo?: boolean
    slug?: boolean
    publicadoEm?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    autor?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postagemBlog"]>

  export type PostagemBlogSelectScalar = {
    id?: boolean
    autorId?: boolean
    titulo?: boolean
    conteudo?: boolean
    slug?: boolean
    publicadoEm?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type PostagemBlogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autor?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type PostagemBlogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autor?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $PostagemBlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostagemBlog"
    objects: {
      autor: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      autorId: bigint
      titulo: string
      conteudo: string
      slug: string
      publicadoEm: Date | null
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["postagemBlog"]>
    composites: {}
  }

  type PostagemBlogGetPayload<S extends boolean | null | undefined | PostagemBlogDefaultArgs> = $Result.GetResult<Prisma.$PostagemBlogPayload, S>

  type PostagemBlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostagemBlogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostagemBlogCountAggregateInputType | true
    }

  export interface PostagemBlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostagemBlog'], meta: { name: 'PostagemBlog' } }
    /**
     * Find zero or one PostagemBlog that matches the filter.
     * @param {PostagemBlogFindUniqueArgs} args - Arguments to find a PostagemBlog
     * @example
     * // Get one PostagemBlog
     * const postagemBlog = await prisma.postagemBlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostagemBlogFindUniqueArgs>(args: SelectSubset<T, PostagemBlogFindUniqueArgs<ExtArgs>>): Prisma__PostagemBlogClient<$Result.GetResult<Prisma.$PostagemBlogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostagemBlog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostagemBlogFindUniqueOrThrowArgs} args - Arguments to find a PostagemBlog
     * @example
     * // Get one PostagemBlog
     * const postagemBlog = await prisma.postagemBlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostagemBlogFindUniqueOrThrowArgs>(args: SelectSubset<T, PostagemBlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostagemBlogClient<$Result.GetResult<Prisma.$PostagemBlogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostagemBlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostagemBlogFindFirstArgs} args - Arguments to find a PostagemBlog
     * @example
     * // Get one PostagemBlog
     * const postagemBlog = await prisma.postagemBlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostagemBlogFindFirstArgs>(args?: SelectSubset<T, PostagemBlogFindFirstArgs<ExtArgs>>): Prisma__PostagemBlogClient<$Result.GetResult<Prisma.$PostagemBlogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostagemBlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostagemBlogFindFirstOrThrowArgs} args - Arguments to find a PostagemBlog
     * @example
     * // Get one PostagemBlog
     * const postagemBlog = await prisma.postagemBlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostagemBlogFindFirstOrThrowArgs>(args?: SelectSubset<T, PostagemBlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostagemBlogClient<$Result.GetResult<Prisma.$PostagemBlogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostagemBlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostagemBlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostagemBlogs
     * const postagemBlogs = await prisma.postagemBlog.findMany()
     * 
     * // Get first 10 PostagemBlogs
     * const postagemBlogs = await prisma.postagemBlog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postagemBlogWithIdOnly = await prisma.postagemBlog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostagemBlogFindManyArgs>(args?: SelectSubset<T, PostagemBlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostagemBlogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostagemBlog.
     * @param {PostagemBlogCreateArgs} args - Arguments to create a PostagemBlog.
     * @example
     * // Create one PostagemBlog
     * const PostagemBlog = await prisma.postagemBlog.create({
     *   data: {
     *     // ... data to create a PostagemBlog
     *   }
     * })
     * 
     */
    create<T extends PostagemBlogCreateArgs>(args: SelectSubset<T, PostagemBlogCreateArgs<ExtArgs>>): Prisma__PostagemBlogClient<$Result.GetResult<Prisma.$PostagemBlogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostagemBlogs.
     * @param {PostagemBlogCreateManyArgs} args - Arguments to create many PostagemBlogs.
     * @example
     * // Create many PostagemBlogs
     * const postagemBlog = await prisma.postagemBlog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostagemBlogCreateManyArgs>(args?: SelectSubset<T, PostagemBlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostagemBlogs and returns the data saved in the database.
     * @param {PostagemBlogCreateManyAndReturnArgs} args - Arguments to create many PostagemBlogs.
     * @example
     * // Create many PostagemBlogs
     * const postagemBlog = await prisma.postagemBlog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostagemBlogs and only return the `id`
     * const postagemBlogWithIdOnly = await prisma.postagemBlog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostagemBlogCreateManyAndReturnArgs>(args?: SelectSubset<T, PostagemBlogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostagemBlogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostagemBlog.
     * @param {PostagemBlogDeleteArgs} args - Arguments to delete one PostagemBlog.
     * @example
     * // Delete one PostagemBlog
     * const PostagemBlog = await prisma.postagemBlog.delete({
     *   where: {
     *     // ... filter to delete one PostagemBlog
     *   }
     * })
     * 
     */
    delete<T extends PostagemBlogDeleteArgs>(args: SelectSubset<T, PostagemBlogDeleteArgs<ExtArgs>>): Prisma__PostagemBlogClient<$Result.GetResult<Prisma.$PostagemBlogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostagemBlog.
     * @param {PostagemBlogUpdateArgs} args - Arguments to update one PostagemBlog.
     * @example
     * // Update one PostagemBlog
     * const postagemBlog = await prisma.postagemBlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostagemBlogUpdateArgs>(args: SelectSubset<T, PostagemBlogUpdateArgs<ExtArgs>>): Prisma__PostagemBlogClient<$Result.GetResult<Prisma.$PostagemBlogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostagemBlogs.
     * @param {PostagemBlogDeleteManyArgs} args - Arguments to filter PostagemBlogs to delete.
     * @example
     * // Delete a few PostagemBlogs
     * const { count } = await prisma.postagemBlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostagemBlogDeleteManyArgs>(args?: SelectSubset<T, PostagemBlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostagemBlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostagemBlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostagemBlogs
     * const postagemBlog = await prisma.postagemBlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostagemBlogUpdateManyArgs>(args: SelectSubset<T, PostagemBlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostagemBlog.
     * @param {PostagemBlogUpsertArgs} args - Arguments to update or create a PostagemBlog.
     * @example
     * // Update or create a PostagemBlog
     * const postagemBlog = await prisma.postagemBlog.upsert({
     *   create: {
     *     // ... data to create a PostagemBlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostagemBlog we want to update
     *   }
     * })
     */
    upsert<T extends PostagemBlogUpsertArgs>(args: SelectSubset<T, PostagemBlogUpsertArgs<ExtArgs>>): Prisma__PostagemBlogClient<$Result.GetResult<Prisma.$PostagemBlogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostagemBlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostagemBlogCountArgs} args - Arguments to filter PostagemBlogs to count.
     * @example
     * // Count the number of PostagemBlogs
     * const count = await prisma.postagemBlog.count({
     *   where: {
     *     // ... the filter for the PostagemBlogs we want to count
     *   }
     * })
    **/
    count<T extends PostagemBlogCountArgs>(
      args?: Subset<T, PostagemBlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostagemBlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostagemBlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostagemBlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostagemBlogAggregateArgs>(args: Subset<T, PostagemBlogAggregateArgs>): Prisma.PrismaPromise<GetPostagemBlogAggregateType<T>>

    /**
     * Group by PostagemBlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostagemBlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostagemBlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostagemBlogGroupByArgs['orderBy'] }
        : { orderBy?: PostagemBlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostagemBlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostagemBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostagemBlog model
   */
  readonly fields: PostagemBlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostagemBlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostagemBlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    autor<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostagemBlog model
   */ 
  interface PostagemBlogFieldRefs {
    readonly id: FieldRef<"PostagemBlog", 'BigInt'>
    readonly autorId: FieldRef<"PostagemBlog", 'BigInt'>
    readonly titulo: FieldRef<"PostagemBlog", 'String'>
    readonly conteudo: FieldRef<"PostagemBlog", 'String'>
    readonly slug: FieldRef<"PostagemBlog", 'String'>
    readonly publicadoEm: FieldRef<"PostagemBlog", 'DateTime'>
    readonly criadoEm: FieldRef<"PostagemBlog", 'DateTime'>
    readonly atualizadoEm: FieldRef<"PostagemBlog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostagemBlog findUnique
   */
  export type PostagemBlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostagemBlog
     */
    select?: PostagemBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostagemBlogInclude<ExtArgs> | null
    /**
     * Filter, which PostagemBlog to fetch.
     */
    where: PostagemBlogWhereUniqueInput
  }

  /**
   * PostagemBlog findUniqueOrThrow
   */
  export type PostagemBlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostagemBlog
     */
    select?: PostagemBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostagemBlogInclude<ExtArgs> | null
    /**
     * Filter, which PostagemBlog to fetch.
     */
    where: PostagemBlogWhereUniqueInput
  }

  /**
   * PostagemBlog findFirst
   */
  export type PostagemBlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostagemBlog
     */
    select?: PostagemBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostagemBlogInclude<ExtArgs> | null
    /**
     * Filter, which PostagemBlog to fetch.
     */
    where?: PostagemBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostagemBlogs to fetch.
     */
    orderBy?: PostagemBlogOrderByWithRelationInput | PostagemBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostagemBlogs.
     */
    cursor?: PostagemBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostagemBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostagemBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostagemBlogs.
     */
    distinct?: PostagemBlogScalarFieldEnum | PostagemBlogScalarFieldEnum[]
  }

  /**
   * PostagemBlog findFirstOrThrow
   */
  export type PostagemBlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostagemBlog
     */
    select?: PostagemBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostagemBlogInclude<ExtArgs> | null
    /**
     * Filter, which PostagemBlog to fetch.
     */
    where?: PostagemBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostagemBlogs to fetch.
     */
    orderBy?: PostagemBlogOrderByWithRelationInput | PostagemBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostagemBlogs.
     */
    cursor?: PostagemBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostagemBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostagemBlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostagemBlogs.
     */
    distinct?: PostagemBlogScalarFieldEnum | PostagemBlogScalarFieldEnum[]
  }

  /**
   * PostagemBlog findMany
   */
  export type PostagemBlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostagemBlog
     */
    select?: PostagemBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostagemBlogInclude<ExtArgs> | null
    /**
     * Filter, which PostagemBlogs to fetch.
     */
    where?: PostagemBlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostagemBlogs to fetch.
     */
    orderBy?: PostagemBlogOrderByWithRelationInput | PostagemBlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostagemBlogs.
     */
    cursor?: PostagemBlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostagemBlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostagemBlogs.
     */
    skip?: number
    distinct?: PostagemBlogScalarFieldEnum | PostagemBlogScalarFieldEnum[]
  }

  /**
   * PostagemBlog create
   */
  export type PostagemBlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostagemBlog
     */
    select?: PostagemBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostagemBlogInclude<ExtArgs> | null
    /**
     * The data needed to create a PostagemBlog.
     */
    data: XOR<PostagemBlogCreateInput, PostagemBlogUncheckedCreateInput>
  }

  /**
   * PostagemBlog createMany
   */
  export type PostagemBlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostagemBlogs.
     */
    data: PostagemBlogCreateManyInput | PostagemBlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostagemBlog createManyAndReturn
   */
  export type PostagemBlogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostagemBlog
     */
    select?: PostagemBlogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostagemBlogs.
     */
    data: PostagemBlogCreateManyInput | PostagemBlogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostagemBlogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostagemBlog update
   */
  export type PostagemBlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostagemBlog
     */
    select?: PostagemBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostagemBlogInclude<ExtArgs> | null
    /**
     * The data needed to update a PostagemBlog.
     */
    data: XOR<PostagemBlogUpdateInput, PostagemBlogUncheckedUpdateInput>
    /**
     * Choose, which PostagemBlog to update.
     */
    where: PostagemBlogWhereUniqueInput
  }

  /**
   * PostagemBlog updateMany
   */
  export type PostagemBlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostagemBlogs.
     */
    data: XOR<PostagemBlogUpdateManyMutationInput, PostagemBlogUncheckedUpdateManyInput>
    /**
     * Filter which PostagemBlogs to update
     */
    where?: PostagemBlogWhereInput
  }

  /**
   * PostagemBlog upsert
   */
  export type PostagemBlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostagemBlog
     */
    select?: PostagemBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostagemBlogInclude<ExtArgs> | null
    /**
     * The filter to search for the PostagemBlog to update in case it exists.
     */
    where: PostagemBlogWhereUniqueInput
    /**
     * In case the PostagemBlog found by the `where` argument doesn't exist, create a new PostagemBlog with this data.
     */
    create: XOR<PostagemBlogCreateInput, PostagemBlogUncheckedCreateInput>
    /**
     * In case the PostagemBlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostagemBlogUpdateInput, PostagemBlogUncheckedUpdateInput>
  }

  /**
   * PostagemBlog delete
   */
  export type PostagemBlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostagemBlog
     */
    select?: PostagemBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostagemBlogInclude<ExtArgs> | null
    /**
     * Filter which PostagemBlog to delete.
     */
    where: PostagemBlogWhereUniqueInput
  }

  /**
   * PostagemBlog deleteMany
   */
  export type PostagemBlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostagemBlogs to delete
     */
    where?: PostagemBlogWhereInput
  }

  /**
   * PostagemBlog without action
   */
  export type PostagemBlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostagemBlog
     */
    select?: PostagemBlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostagemBlogInclude<ExtArgs> | null
  }


  /**
   * Model Matricula
   */

  export type AggregateMatricula = {
    _count: MatriculaCountAggregateOutputType | null
    _avg: MatriculaAvgAggregateOutputType | null
    _sum: MatriculaSumAggregateOutputType | null
    _min: MatriculaMinAggregateOutputType | null
    _max: MatriculaMaxAggregateOutputType | null
  }

  export type MatriculaAvgAggregateOutputType = {
    id: number | null
    cursoId: number | null
    usuarioId: number | null
  }

  export type MatriculaSumAggregateOutputType = {
    id: bigint | null
    cursoId: bigint | null
    usuarioId: bigint | null
  }

  export type MatriculaMinAggregateOutputType = {
    id: bigint | null
    cursoId: bigint | null
    usuarioId: bigint | null
    status: string | null
    dataInscricao: Date | null
  }

  export type MatriculaMaxAggregateOutputType = {
    id: bigint | null
    cursoId: bigint | null
    usuarioId: bigint | null
    status: string | null
    dataInscricao: Date | null
  }

  export type MatriculaCountAggregateOutputType = {
    id: number
    cursoId: number
    usuarioId: number
    status: number
    dataInscricao: number
    _all: number
  }


  export type MatriculaAvgAggregateInputType = {
    id?: true
    cursoId?: true
    usuarioId?: true
  }

  export type MatriculaSumAggregateInputType = {
    id?: true
    cursoId?: true
    usuarioId?: true
  }

  export type MatriculaMinAggregateInputType = {
    id?: true
    cursoId?: true
    usuarioId?: true
    status?: true
    dataInscricao?: true
  }

  export type MatriculaMaxAggregateInputType = {
    id?: true
    cursoId?: true
    usuarioId?: true
    status?: true
    dataInscricao?: true
  }

  export type MatriculaCountAggregateInputType = {
    id?: true
    cursoId?: true
    usuarioId?: true
    status?: true
    dataInscricao?: true
    _all?: true
  }

  export type MatriculaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matricula to aggregate.
     */
    where?: MatriculaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matriculas to fetch.
     */
    orderBy?: MatriculaOrderByWithRelationInput | MatriculaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatriculaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matriculas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matriculas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matriculas
    **/
    _count?: true | MatriculaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatriculaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatriculaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatriculaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatriculaMaxAggregateInputType
  }

  export type GetMatriculaAggregateType<T extends MatriculaAggregateArgs> = {
        [P in keyof T & keyof AggregateMatricula]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatricula[P]>
      : GetScalarType<T[P], AggregateMatricula[P]>
  }




  export type MatriculaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatriculaWhereInput
    orderBy?: MatriculaOrderByWithAggregationInput | MatriculaOrderByWithAggregationInput[]
    by: MatriculaScalarFieldEnum[] | MatriculaScalarFieldEnum
    having?: MatriculaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatriculaCountAggregateInputType | true
    _avg?: MatriculaAvgAggregateInputType
    _sum?: MatriculaSumAggregateInputType
    _min?: MatriculaMinAggregateInputType
    _max?: MatriculaMaxAggregateInputType
  }

  export type MatriculaGroupByOutputType = {
    id: bigint
    cursoId: bigint
    usuarioId: bigint
    status: string
    dataInscricao: Date
    _count: MatriculaCountAggregateOutputType | null
    _avg: MatriculaAvgAggregateOutputType | null
    _sum: MatriculaSumAggregateOutputType | null
    _min: MatriculaMinAggregateOutputType | null
    _max: MatriculaMaxAggregateOutputType | null
  }

  type GetMatriculaGroupByPayload<T extends MatriculaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatriculaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatriculaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatriculaGroupByOutputType[P]>
            : GetScalarType<T[P], MatriculaGroupByOutputType[P]>
        }
      >
    >


  export type MatriculaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    usuarioId?: boolean
    status?: boolean
    dataInscricao?: boolean
    curso?: boolean | CursoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matricula"]>

  export type MatriculaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    usuarioId?: boolean
    status?: boolean
    dataInscricao?: boolean
    curso?: boolean | CursoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matricula"]>

  export type MatriculaSelectScalar = {
    id?: boolean
    cursoId?: boolean
    usuarioId?: boolean
    status?: boolean
    dataInscricao?: boolean
  }

  export type MatriculaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | CursoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type MatriculaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | CursoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $MatriculaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Matricula"
    objects: {
      curso: Prisma.$CursoPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      cursoId: bigint
      usuarioId: bigint
      status: string
      dataInscricao: Date
    }, ExtArgs["result"]["matricula"]>
    composites: {}
  }

  type MatriculaGetPayload<S extends boolean | null | undefined | MatriculaDefaultArgs> = $Result.GetResult<Prisma.$MatriculaPayload, S>

  type MatriculaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatriculaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatriculaCountAggregateInputType | true
    }

  export interface MatriculaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Matricula'], meta: { name: 'Matricula' } }
    /**
     * Find zero or one Matricula that matches the filter.
     * @param {MatriculaFindUniqueArgs} args - Arguments to find a Matricula
     * @example
     * // Get one Matricula
     * const matricula = await prisma.matricula.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatriculaFindUniqueArgs>(args: SelectSubset<T, MatriculaFindUniqueArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Matricula that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MatriculaFindUniqueOrThrowArgs} args - Arguments to find a Matricula
     * @example
     * // Get one Matricula
     * const matricula = await prisma.matricula.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatriculaFindUniqueOrThrowArgs>(args: SelectSubset<T, MatriculaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Matricula that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatriculaFindFirstArgs} args - Arguments to find a Matricula
     * @example
     * // Get one Matricula
     * const matricula = await prisma.matricula.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatriculaFindFirstArgs>(args?: SelectSubset<T, MatriculaFindFirstArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Matricula that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatriculaFindFirstOrThrowArgs} args - Arguments to find a Matricula
     * @example
     * // Get one Matricula
     * const matricula = await prisma.matricula.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatriculaFindFirstOrThrowArgs>(args?: SelectSubset<T, MatriculaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Matriculas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatriculaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matriculas
     * const matriculas = await prisma.matricula.findMany()
     * 
     * // Get first 10 Matriculas
     * const matriculas = await prisma.matricula.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matriculaWithIdOnly = await prisma.matricula.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatriculaFindManyArgs>(args?: SelectSubset<T, MatriculaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Matricula.
     * @param {MatriculaCreateArgs} args - Arguments to create a Matricula.
     * @example
     * // Create one Matricula
     * const Matricula = await prisma.matricula.create({
     *   data: {
     *     // ... data to create a Matricula
     *   }
     * })
     * 
     */
    create<T extends MatriculaCreateArgs>(args: SelectSubset<T, MatriculaCreateArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Matriculas.
     * @param {MatriculaCreateManyArgs} args - Arguments to create many Matriculas.
     * @example
     * // Create many Matriculas
     * const matricula = await prisma.matricula.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatriculaCreateManyArgs>(args?: SelectSubset<T, MatriculaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Matriculas and returns the data saved in the database.
     * @param {MatriculaCreateManyAndReturnArgs} args - Arguments to create many Matriculas.
     * @example
     * // Create many Matriculas
     * const matricula = await prisma.matricula.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Matriculas and only return the `id`
     * const matriculaWithIdOnly = await prisma.matricula.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatriculaCreateManyAndReturnArgs>(args?: SelectSubset<T, MatriculaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Matricula.
     * @param {MatriculaDeleteArgs} args - Arguments to delete one Matricula.
     * @example
     * // Delete one Matricula
     * const Matricula = await prisma.matricula.delete({
     *   where: {
     *     // ... filter to delete one Matricula
     *   }
     * })
     * 
     */
    delete<T extends MatriculaDeleteArgs>(args: SelectSubset<T, MatriculaDeleteArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Matricula.
     * @param {MatriculaUpdateArgs} args - Arguments to update one Matricula.
     * @example
     * // Update one Matricula
     * const matricula = await prisma.matricula.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatriculaUpdateArgs>(args: SelectSubset<T, MatriculaUpdateArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Matriculas.
     * @param {MatriculaDeleteManyArgs} args - Arguments to filter Matriculas to delete.
     * @example
     * // Delete a few Matriculas
     * const { count } = await prisma.matricula.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatriculaDeleteManyArgs>(args?: SelectSubset<T, MatriculaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matriculas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatriculaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matriculas
     * const matricula = await prisma.matricula.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatriculaUpdateManyArgs>(args: SelectSubset<T, MatriculaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Matricula.
     * @param {MatriculaUpsertArgs} args - Arguments to update or create a Matricula.
     * @example
     * // Update or create a Matricula
     * const matricula = await prisma.matricula.upsert({
     *   create: {
     *     // ... data to create a Matricula
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Matricula we want to update
     *   }
     * })
     */
    upsert<T extends MatriculaUpsertArgs>(args: SelectSubset<T, MatriculaUpsertArgs<ExtArgs>>): Prisma__MatriculaClient<$Result.GetResult<Prisma.$MatriculaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Matriculas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatriculaCountArgs} args - Arguments to filter Matriculas to count.
     * @example
     * // Count the number of Matriculas
     * const count = await prisma.matricula.count({
     *   where: {
     *     // ... the filter for the Matriculas we want to count
     *   }
     * })
    **/
    count<T extends MatriculaCountArgs>(
      args?: Subset<T, MatriculaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatriculaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Matricula.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatriculaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatriculaAggregateArgs>(args: Subset<T, MatriculaAggregateArgs>): Prisma.PrismaPromise<GetMatriculaAggregateType<T>>

    /**
     * Group by Matricula.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatriculaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatriculaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatriculaGroupByArgs['orderBy'] }
        : { orderBy?: MatriculaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatriculaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatriculaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Matricula model
   */
  readonly fields: MatriculaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Matricula.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatriculaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    curso<T extends CursoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CursoDefaultArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Matricula model
   */ 
  interface MatriculaFieldRefs {
    readonly id: FieldRef<"Matricula", 'BigInt'>
    readonly cursoId: FieldRef<"Matricula", 'BigInt'>
    readonly usuarioId: FieldRef<"Matricula", 'BigInt'>
    readonly status: FieldRef<"Matricula", 'String'>
    readonly dataInscricao: FieldRef<"Matricula", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Matricula findUnique
   */
  export type MatriculaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * Filter, which Matricula to fetch.
     */
    where: MatriculaWhereUniqueInput
  }

  /**
   * Matricula findUniqueOrThrow
   */
  export type MatriculaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * Filter, which Matricula to fetch.
     */
    where: MatriculaWhereUniqueInput
  }

  /**
   * Matricula findFirst
   */
  export type MatriculaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * Filter, which Matricula to fetch.
     */
    where?: MatriculaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matriculas to fetch.
     */
    orderBy?: MatriculaOrderByWithRelationInput | MatriculaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matriculas.
     */
    cursor?: MatriculaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matriculas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matriculas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matriculas.
     */
    distinct?: MatriculaScalarFieldEnum | MatriculaScalarFieldEnum[]
  }

  /**
   * Matricula findFirstOrThrow
   */
  export type MatriculaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * Filter, which Matricula to fetch.
     */
    where?: MatriculaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matriculas to fetch.
     */
    orderBy?: MatriculaOrderByWithRelationInput | MatriculaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matriculas.
     */
    cursor?: MatriculaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matriculas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matriculas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matriculas.
     */
    distinct?: MatriculaScalarFieldEnum | MatriculaScalarFieldEnum[]
  }

  /**
   * Matricula findMany
   */
  export type MatriculaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * Filter, which Matriculas to fetch.
     */
    where?: MatriculaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matriculas to fetch.
     */
    orderBy?: MatriculaOrderByWithRelationInput | MatriculaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matriculas.
     */
    cursor?: MatriculaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matriculas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matriculas.
     */
    skip?: number
    distinct?: MatriculaScalarFieldEnum | MatriculaScalarFieldEnum[]
  }

  /**
   * Matricula create
   */
  export type MatriculaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * The data needed to create a Matricula.
     */
    data: XOR<MatriculaCreateInput, MatriculaUncheckedCreateInput>
  }

  /**
   * Matricula createMany
   */
  export type MatriculaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matriculas.
     */
    data: MatriculaCreateManyInput | MatriculaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Matricula createManyAndReturn
   */
  export type MatriculaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Matriculas.
     */
    data: MatriculaCreateManyInput | MatriculaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Matricula update
   */
  export type MatriculaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * The data needed to update a Matricula.
     */
    data: XOR<MatriculaUpdateInput, MatriculaUncheckedUpdateInput>
    /**
     * Choose, which Matricula to update.
     */
    where: MatriculaWhereUniqueInput
  }

  /**
   * Matricula updateMany
   */
  export type MatriculaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matriculas.
     */
    data: XOR<MatriculaUpdateManyMutationInput, MatriculaUncheckedUpdateManyInput>
    /**
     * Filter which Matriculas to update
     */
    where?: MatriculaWhereInput
  }

  /**
   * Matricula upsert
   */
  export type MatriculaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * The filter to search for the Matricula to update in case it exists.
     */
    where: MatriculaWhereUniqueInput
    /**
     * In case the Matricula found by the `where` argument doesn't exist, create a new Matricula with this data.
     */
    create: XOR<MatriculaCreateInput, MatriculaUncheckedCreateInput>
    /**
     * In case the Matricula was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatriculaUpdateInput, MatriculaUncheckedUpdateInput>
  }

  /**
   * Matricula delete
   */
  export type MatriculaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
    /**
     * Filter which Matricula to delete.
     */
    where: MatriculaWhereUniqueInput
  }

  /**
   * Matricula deleteMany
   */
  export type MatriculaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matriculas to delete
     */
    where?: MatriculaWhereInput
  }

  /**
   * Matricula without action
   */
  export type MatriculaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matricula
     */
    select?: MatriculaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatriculaInclude<ExtArgs> | null
  }


  /**
   * Model Candidatura
   */

  export type AggregateCandidatura = {
    _count: CandidaturaCountAggregateOutputType | null
    _avg: CandidaturaAvgAggregateOutputType | null
    _sum: CandidaturaSumAggregateOutputType | null
    _min: CandidaturaMinAggregateOutputType | null
    _max: CandidaturaMaxAggregateOutputType | null
  }

  export type CandidaturaAvgAggregateOutputType = {
    id: number | null
    oportunidadeId: number | null
    usuarioId: number | null
  }

  export type CandidaturaSumAggregateOutputType = {
    id: bigint | null
    oportunidadeId: bigint | null
    usuarioId: bigint | null
  }

  export type CandidaturaMinAggregateOutputType = {
    id: bigint | null
    oportunidadeId: bigint | null
    usuarioId: bigint | null
    status: string | null
    dataCandidatura: Date | null
  }

  export type CandidaturaMaxAggregateOutputType = {
    id: bigint | null
    oportunidadeId: bigint | null
    usuarioId: bigint | null
    status: string | null
    dataCandidatura: Date | null
  }

  export type CandidaturaCountAggregateOutputType = {
    id: number
    oportunidadeId: number
    usuarioId: number
    status: number
    dataCandidatura: number
    _all: number
  }


  export type CandidaturaAvgAggregateInputType = {
    id?: true
    oportunidadeId?: true
    usuarioId?: true
  }

  export type CandidaturaSumAggregateInputType = {
    id?: true
    oportunidadeId?: true
    usuarioId?: true
  }

  export type CandidaturaMinAggregateInputType = {
    id?: true
    oportunidadeId?: true
    usuarioId?: true
    status?: true
    dataCandidatura?: true
  }

  export type CandidaturaMaxAggregateInputType = {
    id?: true
    oportunidadeId?: true
    usuarioId?: true
    status?: true
    dataCandidatura?: true
  }

  export type CandidaturaCountAggregateInputType = {
    id?: true
    oportunidadeId?: true
    usuarioId?: true
    status?: true
    dataCandidatura?: true
    _all?: true
  }

  export type CandidaturaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Candidatura to aggregate.
     */
    where?: CandidaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidaturas to fetch.
     */
    orderBy?: CandidaturaOrderByWithRelationInput | CandidaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CandidaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidaturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Candidaturas
    **/
    _count?: true | CandidaturaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CandidaturaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CandidaturaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CandidaturaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CandidaturaMaxAggregateInputType
  }

  export type GetCandidaturaAggregateType<T extends CandidaturaAggregateArgs> = {
        [P in keyof T & keyof AggregateCandidatura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCandidatura[P]>
      : GetScalarType<T[P], AggregateCandidatura[P]>
  }




  export type CandidaturaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidaturaWhereInput
    orderBy?: CandidaturaOrderByWithAggregationInput | CandidaturaOrderByWithAggregationInput[]
    by: CandidaturaScalarFieldEnum[] | CandidaturaScalarFieldEnum
    having?: CandidaturaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CandidaturaCountAggregateInputType | true
    _avg?: CandidaturaAvgAggregateInputType
    _sum?: CandidaturaSumAggregateInputType
    _min?: CandidaturaMinAggregateInputType
    _max?: CandidaturaMaxAggregateInputType
  }

  export type CandidaturaGroupByOutputType = {
    id: bigint
    oportunidadeId: bigint
    usuarioId: bigint
    status: string
    dataCandidatura: Date
    _count: CandidaturaCountAggregateOutputType | null
    _avg: CandidaturaAvgAggregateOutputType | null
    _sum: CandidaturaSumAggregateOutputType | null
    _min: CandidaturaMinAggregateOutputType | null
    _max: CandidaturaMaxAggregateOutputType | null
  }

  type GetCandidaturaGroupByPayload<T extends CandidaturaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CandidaturaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CandidaturaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CandidaturaGroupByOutputType[P]>
            : GetScalarType<T[P], CandidaturaGroupByOutputType[P]>
        }
      >
    >


  export type CandidaturaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    oportunidadeId?: boolean
    usuarioId?: boolean
    status?: boolean
    dataCandidatura?: boolean
    oportunidade?: boolean | OportunidadeDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidatura"]>

  export type CandidaturaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    oportunidadeId?: boolean
    usuarioId?: boolean
    status?: boolean
    dataCandidatura?: boolean
    oportunidade?: boolean | OportunidadeDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidatura"]>

  export type CandidaturaSelectScalar = {
    id?: boolean
    oportunidadeId?: boolean
    usuarioId?: boolean
    status?: boolean
    dataCandidatura?: boolean
  }

  export type CandidaturaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    oportunidade?: boolean | OportunidadeDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type CandidaturaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    oportunidade?: boolean | OportunidadeDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $CandidaturaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Candidatura"
    objects: {
      oportunidade: Prisma.$OportunidadePayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      oportunidadeId: bigint
      usuarioId: bigint
      status: string
      dataCandidatura: Date
    }, ExtArgs["result"]["candidatura"]>
    composites: {}
  }

  type CandidaturaGetPayload<S extends boolean | null | undefined | CandidaturaDefaultArgs> = $Result.GetResult<Prisma.$CandidaturaPayload, S>

  type CandidaturaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CandidaturaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CandidaturaCountAggregateInputType | true
    }

  export interface CandidaturaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Candidatura'], meta: { name: 'Candidatura' } }
    /**
     * Find zero or one Candidatura that matches the filter.
     * @param {CandidaturaFindUniqueArgs} args - Arguments to find a Candidatura
     * @example
     * // Get one Candidatura
     * const candidatura = await prisma.candidatura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CandidaturaFindUniqueArgs>(args: SelectSubset<T, CandidaturaFindUniqueArgs<ExtArgs>>): Prisma__CandidaturaClient<$Result.GetResult<Prisma.$CandidaturaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Candidatura that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CandidaturaFindUniqueOrThrowArgs} args - Arguments to find a Candidatura
     * @example
     * // Get one Candidatura
     * const candidatura = await prisma.candidatura.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CandidaturaFindUniqueOrThrowArgs>(args: SelectSubset<T, CandidaturaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CandidaturaClient<$Result.GetResult<Prisma.$CandidaturaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Candidatura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidaturaFindFirstArgs} args - Arguments to find a Candidatura
     * @example
     * // Get one Candidatura
     * const candidatura = await prisma.candidatura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CandidaturaFindFirstArgs>(args?: SelectSubset<T, CandidaturaFindFirstArgs<ExtArgs>>): Prisma__CandidaturaClient<$Result.GetResult<Prisma.$CandidaturaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Candidatura that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidaturaFindFirstOrThrowArgs} args - Arguments to find a Candidatura
     * @example
     * // Get one Candidatura
     * const candidatura = await prisma.candidatura.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CandidaturaFindFirstOrThrowArgs>(args?: SelectSubset<T, CandidaturaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CandidaturaClient<$Result.GetResult<Prisma.$CandidaturaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Candidaturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidaturaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Candidaturas
     * const candidaturas = await prisma.candidatura.findMany()
     * 
     * // Get first 10 Candidaturas
     * const candidaturas = await prisma.candidatura.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const candidaturaWithIdOnly = await prisma.candidatura.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CandidaturaFindManyArgs>(args?: SelectSubset<T, CandidaturaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidaturaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Candidatura.
     * @param {CandidaturaCreateArgs} args - Arguments to create a Candidatura.
     * @example
     * // Create one Candidatura
     * const Candidatura = await prisma.candidatura.create({
     *   data: {
     *     // ... data to create a Candidatura
     *   }
     * })
     * 
     */
    create<T extends CandidaturaCreateArgs>(args: SelectSubset<T, CandidaturaCreateArgs<ExtArgs>>): Prisma__CandidaturaClient<$Result.GetResult<Prisma.$CandidaturaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Candidaturas.
     * @param {CandidaturaCreateManyArgs} args - Arguments to create many Candidaturas.
     * @example
     * // Create many Candidaturas
     * const candidatura = await prisma.candidatura.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CandidaturaCreateManyArgs>(args?: SelectSubset<T, CandidaturaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Candidaturas and returns the data saved in the database.
     * @param {CandidaturaCreateManyAndReturnArgs} args - Arguments to create many Candidaturas.
     * @example
     * // Create many Candidaturas
     * const candidatura = await prisma.candidatura.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Candidaturas and only return the `id`
     * const candidaturaWithIdOnly = await prisma.candidatura.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CandidaturaCreateManyAndReturnArgs>(args?: SelectSubset<T, CandidaturaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidaturaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Candidatura.
     * @param {CandidaturaDeleteArgs} args - Arguments to delete one Candidatura.
     * @example
     * // Delete one Candidatura
     * const Candidatura = await prisma.candidatura.delete({
     *   where: {
     *     // ... filter to delete one Candidatura
     *   }
     * })
     * 
     */
    delete<T extends CandidaturaDeleteArgs>(args: SelectSubset<T, CandidaturaDeleteArgs<ExtArgs>>): Prisma__CandidaturaClient<$Result.GetResult<Prisma.$CandidaturaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Candidatura.
     * @param {CandidaturaUpdateArgs} args - Arguments to update one Candidatura.
     * @example
     * // Update one Candidatura
     * const candidatura = await prisma.candidatura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CandidaturaUpdateArgs>(args: SelectSubset<T, CandidaturaUpdateArgs<ExtArgs>>): Prisma__CandidaturaClient<$Result.GetResult<Prisma.$CandidaturaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Candidaturas.
     * @param {CandidaturaDeleteManyArgs} args - Arguments to filter Candidaturas to delete.
     * @example
     * // Delete a few Candidaturas
     * const { count } = await prisma.candidatura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CandidaturaDeleteManyArgs>(args?: SelectSubset<T, CandidaturaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Candidaturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidaturaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Candidaturas
     * const candidatura = await prisma.candidatura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CandidaturaUpdateManyArgs>(args: SelectSubset<T, CandidaturaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Candidatura.
     * @param {CandidaturaUpsertArgs} args - Arguments to update or create a Candidatura.
     * @example
     * // Update or create a Candidatura
     * const candidatura = await prisma.candidatura.upsert({
     *   create: {
     *     // ... data to create a Candidatura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Candidatura we want to update
     *   }
     * })
     */
    upsert<T extends CandidaturaUpsertArgs>(args: SelectSubset<T, CandidaturaUpsertArgs<ExtArgs>>): Prisma__CandidaturaClient<$Result.GetResult<Prisma.$CandidaturaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Candidaturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidaturaCountArgs} args - Arguments to filter Candidaturas to count.
     * @example
     * // Count the number of Candidaturas
     * const count = await prisma.candidatura.count({
     *   where: {
     *     // ... the filter for the Candidaturas we want to count
     *   }
     * })
    **/
    count<T extends CandidaturaCountArgs>(
      args?: Subset<T, CandidaturaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CandidaturaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Candidatura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidaturaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CandidaturaAggregateArgs>(args: Subset<T, CandidaturaAggregateArgs>): Prisma.PrismaPromise<GetCandidaturaAggregateType<T>>

    /**
     * Group by Candidatura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidaturaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CandidaturaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CandidaturaGroupByArgs['orderBy'] }
        : { orderBy?: CandidaturaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CandidaturaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCandidaturaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Candidatura model
   */
  readonly fields: CandidaturaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Candidatura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CandidaturaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    oportunidade<T extends OportunidadeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OportunidadeDefaultArgs<ExtArgs>>): Prisma__OportunidadeClient<$Result.GetResult<Prisma.$OportunidadePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Candidatura model
   */ 
  interface CandidaturaFieldRefs {
    readonly id: FieldRef<"Candidatura", 'BigInt'>
    readonly oportunidadeId: FieldRef<"Candidatura", 'BigInt'>
    readonly usuarioId: FieldRef<"Candidatura", 'BigInt'>
    readonly status: FieldRef<"Candidatura", 'String'>
    readonly dataCandidatura: FieldRef<"Candidatura", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Candidatura findUnique
   */
  export type CandidaturaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidatura
     */
    select?: CandidaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidaturaInclude<ExtArgs> | null
    /**
     * Filter, which Candidatura to fetch.
     */
    where: CandidaturaWhereUniqueInput
  }

  /**
   * Candidatura findUniqueOrThrow
   */
  export type CandidaturaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidatura
     */
    select?: CandidaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidaturaInclude<ExtArgs> | null
    /**
     * Filter, which Candidatura to fetch.
     */
    where: CandidaturaWhereUniqueInput
  }

  /**
   * Candidatura findFirst
   */
  export type CandidaturaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidatura
     */
    select?: CandidaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidaturaInclude<ExtArgs> | null
    /**
     * Filter, which Candidatura to fetch.
     */
    where?: CandidaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidaturas to fetch.
     */
    orderBy?: CandidaturaOrderByWithRelationInput | CandidaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Candidaturas.
     */
    cursor?: CandidaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidaturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Candidaturas.
     */
    distinct?: CandidaturaScalarFieldEnum | CandidaturaScalarFieldEnum[]
  }

  /**
   * Candidatura findFirstOrThrow
   */
  export type CandidaturaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidatura
     */
    select?: CandidaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidaturaInclude<ExtArgs> | null
    /**
     * Filter, which Candidatura to fetch.
     */
    where?: CandidaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidaturas to fetch.
     */
    orderBy?: CandidaturaOrderByWithRelationInput | CandidaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Candidaturas.
     */
    cursor?: CandidaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidaturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Candidaturas.
     */
    distinct?: CandidaturaScalarFieldEnum | CandidaturaScalarFieldEnum[]
  }

  /**
   * Candidatura findMany
   */
  export type CandidaturaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidatura
     */
    select?: CandidaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidaturaInclude<ExtArgs> | null
    /**
     * Filter, which Candidaturas to fetch.
     */
    where?: CandidaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidaturas to fetch.
     */
    orderBy?: CandidaturaOrderByWithRelationInput | CandidaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Candidaturas.
     */
    cursor?: CandidaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidaturas.
     */
    skip?: number
    distinct?: CandidaturaScalarFieldEnum | CandidaturaScalarFieldEnum[]
  }

  /**
   * Candidatura create
   */
  export type CandidaturaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidatura
     */
    select?: CandidaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidaturaInclude<ExtArgs> | null
    /**
     * The data needed to create a Candidatura.
     */
    data: XOR<CandidaturaCreateInput, CandidaturaUncheckedCreateInput>
  }

  /**
   * Candidatura createMany
   */
  export type CandidaturaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Candidaturas.
     */
    data: CandidaturaCreateManyInput | CandidaturaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Candidatura createManyAndReturn
   */
  export type CandidaturaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidatura
     */
    select?: CandidaturaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Candidaturas.
     */
    data: CandidaturaCreateManyInput | CandidaturaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidaturaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Candidatura update
   */
  export type CandidaturaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidatura
     */
    select?: CandidaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidaturaInclude<ExtArgs> | null
    /**
     * The data needed to update a Candidatura.
     */
    data: XOR<CandidaturaUpdateInput, CandidaturaUncheckedUpdateInput>
    /**
     * Choose, which Candidatura to update.
     */
    where: CandidaturaWhereUniqueInput
  }

  /**
   * Candidatura updateMany
   */
  export type CandidaturaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Candidaturas.
     */
    data: XOR<CandidaturaUpdateManyMutationInput, CandidaturaUncheckedUpdateManyInput>
    /**
     * Filter which Candidaturas to update
     */
    where?: CandidaturaWhereInput
  }

  /**
   * Candidatura upsert
   */
  export type CandidaturaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidatura
     */
    select?: CandidaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidaturaInclude<ExtArgs> | null
    /**
     * The filter to search for the Candidatura to update in case it exists.
     */
    where: CandidaturaWhereUniqueInput
    /**
     * In case the Candidatura found by the `where` argument doesn't exist, create a new Candidatura with this data.
     */
    create: XOR<CandidaturaCreateInput, CandidaturaUncheckedCreateInput>
    /**
     * In case the Candidatura was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CandidaturaUpdateInput, CandidaturaUncheckedUpdateInput>
  }

  /**
   * Candidatura delete
   */
  export type CandidaturaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidatura
     */
    select?: CandidaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidaturaInclude<ExtArgs> | null
    /**
     * Filter which Candidatura to delete.
     */
    where: CandidaturaWhereUniqueInput
  }

  /**
   * Candidatura deleteMany
   */
  export type CandidaturaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Candidaturas to delete
     */
    where?: CandidaturaWhereInput
  }

  /**
   * Candidatura without action
   */
  export type CandidaturaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidatura
     */
    select?: CandidaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidaturaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    publicId: 'publicId',
    nomeCompleto: 'nomeCompleto',
    email: 'email',
    senha: 'senha',
    tipoUsuario: 'tipoUsuario',
    emailConfirmado: 'emailConfirmado',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const PerfilEstudanteScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    nomeEscola: 'nomeEscola',
    areaInteressePrincipal: 'areaInteressePrincipal',
    urlCurriculo: 'urlCurriculo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type PerfilEstudanteScalarFieldEnum = (typeof PerfilEstudanteScalarFieldEnum)[keyof typeof PerfilEstudanteScalarFieldEnum]


  export const PerfilInstituicaoScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    nomeInstituicao: 'nomeInstituicao',
    descricao: 'descricao',
    urlSite: 'urlSite',
    urlLogo: 'urlLogo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type PerfilInstituicaoScalarFieldEnum = (typeof PerfilInstituicaoScalarFieldEnum)[keyof typeof PerfilInstituicaoScalarFieldEnum]


  export const CategoriaCursoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type CategoriaCursoScalarFieldEnum = (typeof CategoriaCursoScalarFieldEnum)[keyof typeof CategoriaCursoScalarFieldEnum]


  export const CursoScalarFieldEnum: {
    id: 'id',
    instituicaoId: 'instituicaoId',
    titulo: 'titulo',
    descricao: 'descricao',
    modalidade: 'modalidade',
    nivel: 'nivel',
    cargaHorariaHoras: 'cargaHorariaHoras',
    localizacao: 'localizacao',
    requisitos: 'requisitos',
    linkInscricao: 'linkInscricao',
    estaAtivo: 'estaAtivo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type CursoScalarFieldEnum = (typeof CursoScalarFieldEnum)[keyof typeof CursoScalarFieldEnum]


  export const CursoCategoriaScalarFieldEnum: {
    cursoId: 'cursoId',
    categoriaId: 'categoriaId'
  };

  export type CursoCategoriaScalarFieldEnum = (typeof CursoCategoriaScalarFieldEnum)[keyof typeof CursoCategoriaScalarFieldEnum]


  export const OportunidadeScalarFieldEnum: {
    id: 'id',
    instituicaoId: 'instituicaoId',
    titulo: 'titulo',
    descricao: 'descricao',
    requisitos: 'requisitos',
    categoriaCursoRelacionadaId: 'categoriaCursoRelacionadaId',
    estaAtivo: 'estaAtivo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type OportunidadeScalarFieldEnum = (typeof OportunidadeScalarFieldEnum)[keyof typeof OportunidadeScalarFieldEnum]


  export const PostagemBlogScalarFieldEnum: {
    id: 'id',
    autorId: 'autorId',
    titulo: 'titulo',
    conteudo: 'conteudo',
    slug: 'slug',
    publicadoEm: 'publicadoEm',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type PostagemBlogScalarFieldEnum = (typeof PostagemBlogScalarFieldEnum)[keyof typeof PostagemBlogScalarFieldEnum]


  export const MatriculaScalarFieldEnum: {
    id: 'id',
    cursoId: 'cursoId',
    usuarioId: 'usuarioId',
    status: 'status',
    dataInscricao: 'dataInscricao'
  };

  export type MatriculaScalarFieldEnum = (typeof MatriculaScalarFieldEnum)[keyof typeof MatriculaScalarFieldEnum]


  export const CandidaturaScalarFieldEnum: {
    id: 'id',
    oportunidadeId: 'oportunidadeId',
    usuarioId: 'usuarioId',
    status: 'status',
    dataCandidatura: 'dataCandidatura'
  };

  export type CandidaturaScalarFieldEnum = (typeof CandidaturaScalarFieldEnum)[keyof typeof CandidaturaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserTypeEnum'
   */
  export type EnumUserTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserTypeEnum'>
    


  /**
   * Reference to a field of type 'UserTypeEnum[]'
   */
  export type ListEnumUserTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserTypeEnum[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'CourseModalityEnum'
   */
  export type EnumCourseModalityEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseModalityEnum'>
    


  /**
   * Reference to a field of type 'CourseModalityEnum[]'
   */
  export type ListEnumCourseModalityEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseModalityEnum[]'>
    


  /**
   * Reference to a field of type 'CourseLevelEnum'
   */
  export type EnumCourseLevelEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseLevelEnum'>
    


  /**
   * Reference to a field of type 'CourseLevelEnum[]'
   */
  export type ListEnumCourseLevelEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseLevelEnum[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: BigIntFilter<"Usuario"> | bigint | number
    publicId?: UuidFilter<"Usuario"> | string
    nomeCompleto?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    tipoUsuario?: EnumUserTypeEnumFilter<"Usuario"> | $Enums.UserTypeEnum
    emailConfirmado?: BoolFilter<"Usuario"> | boolean
    ativo?: BoolFilter<"Usuario"> | boolean
    criadoEm?: DateTimeFilter<"Usuario"> | Date | string
    atualizadoEm?: DateTimeFilter<"Usuario"> | Date | string
    perfilEstudante?: XOR<PerfilEstudanteNullableRelationFilter, PerfilEstudanteWhereInput> | null
    perfilInstituicao?: XOR<PerfilInstituicaoNullableRelationFilter, PerfilInstituicaoWhereInput> | null
    postagensBlog?: PostagemBlogListRelationFilter
    matriculas?: MatriculaListRelationFilter
    candidaturas?: CandidaturaListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    publicId?: SortOrder
    nomeCompleto?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipoUsuario?: SortOrder
    emailConfirmado?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    perfilEstudante?: PerfilEstudanteOrderByWithRelationInput
    perfilInstituicao?: PerfilInstituicaoOrderByWithRelationInput
    postagensBlog?: PostagemBlogOrderByRelationAggregateInput
    matriculas?: MatriculaOrderByRelationAggregateInput
    candidaturas?: CandidaturaOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    publicId?: UuidFilter<"Usuario"> | string
    nomeCompleto?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    tipoUsuario?: EnumUserTypeEnumFilter<"Usuario"> | $Enums.UserTypeEnum
    emailConfirmado?: BoolFilter<"Usuario"> | boolean
    ativo?: BoolFilter<"Usuario"> | boolean
    criadoEm?: DateTimeFilter<"Usuario"> | Date | string
    atualizadoEm?: DateTimeFilter<"Usuario"> | Date | string
    perfilEstudante?: XOR<PerfilEstudanteNullableRelationFilter, PerfilEstudanteWhereInput> | null
    perfilInstituicao?: XOR<PerfilInstituicaoNullableRelationFilter, PerfilInstituicaoWhereInput> | null
    postagensBlog?: PostagemBlogListRelationFilter
    matriculas?: MatriculaListRelationFilter
    candidaturas?: CandidaturaListRelationFilter
  }, "id" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    publicId?: SortOrder
    nomeCompleto?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipoUsuario?: SortOrder
    emailConfirmado?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Usuario"> | bigint | number
    publicId?: UuidWithAggregatesFilter<"Usuario"> | string
    nomeCompleto?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    senha?: StringWithAggregatesFilter<"Usuario"> | string
    tipoUsuario?: EnumUserTypeEnumWithAggregatesFilter<"Usuario"> | $Enums.UserTypeEnum
    emailConfirmado?: BoolWithAggregatesFilter<"Usuario"> | boolean
    ativo?: BoolWithAggregatesFilter<"Usuario"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type PerfilEstudanteWhereInput = {
    AND?: PerfilEstudanteWhereInput | PerfilEstudanteWhereInput[]
    OR?: PerfilEstudanteWhereInput[]
    NOT?: PerfilEstudanteWhereInput | PerfilEstudanteWhereInput[]
    id?: BigIntFilter<"PerfilEstudante"> | bigint | number
    usuarioId?: BigIntFilter<"PerfilEstudante"> | bigint | number
    nomeEscola?: StringFilter<"PerfilEstudante"> | string
    areaInteressePrincipal?: StringFilter<"PerfilEstudante"> | string
    urlCurriculo?: StringNullableFilter<"PerfilEstudante"> | string | null
    criadoEm?: DateTimeFilter<"PerfilEstudante"> | Date | string
    atualizadoEm?: DateTimeFilter<"PerfilEstudante"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type PerfilEstudanteOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nomeEscola?: SortOrder
    areaInteressePrincipal?: SortOrder
    urlCurriculo?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type PerfilEstudanteWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    usuarioId?: bigint | number
    AND?: PerfilEstudanteWhereInput | PerfilEstudanteWhereInput[]
    OR?: PerfilEstudanteWhereInput[]
    NOT?: PerfilEstudanteWhereInput | PerfilEstudanteWhereInput[]
    nomeEscola?: StringFilter<"PerfilEstudante"> | string
    areaInteressePrincipal?: StringFilter<"PerfilEstudante"> | string
    urlCurriculo?: StringNullableFilter<"PerfilEstudante"> | string | null
    criadoEm?: DateTimeFilter<"PerfilEstudante"> | Date | string
    atualizadoEm?: DateTimeFilter<"PerfilEstudante"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id" | "usuarioId">

  export type PerfilEstudanteOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nomeEscola?: SortOrder
    areaInteressePrincipal?: SortOrder
    urlCurriculo?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: PerfilEstudanteCountOrderByAggregateInput
    _avg?: PerfilEstudanteAvgOrderByAggregateInput
    _max?: PerfilEstudanteMaxOrderByAggregateInput
    _min?: PerfilEstudanteMinOrderByAggregateInput
    _sum?: PerfilEstudanteSumOrderByAggregateInput
  }

  export type PerfilEstudanteScalarWhereWithAggregatesInput = {
    AND?: PerfilEstudanteScalarWhereWithAggregatesInput | PerfilEstudanteScalarWhereWithAggregatesInput[]
    OR?: PerfilEstudanteScalarWhereWithAggregatesInput[]
    NOT?: PerfilEstudanteScalarWhereWithAggregatesInput | PerfilEstudanteScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"PerfilEstudante"> | bigint | number
    usuarioId?: BigIntWithAggregatesFilter<"PerfilEstudante"> | bigint | number
    nomeEscola?: StringWithAggregatesFilter<"PerfilEstudante"> | string
    areaInteressePrincipal?: StringWithAggregatesFilter<"PerfilEstudante"> | string
    urlCurriculo?: StringNullableWithAggregatesFilter<"PerfilEstudante"> | string | null
    criadoEm?: DateTimeWithAggregatesFilter<"PerfilEstudante"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"PerfilEstudante"> | Date | string
  }

  export type PerfilInstituicaoWhereInput = {
    AND?: PerfilInstituicaoWhereInput | PerfilInstituicaoWhereInput[]
    OR?: PerfilInstituicaoWhereInput[]
    NOT?: PerfilInstituicaoWhereInput | PerfilInstituicaoWhereInput[]
    id?: BigIntFilter<"PerfilInstituicao"> | bigint | number
    usuarioId?: BigIntFilter<"PerfilInstituicao"> | bigint | number
    nomeInstituicao?: StringFilter<"PerfilInstituicao"> | string
    descricao?: StringFilter<"PerfilInstituicao"> | string
    urlSite?: StringNullableFilter<"PerfilInstituicao"> | string | null
    urlLogo?: StringNullableFilter<"PerfilInstituicao"> | string | null
    criadoEm?: DateTimeFilter<"PerfilInstituicao"> | Date | string
    atualizadoEm?: DateTimeFilter<"PerfilInstituicao"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    cursos?: CursoListRelationFilter
    oportunidades?: OportunidadeListRelationFilter
  }

  export type PerfilInstituicaoOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nomeInstituicao?: SortOrder
    descricao?: SortOrder
    urlSite?: SortOrderInput | SortOrder
    urlLogo?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    cursos?: CursoOrderByRelationAggregateInput
    oportunidades?: OportunidadeOrderByRelationAggregateInput
  }

  export type PerfilInstituicaoWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    usuarioId?: bigint | number
    AND?: PerfilInstituicaoWhereInput | PerfilInstituicaoWhereInput[]
    OR?: PerfilInstituicaoWhereInput[]
    NOT?: PerfilInstituicaoWhereInput | PerfilInstituicaoWhereInput[]
    nomeInstituicao?: StringFilter<"PerfilInstituicao"> | string
    descricao?: StringFilter<"PerfilInstituicao"> | string
    urlSite?: StringNullableFilter<"PerfilInstituicao"> | string | null
    urlLogo?: StringNullableFilter<"PerfilInstituicao"> | string | null
    criadoEm?: DateTimeFilter<"PerfilInstituicao"> | Date | string
    atualizadoEm?: DateTimeFilter<"PerfilInstituicao"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    cursos?: CursoListRelationFilter
    oportunidades?: OportunidadeListRelationFilter
  }, "id" | "usuarioId">

  export type PerfilInstituicaoOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nomeInstituicao?: SortOrder
    descricao?: SortOrder
    urlSite?: SortOrderInput | SortOrder
    urlLogo?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: PerfilInstituicaoCountOrderByAggregateInput
    _avg?: PerfilInstituicaoAvgOrderByAggregateInput
    _max?: PerfilInstituicaoMaxOrderByAggregateInput
    _min?: PerfilInstituicaoMinOrderByAggregateInput
    _sum?: PerfilInstituicaoSumOrderByAggregateInput
  }

  export type PerfilInstituicaoScalarWhereWithAggregatesInput = {
    AND?: PerfilInstituicaoScalarWhereWithAggregatesInput | PerfilInstituicaoScalarWhereWithAggregatesInput[]
    OR?: PerfilInstituicaoScalarWhereWithAggregatesInput[]
    NOT?: PerfilInstituicaoScalarWhereWithAggregatesInput | PerfilInstituicaoScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"PerfilInstituicao"> | bigint | number
    usuarioId?: BigIntWithAggregatesFilter<"PerfilInstituicao"> | bigint | number
    nomeInstituicao?: StringWithAggregatesFilter<"PerfilInstituicao"> | string
    descricao?: StringWithAggregatesFilter<"PerfilInstituicao"> | string
    urlSite?: StringNullableWithAggregatesFilter<"PerfilInstituicao"> | string | null
    urlLogo?: StringNullableWithAggregatesFilter<"PerfilInstituicao"> | string | null
    criadoEm?: DateTimeWithAggregatesFilter<"PerfilInstituicao"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"PerfilInstituicao"> | Date | string
  }

  export type CategoriaCursoWhereInput = {
    AND?: CategoriaCursoWhereInput | CategoriaCursoWhereInput[]
    OR?: CategoriaCursoWhereInput[]
    NOT?: CategoriaCursoWhereInput | CategoriaCursoWhereInput[]
    id?: BigIntFilter<"CategoriaCurso"> | bigint | number
    nome?: StringFilter<"CategoriaCurso"> | string
    criadoEm?: DateTimeFilter<"CategoriaCurso"> | Date | string
    atualizadoEm?: DateTimeFilter<"CategoriaCurso"> | Date | string
    cursos?: CursoCategoriaListRelationFilter
    oportunidadesRelacionadas?: OportunidadeListRelationFilter
  }

  export type CategoriaCursoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    cursos?: CursoCategoriaOrderByRelationAggregateInput
    oportunidadesRelacionadas?: OportunidadeOrderByRelationAggregateInput
  }

  export type CategoriaCursoWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    nome?: string
    AND?: CategoriaCursoWhereInput | CategoriaCursoWhereInput[]
    OR?: CategoriaCursoWhereInput[]
    NOT?: CategoriaCursoWhereInput | CategoriaCursoWhereInput[]
    criadoEm?: DateTimeFilter<"CategoriaCurso"> | Date | string
    atualizadoEm?: DateTimeFilter<"CategoriaCurso"> | Date | string
    cursos?: CursoCategoriaListRelationFilter
    oportunidadesRelacionadas?: OportunidadeListRelationFilter
  }, "id" | "nome">

  export type CategoriaCursoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: CategoriaCursoCountOrderByAggregateInput
    _avg?: CategoriaCursoAvgOrderByAggregateInput
    _max?: CategoriaCursoMaxOrderByAggregateInput
    _min?: CategoriaCursoMinOrderByAggregateInput
    _sum?: CategoriaCursoSumOrderByAggregateInput
  }

  export type CategoriaCursoScalarWhereWithAggregatesInput = {
    AND?: CategoriaCursoScalarWhereWithAggregatesInput | CategoriaCursoScalarWhereWithAggregatesInput[]
    OR?: CategoriaCursoScalarWhereWithAggregatesInput[]
    NOT?: CategoriaCursoScalarWhereWithAggregatesInput | CategoriaCursoScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"CategoriaCurso"> | bigint | number
    nome?: StringWithAggregatesFilter<"CategoriaCurso"> | string
    criadoEm?: DateTimeWithAggregatesFilter<"CategoriaCurso"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"CategoriaCurso"> | Date | string
  }

  export type CursoWhereInput = {
    AND?: CursoWhereInput | CursoWhereInput[]
    OR?: CursoWhereInput[]
    NOT?: CursoWhereInput | CursoWhereInput[]
    id?: BigIntFilter<"Curso"> | bigint | number
    instituicaoId?: BigIntFilter<"Curso"> | bigint | number
    titulo?: StringFilter<"Curso"> | string
    descricao?: StringFilter<"Curso"> | string
    modalidade?: EnumCourseModalityEnumFilter<"Curso"> | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumFilter<"Curso"> | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntFilter<"Curso"> | number
    localizacao?: StringNullableFilter<"Curso"> | string | null
    requisitos?: StringFilter<"Curso"> | string
    linkInscricao?: StringFilter<"Curso"> | string
    estaAtivo?: BoolFilter<"Curso"> | boolean
    criadoEm?: DateTimeFilter<"Curso"> | Date | string
    atualizadoEm?: DateTimeFilter<"Curso"> | Date | string
    instituicao?: XOR<PerfilInstituicaoRelationFilter, PerfilInstituicaoWhereInput>
    categorias?: CursoCategoriaListRelationFilter
    matriculas?: MatriculaListRelationFilter
  }

  export type CursoOrderByWithRelationInput = {
    id?: SortOrder
    instituicaoId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    modalidade?: SortOrder
    nivel?: SortOrder
    cargaHorariaHoras?: SortOrder
    localizacao?: SortOrderInput | SortOrder
    requisitos?: SortOrder
    linkInscricao?: SortOrder
    estaAtivo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    instituicao?: PerfilInstituicaoOrderByWithRelationInput
    categorias?: CursoCategoriaOrderByRelationAggregateInput
    matriculas?: MatriculaOrderByRelationAggregateInput
  }

  export type CursoWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: CursoWhereInput | CursoWhereInput[]
    OR?: CursoWhereInput[]
    NOT?: CursoWhereInput | CursoWhereInput[]
    instituicaoId?: BigIntFilter<"Curso"> | bigint | number
    titulo?: StringFilter<"Curso"> | string
    descricao?: StringFilter<"Curso"> | string
    modalidade?: EnumCourseModalityEnumFilter<"Curso"> | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumFilter<"Curso"> | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntFilter<"Curso"> | number
    localizacao?: StringNullableFilter<"Curso"> | string | null
    requisitos?: StringFilter<"Curso"> | string
    linkInscricao?: StringFilter<"Curso"> | string
    estaAtivo?: BoolFilter<"Curso"> | boolean
    criadoEm?: DateTimeFilter<"Curso"> | Date | string
    atualizadoEm?: DateTimeFilter<"Curso"> | Date | string
    instituicao?: XOR<PerfilInstituicaoRelationFilter, PerfilInstituicaoWhereInput>
    categorias?: CursoCategoriaListRelationFilter
    matriculas?: MatriculaListRelationFilter
  }, "id">

  export type CursoOrderByWithAggregationInput = {
    id?: SortOrder
    instituicaoId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    modalidade?: SortOrder
    nivel?: SortOrder
    cargaHorariaHoras?: SortOrder
    localizacao?: SortOrderInput | SortOrder
    requisitos?: SortOrder
    linkInscricao?: SortOrder
    estaAtivo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: CursoCountOrderByAggregateInput
    _avg?: CursoAvgOrderByAggregateInput
    _max?: CursoMaxOrderByAggregateInput
    _min?: CursoMinOrderByAggregateInput
    _sum?: CursoSumOrderByAggregateInput
  }

  export type CursoScalarWhereWithAggregatesInput = {
    AND?: CursoScalarWhereWithAggregatesInput | CursoScalarWhereWithAggregatesInput[]
    OR?: CursoScalarWhereWithAggregatesInput[]
    NOT?: CursoScalarWhereWithAggregatesInput | CursoScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Curso"> | bigint | number
    instituicaoId?: BigIntWithAggregatesFilter<"Curso"> | bigint | number
    titulo?: StringWithAggregatesFilter<"Curso"> | string
    descricao?: StringWithAggregatesFilter<"Curso"> | string
    modalidade?: EnumCourseModalityEnumWithAggregatesFilter<"Curso"> | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumWithAggregatesFilter<"Curso"> | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntWithAggregatesFilter<"Curso"> | number
    localizacao?: StringNullableWithAggregatesFilter<"Curso"> | string | null
    requisitos?: StringWithAggregatesFilter<"Curso"> | string
    linkInscricao?: StringWithAggregatesFilter<"Curso"> | string
    estaAtivo?: BoolWithAggregatesFilter<"Curso"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"Curso"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Curso"> | Date | string
  }

  export type CursoCategoriaWhereInput = {
    AND?: CursoCategoriaWhereInput | CursoCategoriaWhereInput[]
    OR?: CursoCategoriaWhereInput[]
    NOT?: CursoCategoriaWhereInput | CursoCategoriaWhereInput[]
    cursoId?: BigIntFilter<"CursoCategoria"> | bigint | number
    categoriaId?: BigIntFilter<"CursoCategoria"> | bigint | number
    curso?: XOR<CursoRelationFilter, CursoWhereInput>
    categoria?: XOR<CategoriaCursoRelationFilter, CategoriaCursoWhereInput>
  }

  export type CursoCategoriaOrderByWithRelationInput = {
    cursoId?: SortOrder
    categoriaId?: SortOrder
    curso?: CursoOrderByWithRelationInput
    categoria?: CategoriaCursoOrderByWithRelationInput
  }

  export type CursoCategoriaWhereUniqueInput = Prisma.AtLeast<{
    cursoId_categoriaId?: CursoCategoriaCursoIdCategoriaIdCompoundUniqueInput
    AND?: CursoCategoriaWhereInput | CursoCategoriaWhereInput[]
    OR?: CursoCategoriaWhereInput[]
    NOT?: CursoCategoriaWhereInput | CursoCategoriaWhereInput[]
    cursoId?: BigIntFilter<"CursoCategoria"> | bigint | number
    categoriaId?: BigIntFilter<"CursoCategoria"> | bigint | number
    curso?: XOR<CursoRelationFilter, CursoWhereInput>
    categoria?: XOR<CategoriaCursoRelationFilter, CategoriaCursoWhereInput>
  }, "cursoId_categoriaId">

  export type CursoCategoriaOrderByWithAggregationInput = {
    cursoId?: SortOrder
    categoriaId?: SortOrder
    _count?: CursoCategoriaCountOrderByAggregateInput
    _avg?: CursoCategoriaAvgOrderByAggregateInput
    _max?: CursoCategoriaMaxOrderByAggregateInput
    _min?: CursoCategoriaMinOrderByAggregateInput
    _sum?: CursoCategoriaSumOrderByAggregateInput
  }

  export type CursoCategoriaScalarWhereWithAggregatesInput = {
    AND?: CursoCategoriaScalarWhereWithAggregatesInput | CursoCategoriaScalarWhereWithAggregatesInput[]
    OR?: CursoCategoriaScalarWhereWithAggregatesInput[]
    NOT?: CursoCategoriaScalarWhereWithAggregatesInput | CursoCategoriaScalarWhereWithAggregatesInput[]
    cursoId?: BigIntWithAggregatesFilter<"CursoCategoria"> | bigint | number
    categoriaId?: BigIntWithAggregatesFilter<"CursoCategoria"> | bigint | number
  }

  export type OportunidadeWhereInput = {
    AND?: OportunidadeWhereInput | OportunidadeWhereInput[]
    OR?: OportunidadeWhereInput[]
    NOT?: OportunidadeWhereInput | OportunidadeWhereInput[]
    id?: BigIntFilter<"Oportunidade"> | bigint | number
    instituicaoId?: BigIntFilter<"Oportunidade"> | bigint | number
    titulo?: StringFilter<"Oportunidade"> | string
    descricao?: StringFilter<"Oportunidade"> | string
    requisitos?: StringFilter<"Oportunidade"> | string
    categoriaCursoRelacionadaId?: BigIntNullableFilter<"Oportunidade"> | bigint | number | null
    estaAtivo?: BoolFilter<"Oportunidade"> | boolean
    criadoEm?: DateTimeFilter<"Oportunidade"> | Date | string
    atualizadoEm?: DateTimeFilter<"Oportunidade"> | Date | string
    instituicao?: XOR<PerfilInstituicaoRelationFilter, PerfilInstituicaoWhereInput>
    categoriaCursoRelacionada?: XOR<CategoriaCursoNullableRelationFilter, CategoriaCursoWhereInput> | null
    candidaturas?: CandidaturaListRelationFilter
  }

  export type OportunidadeOrderByWithRelationInput = {
    id?: SortOrder
    instituicaoId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    requisitos?: SortOrder
    categoriaCursoRelacionadaId?: SortOrderInput | SortOrder
    estaAtivo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    instituicao?: PerfilInstituicaoOrderByWithRelationInput
    categoriaCursoRelacionada?: CategoriaCursoOrderByWithRelationInput
    candidaturas?: CandidaturaOrderByRelationAggregateInput
  }

  export type OportunidadeWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: OportunidadeWhereInput | OportunidadeWhereInput[]
    OR?: OportunidadeWhereInput[]
    NOT?: OportunidadeWhereInput | OportunidadeWhereInput[]
    instituicaoId?: BigIntFilter<"Oportunidade"> | bigint | number
    titulo?: StringFilter<"Oportunidade"> | string
    descricao?: StringFilter<"Oportunidade"> | string
    requisitos?: StringFilter<"Oportunidade"> | string
    categoriaCursoRelacionadaId?: BigIntNullableFilter<"Oportunidade"> | bigint | number | null
    estaAtivo?: BoolFilter<"Oportunidade"> | boolean
    criadoEm?: DateTimeFilter<"Oportunidade"> | Date | string
    atualizadoEm?: DateTimeFilter<"Oportunidade"> | Date | string
    instituicao?: XOR<PerfilInstituicaoRelationFilter, PerfilInstituicaoWhereInput>
    categoriaCursoRelacionada?: XOR<CategoriaCursoNullableRelationFilter, CategoriaCursoWhereInput> | null
    candidaturas?: CandidaturaListRelationFilter
  }, "id">

  export type OportunidadeOrderByWithAggregationInput = {
    id?: SortOrder
    instituicaoId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    requisitos?: SortOrder
    categoriaCursoRelacionadaId?: SortOrderInput | SortOrder
    estaAtivo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: OportunidadeCountOrderByAggregateInput
    _avg?: OportunidadeAvgOrderByAggregateInput
    _max?: OportunidadeMaxOrderByAggregateInput
    _min?: OportunidadeMinOrderByAggregateInput
    _sum?: OportunidadeSumOrderByAggregateInput
  }

  export type OportunidadeScalarWhereWithAggregatesInput = {
    AND?: OportunidadeScalarWhereWithAggregatesInput | OportunidadeScalarWhereWithAggregatesInput[]
    OR?: OportunidadeScalarWhereWithAggregatesInput[]
    NOT?: OportunidadeScalarWhereWithAggregatesInput | OportunidadeScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Oportunidade"> | bigint | number
    instituicaoId?: BigIntWithAggregatesFilter<"Oportunidade"> | bigint | number
    titulo?: StringWithAggregatesFilter<"Oportunidade"> | string
    descricao?: StringWithAggregatesFilter<"Oportunidade"> | string
    requisitos?: StringWithAggregatesFilter<"Oportunidade"> | string
    categoriaCursoRelacionadaId?: BigIntNullableWithAggregatesFilter<"Oportunidade"> | bigint | number | null
    estaAtivo?: BoolWithAggregatesFilter<"Oportunidade"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"Oportunidade"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Oportunidade"> | Date | string
  }

  export type PostagemBlogWhereInput = {
    AND?: PostagemBlogWhereInput | PostagemBlogWhereInput[]
    OR?: PostagemBlogWhereInput[]
    NOT?: PostagemBlogWhereInput | PostagemBlogWhereInput[]
    id?: BigIntFilter<"PostagemBlog"> | bigint | number
    autorId?: BigIntFilter<"PostagemBlog"> | bigint | number
    titulo?: StringFilter<"PostagemBlog"> | string
    conteudo?: StringFilter<"PostagemBlog"> | string
    slug?: StringFilter<"PostagemBlog"> | string
    publicadoEm?: DateTimeNullableFilter<"PostagemBlog"> | Date | string | null
    criadoEm?: DateTimeFilter<"PostagemBlog"> | Date | string
    atualizadoEm?: DateTimeFilter<"PostagemBlog"> | Date | string
    autor?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type PostagemBlogOrderByWithRelationInput = {
    id?: SortOrder
    autorId?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    slug?: SortOrder
    publicadoEm?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    autor?: UsuarioOrderByWithRelationInput
  }

  export type PostagemBlogWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    slug?: string
    AND?: PostagemBlogWhereInput | PostagemBlogWhereInput[]
    OR?: PostagemBlogWhereInput[]
    NOT?: PostagemBlogWhereInput | PostagemBlogWhereInput[]
    autorId?: BigIntFilter<"PostagemBlog"> | bigint | number
    titulo?: StringFilter<"PostagemBlog"> | string
    conteudo?: StringFilter<"PostagemBlog"> | string
    publicadoEm?: DateTimeNullableFilter<"PostagemBlog"> | Date | string | null
    criadoEm?: DateTimeFilter<"PostagemBlog"> | Date | string
    atualizadoEm?: DateTimeFilter<"PostagemBlog"> | Date | string
    autor?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id" | "slug">

  export type PostagemBlogOrderByWithAggregationInput = {
    id?: SortOrder
    autorId?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    slug?: SortOrder
    publicadoEm?: SortOrderInput | SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: PostagemBlogCountOrderByAggregateInput
    _avg?: PostagemBlogAvgOrderByAggregateInput
    _max?: PostagemBlogMaxOrderByAggregateInput
    _min?: PostagemBlogMinOrderByAggregateInput
    _sum?: PostagemBlogSumOrderByAggregateInput
  }

  export type PostagemBlogScalarWhereWithAggregatesInput = {
    AND?: PostagemBlogScalarWhereWithAggregatesInput | PostagemBlogScalarWhereWithAggregatesInput[]
    OR?: PostagemBlogScalarWhereWithAggregatesInput[]
    NOT?: PostagemBlogScalarWhereWithAggregatesInput | PostagemBlogScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"PostagemBlog"> | bigint | number
    autorId?: BigIntWithAggregatesFilter<"PostagemBlog"> | bigint | number
    titulo?: StringWithAggregatesFilter<"PostagemBlog"> | string
    conteudo?: StringWithAggregatesFilter<"PostagemBlog"> | string
    slug?: StringWithAggregatesFilter<"PostagemBlog"> | string
    publicadoEm?: DateTimeNullableWithAggregatesFilter<"PostagemBlog"> | Date | string | null
    criadoEm?: DateTimeWithAggregatesFilter<"PostagemBlog"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"PostagemBlog"> | Date | string
  }

  export type MatriculaWhereInput = {
    AND?: MatriculaWhereInput | MatriculaWhereInput[]
    OR?: MatriculaWhereInput[]
    NOT?: MatriculaWhereInput | MatriculaWhereInput[]
    id?: BigIntFilter<"Matricula"> | bigint | number
    cursoId?: BigIntFilter<"Matricula"> | bigint | number
    usuarioId?: BigIntFilter<"Matricula"> | bigint | number
    status?: StringFilter<"Matricula"> | string
    dataInscricao?: DateTimeFilter<"Matricula"> | Date | string
    curso?: XOR<CursoRelationFilter, CursoWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type MatriculaOrderByWithRelationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    usuarioId?: SortOrder
    status?: SortOrder
    dataInscricao?: SortOrder
    curso?: CursoOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type MatriculaWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    cursoId_usuarioId?: MatriculaCursoIdUsuarioIdCompoundUniqueInput
    AND?: MatriculaWhereInput | MatriculaWhereInput[]
    OR?: MatriculaWhereInput[]
    NOT?: MatriculaWhereInput | MatriculaWhereInput[]
    cursoId?: BigIntFilter<"Matricula"> | bigint | number
    usuarioId?: BigIntFilter<"Matricula"> | bigint | number
    status?: StringFilter<"Matricula"> | string
    dataInscricao?: DateTimeFilter<"Matricula"> | Date | string
    curso?: XOR<CursoRelationFilter, CursoWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id" | "cursoId_usuarioId">

  export type MatriculaOrderByWithAggregationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    usuarioId?: SortOrder
    status?: SortOrder
    dataInscricao?: SortOrder
    _count?: MatriculaCountOrderByAggregateInput
    _avg?: MatriculaAvgOrderByAggregateInput
    _max?: MatriculaMaxOrderByAggregateInput
    _min?: MatriculaMinOrderByAggregateInput
    _sum?: MatriculaSumOrderByAggregateInput
  }

  export type MatriculaScalarWhereWithAggregatesInput = {
    AND?: MatriculaScalarWhereWithAggregatesInput | MatriculaScalarWhereWithAggregatesInput[]
    OR?: MatriculaScalarWhereWithAggregatesInput[]
    NOT?: MatriculaScalarWhereWithAggregatesInput | MatriculaScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Matricula"> | bigint | number
    cursoId?: BigIntWithAggregatesFilter<"Matricula"> | bigint | number
    usuarioId?: BigIntWithAggregatesFilter<"Matricula"> | bigint | number
    status?: StringWithAggregatesFilter<"Matricula"> | string
    dataInscricao?: DateTimeWithAggregatesFilter<"Matricula"> | Date | string
  }

  export type CandidaturaWhereInput = {
    AND?: CandidaturaWhereInput | CandidaturaWhereInput[]
    OR?: CandidaturaWhereInput[]
    NOT?: CandidaturaWhereInput | CandidaturaWhereInput[]
    id?: BigIntFilter<"Candidatura"> | bigint | number
    oportunidadeId?: BigIntFilter<"Candidatura"> | bigint | number
    usuarioId?: BigIntFilter<"Candidatura"> | bigint | number
    status?: StringFilter<"Candidatura"> | string
    dataCandidatura?: DateTimeFilter<"Candidatura"> | Date | string
    oportunidade?: XOR<OportunidadeRelationFilter, OportunidadeWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type CandidaturaOrderByWithRelationInput = {
    id?: SortOrder
    oportunidadeId?: SortOrder
    usuarioId?: SortOrder
    status?: SortOrder
    dataCandidatura?: SortOrder
    oportunidade?: OportunidadeOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type CandidaturaWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    oportunidadeId_usuarioId?: CandidaturaOportunidadeIdUsuarioIdCompoundUniqueInput
    AND?: CandidaturaWhereInput | CandidaturaWhereInput[]
    OR?: CandidaturaWhereInput[]
    NOT?: CandidaturaWhereInput | CandidaturaWhereInput[]
    oportunidadeId?: BigIntFilter<"Candidatura"> | bigint | number
    usuarioId?: BigIntFilter<"Candidatura"> | bigint | number
    status?: StringFilter<"Candidatura"> | string
    dataCandidatura?: DateTimeFilter<"Candidatura"> | Date | string
    oportunidade?: XOR<OportunidadeRelationFilter, OportunidadeWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id" | "oportunidadeId_usuarioId">

  export type CandidaturaOrderByWithAggregationInput = {
    id?: SortOrder
    oportunidadeId?: SortOrder
    usuarioId?: SortOrder
    status?: SortOrder
    dataCandidatura?: SortOrder
    _count?: CandidaturaCountOrderByAggregateInput
    _avg?: CandidaturaAvgOrderByAggregateInput
    _max?: CandidaturaMaxOrderByAggregateInput
    _min?: CandidaturaMinOrderByAggregateInput
    _sum?: CandidaturaSumOrderByAggregateInput
  }

  export type CandidaturaScalarWhereWithAggregatesInput = {
    AND?: CandidaturaScalarWhereWithAggregatesInput | CandidaturaScalarWhereWithAggregatesInput[]
    OR?: CandidaturaScalarWhereWithAggregatesInput[]
    NOT?: CandidaturaScalarWhereWithAggregatesInput | CandidaturaScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Candidatura"> | bigint | number
    oportunidadeId?: BigIntWithAggregatesFilter<"Candidatura"> | bigint | number
    usuarioId?: BigIntWithAggregatesFilter<"Candidatura"> | bigint | number
    status?: StringWithAggregatesFilter<"Candidatura"> | string
    dataCandidatura?: DateTimeWithAggregatesFilter<"Candidatura"> | Date | string
  }

  export type UsuarioCreateInput = {
    id?: bigint | number
    publicId?: string
    nomeCompleto: string
    email: string
    senha: string
    tipoUsuario: $Enums.UserTypeEnum
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    perfilEstudante?: PerfilEstudanteCreateNestedOneWithoutUsuarioInput
    perfilInstituicao?: PerfilInstituicaoCreateNestedOneWithoutUsuarioInput
    postagensBlog?: PostagemBlogCreateNestedManyWithoutAutorInput
    matriculas?: MatriculaCreateNestedManyWithoutUsuarioInput
    candidaturas?: CandidaturaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: bigint | number
    publicId?: string
    nomeCompleto: string
    email: string
    senha: string
    tipoUsuario: $Enums.UserTypeEnum
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    perfilEstudante?: PerfilEstudanteUncheckedCreateNestedOneWithoutUsuarioInput
    perfilInstituicao?: PerfilInstituicaoUncheckedCreateNestedOneWithoutUsuarioInput
    postagensBlog?: PostagemBlogUncheckedCreateNestedManyWithoutAutorInput
    matriculas?: MatriculaUncheckedCreateNestedManyWithoutUsuarioInput
    candidaturas?: CandidaturaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publicId?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: EnumUserTypeEnumFieldUpdateOperationsInput | $Enums.UserTypeEnum
    emailConfirmado?: BoolFieldUpdateOperationsInput | boolean
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    perfilEstudante?: PerfilEstudanteUpdateOneWithoutUsuarioNestedInput
    perfilInstituicao?: PerfilInstituicaoUpdateOneWithoutUsuarioNestedInput
    postagensBlog?: PostagemBlogUpdateManyWithoutAutorNestedInput
    matriculas?: MatriculaUpdateManyWithoutUsuarioNestedInput
    candidaturas?: CandidaturaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publicId?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: EnumUserTypeEnumFieldUpdateOperationsInput | $Enums.UserTypeEnum
    emailConfirmado?: BoolFieldUpdateOperationsInput | boolean
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    perfilEstudante?: PerfilEstudanteUncheckedUpdateOneWithoutUsuarioNestedInput
    perfilInstituicao?: PerfilInstituicaoUncheckedUpdateOneWithoutUsuarioNestedInput
    postagensBlog?: PostagemBlogUncheckedUpdateManyWithoutAutorNestedInput
    matriculas?: MatriculaUncheckedUpdateManyWithoutUsuarioNestedInput
    candidaturas?: CandidaturaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: bigint | number
    publicId?: string
    nomeCompleto: string
    email: string
    senha: string
    tipoUsuario: $Enums.UserTypeEnum
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publicId?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: EnumUserTypeEnumFieldUpdateOperationsInput | $Enums.UserTypeEnum
    emailConfirmado?: BoolFieldUpdateOperationsInput | boolean
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publicId?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: EnumUserTypeEnumFieldUpdateOperationsInput | $Enums.UserTypeEnum
    emailConfirmado?: BoolFieldUpdateOperationsInput | boolean
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerfilEstudanteCreateInput = {
    id?: bigint | number
    nomeEscola: string
    areaInteressePrincipal: string
    urlCurriculo?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    usuario: UsuarioCreateNestedOneWithoutPerfilEstudanteInput
  }

  export type PerfilEstudanteUncheckedCreateInput = {
    id?: bigint | number
    usuarioId: bigint | number
    nomeEscola: string
    areaInteressePrincipal: string
    urlCurriculo?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type PerfilEstudanteUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeEscola?: StringFieldUpdateOperationsInput | string
    areaInteressePrincipal?: StringFieldUpdateOperationsInput | string
    urlCurriculo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutPerfilEstudanteNestedInput
  }

  export type PerfilEstudanteUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usuarioId?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeEscola?: StringFieldUpdateOperationsInput | string
    areaInteressePrincipal?: StringFieldUpdateOperationsInput | string
    urlCurriculo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerfilEstudanteCreateManyInput = {
    id?: bigint | number
    usuarioId: bigint | number
    nomeEscola: string
    areaInteressePrincipal: string
    urlCurriculo?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type PerfilEstudanteUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeEscola?: StringFieldUpdateOperationsInput | string
    areaInteressePrincipal?: StringFieldUpdateOperationsInput | string
    urlCurriculo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerfilEstudanteUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usuarioId?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeEscola?: StringFieldUpdateOperationsInput | string
    areaInteressePrincipal?: StringFieldUpdateOperationsInput | string
    urlCurriculo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerfilInstituicaoCreateInput = {
    id?: bigint | number
    nomeInstituicao: string
    descricao: string
    urlSite?: string | null
    urlLogo?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    usuario: UsuarioCreateNestedOneWithoutPerfilInstituicaoInput
    cursos?: CursoCreateNestedManyWithoutInstituicaoInput
    oportunidades?: OportunidadeCreateNestedManyWithoutInstituicaoInput
  }

  export type PerfilInstituicaoUncheckedCreateInput = {
    id?: bigint | number
    usuarioId: bigint | number
    nomeInstituicao: string
    descricao: string
    urlSite?: string | null
    urlLogo?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    cursos?: CursoUncheckedCreateNestedManyWithoutInstituicaoInput
    oportunidades?: OportunidadeUncheckedCreateNestedManyWithoutInstituicaoInput
  }

  export type PerfilInstituicaoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeInstituicao?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    urlSite?: NullableStringFieldUpdateOperationsInput | string | null
    urlLogo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutPerfilInstituicaoNestedInput
    cursos?: CursoUpdateManyWithoutInstituicaoNestedInput
    oportunidades?: OportunidadeUpdateManyWithoutInstituicaoNestedInput
  }

  export type PerfilInstituicaoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usuarioId?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeInstituicao?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    urlSite?: NullableStringFieldUpdateOperationsInput | string | null
    urlLogo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    cursos?: CursoUncheckedUpdateManyWithoutInstituicaoNestedInput
    oportunidades?: OportunidadeUncheckedUpdateManyWithoutInstituicaoNestedInput
  }

  export type PerfilInstituicaoCreateManyInput = {
    id?: bigint | number
    usuarioId: bigint | number
    nomeInstituicao: string
    descricao: string
    urlSite?: string | null
    urlLogo?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type PerfilInstituicaoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeInstituicao?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    urlSite?: NullableStringFieldUpdateOperationsInput | string | null
    urlLogo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerfilInstituicaoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usuarioId?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeInstituicao?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    urlSite?: NullableStringFieldUpdateOperationsInput | string | null
    urlLogo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriaCursoCreateInput = {
    id?: bigint | number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    cursos?: CursoCategoriaCreateNestedManyWithoutCategoriaInput
    oportunidadesRelacionadas?: OportunidadeCreateNestedManyWithoutCategoriaCursoRelacionadaInput
  }

  export type CategoriaCursoUncheckedCreateInput = {
    id?: bigint | number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    cursos?: CursoCategoriaUncheckedCreateNestedManyWithoutCategoriaInput
    oportunidadesRelacionadas?: OportunidadeUncheckedCreateNestedManyWithoutCategoriaCursoRelacionadaInput
  }

  export type CategoriaCursoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    cursos?: CursoCategoriaUpdateManyWithoutCategoriaNestedInput
    oportunidadesRelacionadas?: OportunidadeUpdateManyWithoutCategoriaCursoRelacionadaNestedInput
  }

  export type CategoriaCursoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    cursos?: CursoCategoriaUncheckedUpdateManyWithoutCategoriaNestedInput
    oportunidadesRelacionadas?: OportunidadeUncheckedUpdateManyWithoutCategoriaCursoRelacionadaNestedInput
  }

  export type CategoriaCursoCreateManyInput = {
    id?: bigint | number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type CategoriaCursoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoriaCursoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursoCreateInput = {
    id?: bigint | number
    titulo: string
    descricao: string
    modalidade: $Enums.CourseModalityEnum
    nivel: $Enums.CourseLevelEnum
    cargaHorariaHoras: number
    localizacao?: string | null
    requisitos: string
    linkInscricao: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    instituicao: PerfilInstituicaoCreateNestedOneWithoutCursosInput
    categorias?: CursoCategoriaCreateNestedManyWithoutCursoInput
    matriculas?: MatriculaCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateInput = {
    id?: bigint | number
    instituicaoId: bigint | number
    titulo: string
    descricao: string
    modalidade: $Enums.CourseModalityEnum
    nivel: $Enums.CourseLevelEnum
    cargaHorariaHoras: number
    localizacao?: string | null
    requisitos: string
    linkInscricao: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    categorias?: CursoCategoriaUncheckedCreateNestedManyWithoutCursoInput
    matriculas?: MatriculaUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: EnumCourseModalityEnumFieldUpdateOperationsInput | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumFieldUpdateOperationsInput | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntFieldUpdateOperationsInput | number
    localizacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisitos?: StringFieldUpdateOperationsInput | string
    linkInscricao?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    instituicao?: PerfilInstituicaoUpdateOneRequiredWithoutCursosNestedInput
    categorias?: CursoCategoriaUpdateManyWithoutCursoNestedInput
    matriculas?: MatriculaUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instituicaoId?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: EnumCourseModalityEnumFieldUpdateOperationsInput | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumFieldUpdateOperationsInput | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntFieldUpdateOperationsInput | number
    localizacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisitos?: StringFieldUpdateOperationsInput | string
    linkInscricao?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    categorias?: CursoCategoriaUncheckedUpdateManyWithoutCursoNestedInput
    matriculas?: MatriculaUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type CursoCreateManyInput = {
    id?: bigint | number
    instituicaoId: bigint | number
    titulo: string
    descricao: string
    modalidade: $Enums.CourseModalityEnum
    nivel: $Enums.CourseLevelEnum
    cargaHorariaHoras: number
    localizacao?: string | null
    requisitos: string
    linkInscricao: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type CursoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: EnumCourseModalityEnumFieldUpdateOperationsInput | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumFieldUpdateOperationsInput | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntFieldUpdateOperationsInput | number
    localizacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisitos?: StringFieldUpdateOperationsInput | string
    linkInscricao?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instituicaoId?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: EnumCourseModalityEnumFieldUpdateOperationsInput | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumFieldUpdateOperationsInput | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntFieldUpdateOperationsInput | number
    localizacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisitos?: StringFieldUpdateOperationsInput | string
    linkInscricao?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursoCategoriaCreateInput = {
    curso: CursoCreateNestedOneWithoutCategoriasInput
    categoria: CategoriaCursoCreateNestedOneWithoutCursosInput
  }

  export type CursoCategoriaUncheckedCreateInput = {
    cursoId: bigint | number
    categoriaId: bigint | number
  }

  export type CursoCategoriaUpdateInput = {
    curso?: CursoUpdateOneRequiredWithoutCategoriasNestedInput
    categoria?: CategoriaCursoUpdateOneRequiredWithoutCursosNestedInput
  }

  export type CursoCategoriaUncheckedUpdateInput = {
    cursoId?: BigIntFieldUpdateOperationsInput | bigint | number
    categoriaId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CursoCategoriaCreateManyInput = {
    cursoId: bigint | number
    categoriaId: bigint | number
  }

  export type CursoCategoriaUpdateManyMutationInput = {

  }

  export type CursoCategoriaUncheckedUpdateManyInput = {
    cursoId?: BigIntFieldUpdateOperationsInput | bigint | number
    categoriaId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OportunidadeCreateInput = {
    id?: bigint | number
    titulo: string
    descricao: string
    requisitos: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    instituicao: PerfilInstituicaoCreateNestedOneWithoutOportunidadesInput
    categoriaCursoRelacionada?: CategoriaCursoCreateNestedOneWithoutOportunidadesRelacionadasInput
    candidaturas?: CandidaturaCreateNestedManyWithoutOportunidadeInput
  }

  export type OportunidadeUncheckedCreateInput = {
    id?: bigint | number
    instituicaoId: bigint | number
    titulo: string
    descricao: string
    requisitos: string
    categoriaCursoRelacionadaId?: bigint | number | null
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    candidaturas?: CandidaturaUncheckedCreateNestedManyWithoutOportunidadeInput
  }

  export type OportunidadeUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    requisitos?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    instituicao?: PerfilInstituicaoUpdateOneRequiredWithoutOportunidadesNestedInput
    categoriaCursoRelacionada?: CategoriaCursoUpdateOneWithoutOportunidadesRelacionadasNestedInput
    candidaturas?: CandidaturaUpdateManyWithoutOportunidadeNestedInput
  }

  export type OportunidadeUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instituicaoId?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    requisitos?: StringFieldUpdateOperationsInput | string
    categoriaCursoRelacionadaId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    candidaturas?: CandidaturaUncheckedUpdateManyWithoutOportunidadeNestedInput
  }

  export type OportunidadeCreateManyInput = {
    id?: bigint | number
    instituicaoId: bigint | number
    titulo: string
    descricao: string
    requisitos: string
    categoriaCursoRelacionadaId?: bigint | number | null
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type OportunidadeUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    requisitos?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OportunidadeUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instituicaoId?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    requisitos?: StringFieldUpdateOperationsInput | string
    categoriaCursoRelacionadaId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostagemBlogCreateInput = {
    id?: bigint | number
    titulo: string
    conteudo: string
    slug: string
    publicadoEm?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    autor: UsuarioCreateNestedOneWithoutPostagensBlogInput
  }

  export type PostagemBlogUncheckedCreateInput = {
    id?: bigint | number
    autorId: bigint | number
    titulo: string
    conteudo: string
    slug: string
    publicadoEm?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type PostagemBlogUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    publicadoEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    autor?: UsuarioUpdateOneRequiredWithoutPostagensBlogNestedInput
  }

  export type PostagemBlogUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    autorId?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    publicadoEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostagemBlogCreateManyInput = {
    id?: bigint | number
    autorId: bigint | number
    titulo: string
    conteudo: string
    slug: string
    publicadoEm?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type PostagemBlogUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    publicadoEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostagemBlogUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    autorId?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    publicadoEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatriculaCreateInput = {
    id?: bigint | number
    status?: string
    dataInscricao?: Date | string
    curso: CursoCreateNestedOneWithoutMatriculasInput
    usuario: UsuarioCreateNestedOneWithoutMatriculasInput
  }

  export type MatriculaUncheckedCreateInput = {
    id?: bigint | number
    cursoId: bigint | number
    usuarioId: bigint | number
    status?: string
    dataInscricao?: Date | string
  }

  export type MatriculaUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataInscricao?: DateTimeFieldUpdateOperationsInput | Date | string
    curso?: CursoUpdateOneRequiredWithoutMatriculasNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutMatriculasNestedInput
  }

  export type MatriculaUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cursoId?: BigIntFieldUpdateOperationsInput | bigint | number
    usuarioId?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataInscricao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatriculaCreateManyInput = {
    id?: bigint | number
    cursoId: bigint | number
    usuarioId: bigint | number
    status?: string
    dataInscricao?: Date | string
  }

  export type MatriculaUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataInscricao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatriculaUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cursoId?: BigIntFieldUpdateOperationsInput | bigint | number
    usuarioId?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataInscricao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidaturaCreateInput = {
    id?: bigint | number
    status?: string
    dataCandidatura?: Date | string
    oportunidade: OportunidadeCreateNestedOneWithoutCandidaturasInput
    usuario: UsuarioCreateNestedOneWithoutCandidaturasInput
  }

  export type CandidaturaUncheckedCreateInput = {
    id?: bigint | number
    oportunidadeId: bigint | number
    usuarioId: bigint | number
    status?: string
    dataCandidatura?: Date | string
  }

  export type CandidaturaUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataCandidatura?: DateTimeFieldUpdateOperationsInput | Date | string
    oportunidade?: OportunidadeUpdateOneRequiredWithoutCandidaturasNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutCandidaturasNestedInput
  }

  export type CandidaturaUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    oportunidadeId?: BigIntFieldUpdateOperationsInput | bigint | number
    usuarioId?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataCandidatura?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidaturaCreateManyInput = {
    id?: bigint | number
    oportunidadeId: bigint | number
    usuarioId: bigint | number
    status?: string
    dataCandidatura?: Date | string
  }

  export type CandidaturaUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataCandidatura?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidaturaUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    oportunidadeId?: BigIntFieldUpdateOperationsInput | bigint | number
    usuarioId?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataCandidatura?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTypeEnum | EnumUserTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.UserTypeEnum[] | ListEnumUserTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTypeEnum[] | ListEnumUserTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeEnumFilter<$PrismaModel> | $Enums.UserTypeEnum
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PerfilEstudanteNullableRelationFilter = {
    is?: PerfilEstudanteWhereInput | null
    isNot?: PerfilEstudanteWhereInput | null
  }

  export type PerfilInstituicaoNullableRelationFilter = {
    is?: PerfilInstituicaoWhereInput | null
    isNot?: PerfilInstituicaoWhereInput | null
  }

  export type PostagemBlogListRelationFilter = {
    every?: PostagemBlogWhereInput
    some?: PostagemBlogWhereInput
    none?: PostagemBlogWhereInput
  }

  export type MatriculaListRelationFilter = {
    every?: MatriculaWhereInput
    some?: MatriculaWhereInput
    none?: MatriculaWhereInput
  }

  export type CandidaturaListRelationFilter = {
    every?: CandidaturaWhereInput
    some?: CandidaturaWhereInput
    none?: CandidaturaWhereInput
  }

  export type PostagemBlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatriculaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CandidaturaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    nomeCompleto?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipoUsuario?: SortOrder
    emailConfirmado?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    nomeCompleto?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipoUsuario?: SortOrder
    emailConfirmado?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    publicId?: SortOrder
    nomeCompleto?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipoUsuario?: SortOrder
    emailConfirmado?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTypeEnum | EnumUserTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.UserTypeEnum[] | ListEnumUserTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTypeEnum[] | ListEnumUserTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.UserTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumUserTypeEnumFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PerfilEstudanteCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nomeEscola?: SortOrder
    areaInteressePrincipal?: SortOrder
    urlCurriculo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type PerfilEstudanteAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type PerfilEstudanteMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nomeEscola?: SortOrder
    areaInteressePrincipal?: SortOrder
    urlCurriculo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type PerfilEstudanteMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nomeEscola?: SortOrder
    areaInteressePrincipal?: SortOrder
    urlCurriculo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type PerfilEstudanteSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type CursoListRelationFilter = {
    every?: CursoWhereInput
    some?: CursoWhereInput
    none?: CursoWhereInput
  }

  export type OportunidadeListRelationFilter = {
    every?: OportunidadeWhereInput
    some?: OportunidadeWhereInput
    none?: OportunidadeWhereInput
  }

  export type CursoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OportunidadeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerfilInstituicaoCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nomeInstituicao?: SortOrder
    descricao?: SortOrder
    urlSite?: SortOrder
    urlLogo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type PerfilInstituicaoAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type PerfilInstituicaoMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nomeInstituicao?: SortOrder
    descricao?: SortOrder
    urlSite?: SortOrder
    urlLogo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type PerfilInstituicaoMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nomeInstituicao?: SortOrder
    descricao?: SortOrder
    urlSite?: SortOrder
    urlLogo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type PerfilInstituicaoSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type CursoCategoriaListRelationFilter = {
    every?: CursoCategoriaWhereInput
    some?: CursoCategoriaWhereInput
    none?: CursoCategoriaWhereInput
  }

  export type CursoCategoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoriaCursoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type CategoriaCursoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriaCursoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type CategoriaCursoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type CategoriaCursoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumCourseModalityEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseModalityEnum | EnumCourseModalityEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CourseModalityEnum[] | ListEnumCourseModalityEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseModalityEnum[] | ListEnumCourseModalityEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseModalityEnumFilter<$PrismaModel> | $Enums.CourseModalityEnum
  }

  export type EnumCourseLevelEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevelEnum | EnumCourseLevelEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevelEnum[] | ListEnumCourseLevelEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevelEnum[] | ListEnumCourseLevelEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelEnumFilter<$PrismaModel> | $Enums.CourseLevelEnum
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PerfilInstituicaoRelationFilter = {
    is?: PerfilInstituicaoWhereInput
    isNot?: PerfilInstituicaoWhereInput
  }

  export type CursoCountOrderByAggregateInput = {
    id?: SortOrder
    instituicaoId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    modalidade?: SortOrder
    nivel?: SortOrder
    cargaHorariaHoras?: SortOrder
    localizacao?: SortOrder
    requisitos?: SortOrder
    linkInscricao?: SortOrder
    estaAtivo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type CursoAvgOrderByAggregateInput = {
    id?: SortOrder
    instituicaoId?: SortOrder
    cargaHorariaHoras?: SortOrder
  }

  export type CursoMaxOrderByAggregateInput = {
    id?: SortOrder
    instituicaoId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    modalidade?: SortOrder
    nivel?: SortOrder
    cargaHorariaHoras?: SortOrder
    localizacao?: SortOrder
    requisitos?: SortOrder
    linkInscricao?: SortOrder
    estaAtivo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type CursoMinOrderByAggregateInput = {
    id?: SortOrder
    instituicaoId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    modalidade?: SortOrder
    nivel?: SortOrder
    cargaHorariaHoras?: SortOrder
    localizacao?: SortOrder
    requisitos?: SortOrder
    linkInscricao?: SortOrder
    estaAtivo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type CursoSumOrderByAggregateInput = {
    id?: SortOrder
    instituicaoId?: SortOrder
    cargaHorariaHoras?: SortOrder
  }

  export type EnumCourseModalityEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseModalityEnum | EnumCourseModalityEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CourseModalityEnum[] | ListEnumCourseModalityEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseModalityEnum[] | ListEnumCourseModalityEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseModalityEnumWithAggregatesFilter<$PrismaModel> | $Enums.CourseModalityEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseModalityEnumFilter<$PrismaModel>
    _max?: NestedEnumCourseModalityEnumFilter<$PrismaModel>
  }

  export type EnumCourseLevelEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevelEnum | EnumCourseLevelEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevelEnum[] | ListEnumCourseLevelEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevelEnum[] | ListEnumCourseLevelEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelEnumWithAggregatesFilter<$PrismaModel> | $Enums.CourseLevelEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseLevelEnumFilter<$PrismaModel>
    _max?: NestedEnumCourseLevelEnumFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CursoRelationFilter = {
    is?: CursoWhereInput
    isNot?: CursoWhereInput
  }

  export type CategoriaCursoRelationFilter = {
    is?: CategoriaCursoWhereInput
    isNot?: CategoriaCursoWhereInput
  }

  export type CursoCategoriaCursoIdCategoriaIdCompoundUniqueInput = {
    cursoId: bigint | number
    categoriaId: bigint | number
  }

  export type CursoCategoriaCountOrderByAggregateInput = {
    cursoId?: SortOrder
    categoriaId?: SortOrder
  }

  export type CursoCategoriaAvgOrderByAggregateInput = {
    cursoId?: SortOrder
    categoriaId?: SortOrder
  }

  export type CursoCategoriaMaxOrderByAggregateInput = {
    cursoId?: SortOrder
    categoriaId?: SortOrder
  }

  export type CursoCategoriaMinOrderByAggregateInput = {
    cursoId?: SortOrder
    categoriaId?: SortOrder
  }

  export type CursoCategoriaSumOrderByAggregateInput = {
    cursoId?: SortOrder
    categoriaId?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type CategoriaCursoNullableRelationFilter = {
    is?: CategoriaCursoWhereInput | null
    isNot?: CategoriaCursoWhereInput | null
  }

  export type OportunidadeCountOrderByAggregateInput = {
    id?: SortOrder
    instituicaoId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    requisitos?: SortOrder
    categoriaCursoRelacionadaId?: SortOrder
    estaAtivo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type OportunidadeAvgOrderByAggregateInput = {
    id?: SortOrder
    instituicaoId?: SortOrder
    categoriaCursoRelacionadaId?: SortOrder
  }

  export type OportunidadeMaxOrderByAggregateInput = {
    id?: SortOrder
    instituicaoId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    requisitos?: SortOrder
    categoriaCursoRelacionadaId?: SortOrder
    estaAtivo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type OportunidadeMinOrderByAggregateInput = {
    id?: SortOrder
    instituicaoId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    requisitos?: SortOrder
    categoriaCursoRelacionadaId?: SortOrder
    estaAtivo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type OportunidadeSumOrderByAggregateInput = {
    id?: SortOrder
    instituicaoId?: SortOrder
    categoriaCursoRelacionadaId?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PostagemBlogCountOrderByAggregateInput = {
    id?: SortOrder
    autorId?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    slug?: SortOrder
    publicadoEm?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type PostagemBlogAvgOrderByAggregateInput = {
    id?: SortOrder
    autorId?: SortOrder
  }

  export type PostagemBlogMaxOrderByAggregateInput = {
    id?: SortOrder
    autorId?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    slug?: SortOrder
    publicadoEm?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type PostagemBlogMinOrderByAggregateInput = {
    id?: SortOrder
    autorId?: SortOrder
    titulo?: SortOrder
    conteudo?: SortOrder
    slug?: SortOrder
    publicadoEm?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type PostagemBlogSumOrderByAggregateInput = {
    id?: SortOrder
    autorId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type MatriculaCursoIdUsuarioIdCompoundUniqueInput = {
    cursoId: bigint | number
    usuarioId: bigint | number
  }

  export type MatriculaCountOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    usuarioId?: SortOrder
    status?: SortOrder
    dataInscricao?: SortOrder
  }

  export type MatriculaAvgOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    usuarioId?: SortOrder
  }

  export type MatriculaMaxOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    usuarioId?: SortOrder
    status?: SortOrder
    dataInscricao?: SortOrder
  }

  export type MatriculaMinOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    usuarioId?: SortOrder
    status?: SortOrder
    dataInscricao?: SortOrder
  }

  export type MatriculaSumOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    usuarioId?: SortOrder
  }

  export type OportunidadeRelationFilter = {
    is?: OportunidadeWhereInput
    isNot?: OportunidadeWhereInput
  }

  export type CandidaturaOportunidadeIdUsuarioIdCompoundUniqueInput = {
    oportunidadeId: bigint | number
    usuarioId: bigint | number
  }

  export type CandidaturaCountOrderByAggregateInput = {
    id?: SortOrder
    oportunidadeId?: SortOrder
    usuarioId?: SortOrder
    status?: SortOrder
    dataCandidatura?: SortOrder
  }

  export type CandidaturaAvgOrderByAggregateInput = {
    id?: SortOrder
    oportunidadeId?: SortOrder
    usuarioId?: SortOrder
  }

  export type CandidaturaMaxOrderByAggregateInput = {
    id?: SortOrder
    oportunidadeId?: SortOrder
    usuarioId?: SortOrder
    status?: SortOrder
    dataCandidatura?: SortOrder
  }

  export type CandidaturaMinOrderByAggregateInput = {
    id?: SortOrder
    oportunidadeId?: SortOrder
    usuarioId?: SortOrder
    status?: SortOrder
    dataCandidatura?: SortOrder
  }

  export type CandidaturaSumOrderByAggregateInput = {
    id?: SortOrder
    oportunidadeId?: SortOrder
    usuarioId?: SortOrder
  }

  export type PerfilEstudanteCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<PerfilEstudanteCreateWithoutUsuarioInput, PerfilEstudanteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: PerfilEstudanteCreateOrConnectWithoutUsuarioInput
    connect?: PerfilEstudanteWhereUniqueInput
  }

  export type PerfilInstituicaoCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<PerfilInstituicaoCreateWithoutUsuarioInput, PerfilInstituicaoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: PerfilInstituicaoCreateOrConnectWithoutUsuarioInput
    connect?: PerfilInstituicaoWhereUniqueInput
  }

  export type PostagemBlogCreateNestedManyWithoutAutorInput = {
    create?: XOR<PostagemBlogCreateWithoutAutorInput, PostagemBlogUncheckedCreateWithoutAutorInput> | PostagemBlogCreateWithoutAutorInput[] | PostagemBlogUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: PostagemBlogCreateOrConnectWithoutAutorInput | PostagemBlogCreateOrConnectWithoutAutorInput[]
    createMany?: PostagemBlogCreateManyAutorInputEnvelope
    connect?: PostagemBlogWhereUniqueInput | PostagemBlogWhereUniqueInput[]
  }

  export type MatriculaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<MatriculaCreateWithoutUsuarioInput, MatriculaUncheckedCreateWithoutUsuarioInput> | MatriculaCreateWithoutUsuarioInput[] | MatriculaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutUsuarioInput | MatriculaCreateOrConnectWithoutUsuarioInput[]
    createMany?: MatriculaCreateManyUsuarioInputEnvelope
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
  }

  export type CandidaturaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<CandidaturaCreateWithoutUsuarioInput, CandidaturaUncheckedCreateWithoutUsuarioInput> | CandidaturaCreateWithoutUsuarioInput[] | CandidaturaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CandidaturaCreateOrConnectWithoutUsuarioInput | CandidaturaCreateOrConnectWithoutUsuarioInput[]
    createMany?: CandidaturaCreateManyUsuarioInputEnvelope
    connect?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
  }

  export type PerfilEstudanteUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<PerfilEstudanteCreateWithoutUsuarioInput, PerfilEstudanteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: PerfilEstudanteCreateOrConnectWithoutUsuarioInput
    connect?: PerfilEstudanteWhereUniqueInput
  }

  export type PerfilInstituicaoUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<PerfilInstituicaoCreateWithoutUsuarioInput, PerfilInstituicaoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: PerfilInstituicaoCreateOrConnectWithoutUsuarioInput
    connect?: PerfilInstituicaoWhereUniqueInput
  }

  export type PostagemBlogUncheckedCreateNestedManyWithoutAutorInput = {
    create?: XOR<PostagemBlogCreateWithoutAutorInput, PostagemBlogUncheckedCreateWithoutAutorInput> | PostagemBlogCreateWithoutAutorInput[] | PostagemBlogUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: PostagemBlogCreateOrConnectWithoutAutorInput | PostagemBlogCreateOrConnectWithoutAutorInput[]
    createMany?: PostagemBlogCreateManyAutorInputEnvelope
    connect?: PostagemBlogWhereUniqueInput | PostagemBlogWhereUniqueInput[]
  }

  export type MatriculaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<MatriculaCreateWithoutUsuarioInput, MatriculaUncheckedCreateWithoutUsuarioInput> | MatriculaCreateWithoutUsuarioInput[] | MatriculaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutUsuarioInput | MatriculaCreateOrConnectWithoutUsuarioInput[]
    createMany?: MatriculaCreateManyUsuarioInputEnvelope
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
  }

  export type CandidaturaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<CandidaturaCreateWithoutUsuarioInput, CandidaturaUncheckedCreateWithoutUsuarioInput> | CandidaturaCreateWithoutUsuarioInput[] | CandidaturaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CandidaturaCreateOrConnectWithoutUsuarioInput | CandidaturaCreateOrConnectWithoutUsuarioInput[]
    createMany?: CandidaturaCreateManyUsuarioInputEnvelope
    connect?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.UserTypeEnum
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PerfilEstudanteUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<PerfilEstudanteCreateWithoutUsuarioInput, PerfilEstudanteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: PerfilEstudanteCreateOrConnectWithoutUsuarioInput
    upsert?: PerfilEstudanteUpsertWithoutUsuarioInput
    disconnect?: PerfilEstudanteWhereInput | boolean
    delete?: PerfilEstudanteWhereInput | boolean
    connect?: PerfilEstudanteWhereUniqueInput
    update?: XOR<XOR<PerfilEstudanteUpdateToOneWithWhereWithoutUsuarioInput, PerfilEstudanteUpdateWithoutUsuarioInput>, PerfilEstudanteUncheckedUpdateWithoutUsuarioInput>
  }

  export type PerfilInstituicaoUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<PerfilInstituicaoCreateWithoutUsuarioInput, PerfilInstituicaoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: PerfilInstituicaoCreateOrConnectWithoutUsuarioInput
    upsert?: PerfilInstituicaoUpsertWithoutUsuarioInput
    disconnect?: PerfilInstituicaoWhereInput | boolean
    delete?: PerfilInstituicaoWhereInput | boolean
    connect?: PerfilInstituicaoWhereUniqueInput
    update?: XOR<XOR<PerfilInstituicaoUpdateToOneWithWhereWithoutUsuarioInput, PerfilInstituicaoUpdateWithoutUsuarioInput>, PerfilInstituicaoUncheckedUpdateWithoutUsuarioInput>
  }

  export type PostagemBlogUpdateManyWithoutAutorNestedInput = {
    create?: XOR<PostagemBlogCreateWithoutAutorInput, PostagemBlogUncheckedCreateWithoutAutorInput> | PostagemBlogCreateWithoutAutorInput[] | PostagemBlogUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: PostagemBlogCreateOrConnectWithoutAutorInput | PostagemBlogCreateOrConnectWithoutAutorInput[]
    upsert?: PostagemBlogUpsertWithWhereUniqueWithoutAutorInput | PostagemBlogUpsertWithWhereUniqueWithoutAutorInput[]
    createMany?: PostagemBlogCreateManyAutorInputEnvelope
    set?: PostagemBlogWhereUniqueInput | PostagemBlogWhereUniqueInput[]
    disconnect?: PostagemBlogWhereUniqueInput | PostagemBlogWhereUniqueInput[]
    delete?: PostagemBlogWhereUniqueInput | PostagemBlogWhereUniqueInput[]
    connect?: PostagemBlogWhereUniqueInput | PostagemBlogWhereUniqueInput[]
    update?: PostagemBlogUpdateWithWhereUniqueWithoutAutorInput | PostagemBlogUpdateWithWhereUniqueWithoutAutorInput[]
    updateMany?: PostagemBlogUpdateManyWithWhereWithoutAutorInput | PostagemBlogUpdateManyWithWhereWithoutAutorInput[]
    deleteMany?: PostagemBlogScalarWhereInput | PostagemBlogScalarWhereInput[]
  }

  export type MatriculaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<MatriculaCreateWithoutUsuarioInput, MatriculaUncheckedCreateWithoutUsuarioInput> | MatriculaCreateWithoutUsuarioInput[] | MatriculaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutUsuarioInput | MatriculaCreateOrConnectWithoutUsuarioInput[]
    upsert?: MatriculaUpsertWithWhereUniqueWithoutUsuarioInput | MatriculaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: MatriculaCreateManyUsuarioInputEnvelope
    set?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    disconnect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    delete?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    update?: MatriculaUpdateWithWhereUniqueWithoutUsuarioInput | MatriculaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: MatriculaUpdateManyWithWhereWithoutUsuarioInput | MatriculaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: MatriculaScalarWhereInput | MatriculaScalarWhereInput[]
  }

  export type CandidaturaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<CandidaturaCreateWithoutUsuarioInput, CandidaturaUncheckedCreateWithoutUsuarioInput> | CandidaturaCreateWithoutUsuarioInput[] | CandidaturaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CandidaturaCreateOrConnectWithoutUsuarioInput | CandidaturaCreateOrConnectWithoutUsuarioInput[]
    upsert?: CandidaturaUpsertWithWhereUniqueWithoutUsuarioInput | CandidaturaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: CandidaturaCreateManyUsuarioInputEnvelope
    set?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    disconnect?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    delete?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    connect?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    update?: CandidaturaUpdateWithWhereUniqueWithoutUsuarioInput | CandidaturaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: CandidaturaUpdateManyWithWhereWithoutUsuarioInput | CandidaturaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: CandidaturaScalarWhereInput | CandidaturaScalarWhereInput[]
  }

  export type PerfilEstudanteUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<PerfilEstudanteCreateWithoutUsuarioInput, PerfilEstudanteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: PerfilEstudanteCreateOrConnectWithoutUsuarioInput
    upsert?: PerfilEstudanteUpsertWithoutUsuarioInput
    disconnect?: PerfilEstudanteWhereInput | boolean
    delete?: PerfilEstudanteWhereInput | boolean
    connect?: PerfilEstudanteWhereUniqueInput
    update?: XOR<XOR<PerfilEstudanteUpdateToOneWithWhereWithoutUsuarioInput, PerfilEstudanteUpdateWithoutUsuarioInput>, PerfilEstudanteUncheckedUpdateWithoutUsuarioInput>
  }

  export type PerfilInstituicaoUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<PerfilInstituicaoCreateWithoutUsuarioInput, PerfilInstituicaoUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: PerfilInstituicaoCreateOrConnectWithoutUsuarioInput
    upsert?: PerfilInstituicaoUpsertWithoutUsuarioInput
    disconnect?: PerfilInstituicaoWhereInput | boolean
    delete?: PerfilInstituicaoWhereInput | boolean
    connect?: PerfilInstituicaoWhereUniqueInput
    update?: XOR<XOR<PerfilInstituicaoUpdateToOneWithWhereWithoutUsuarioInput, PerfilInstituicaoUpdateWithoutUsuarioInput>, PerfilInstituicaoUncheckedUpdateWithoutUsuarioInput>
  }

  export type PostagemBlogUncheckedUpdateManyWithoutAutorNestedInput = {
    create?: XOR<PostagemBlogCreateWithoutAutorInput, PostagemBlogUncheckedCreateWithoutAutorInput> | PostagemBlogCreateWithoutAutorInput[] | PostagemBlogUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: PostagemBlogCreateOrConnectWithoutAutorInput | PostagemBlogCreateOrConnectWithoutAutorInput[]
    upsert?: PostagemBlogUpsertWithWhereUniqueWithoutAutorInput | PostagemBlogUpsertWithWhereUniqueWithoutAutorInput[]
    createMany?: PostagemBlogCreateManyAutorInputEnvelope
    set?: PostagemBlogWhereUniqueInput | PostagemBlogWhereUniqueInput[]
    disconnect?: PostagemBlogWhereUniqueInput | PostagemBlogWhereUniqueInput[]
    delete?: PostagemBlogWhereUniqueInput | PostagemBlogWhereUniqueInput[]
    connect?: PostagemBlogWhereUniqueInput | PostagemBlogWhereUniqueInput[]
    update?: PostagemBlogUpdateWithWhereUniqueWithoutAutorInput | PostagemBlogUpdateWithWhereUniqueWithoutAutorInput[]
    updateMany?: PostagemBlogUpdateManyWithWhereWithoutAutorInput | PostagemBlogUpdateManyWithWhereWithoutAutorInput[]
    deleteMany?: PostagemBlogScalarWhereInput | PostagemBlogScalarWhereInput[]
  }

  export type MatriculaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<MatriculaCreateWithoutUsuarioInput, MatriculaUncheckedCreateWithoutUsuarioInput> | MatriculaCreateWithoutUsuarioInput[] | MatriculaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutUsuarioInput | MatriculaCreateOrConnectWithoutUsuarioInput[]
    upsert?: MatriculaUpsertWithWhereUniqueWithoutUsuarioInput | MatriculaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: MatriculaCreateManyUsuarioInputEnvelope
    set?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    disconnect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    delete?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    update?: MatriculaUpdateWithWhereUniqueWithoutUsuarioInput | MatriculaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: MatriculaUpdateManyWithWhereWithoutUsuarioInput | MatriculaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: MatriculaScalarWhereInput | MatriculaScalarWhereInput[]
  }

  export type CandidaturaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<CandidaturaCreateWithoutUsuarioInput, CandidaturaUncheckedCreateWithoutUsuarioInput> | CandidaturaCreateWithoutUsuarioInput[] | CandidaturaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CandidaturaCreateOrConnectWithoutUsuarioInput | CandidaturaCreateOrConnectWithoutUsuarioInput[]
    upsert?: CandidaturaUpsertWithWhereUniqueWithoutUsuarioInput | CandidaturaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: CandidaturaCreateManyUsuarioInputEnvelope
    set?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    disconnect?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    delete?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    connect?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    update?: CandidaturaUpdateWithWhereUniqueWithoutUsuarioInput | CandidaturaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: CandidaturaUpdateManyWithWhereWithoutUsuarioInput | CandidaturaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: CandidaturaScalarWhereInput | CandidaturaScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutPerfilEstudanteInput = {
    create?: XOR<UsuarioCreateWithoutPerfilEstudanteInput, UsuarioUncheckedCreateWithoutPerfilEstudanteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPerfilEstudanteInput
    connect?: UsuarioWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UsuarioUpdateOneRequiredWithoutPerfilEstudanteNestedInput = {
    create?: XOR<UsuarioCreateWithoutPerfilEstudanteInput, UsuarioUncheckedCreateWithoutPerfilEstudanteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPerfilEstudanteInput
    upsert?: UsuarioUpsertWithoutPerfilEstudanteInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPerfilEstudanteInput, UsuarioUpdateWithoutPerfilEstudanteInput>, UsuarioUncheckedUpdateWithoutPerfilEstudanteInput>
  }

  export type UsuarioCreateNestedOneWithoutPerfilInstituicaoInput = {
    create?: XOR<UsuarioCreateWithoutPerfilInstituicaoInput, UsuarioUncheckedCreateWithoutPerfilInstituicaoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPerfilInstituicaoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type CursoCreateNestedManyWithoutInstituicaoInput = {
    create?: XOR<CursoCreateWithoutInstituicaoInput, CursoUncheckedCreateWithoutInstituicaoInput> | CursoCreateWithoutInstituicaoInput[] | CursoUncheckedCreateWithoutInstituicaoInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutInstituicaoInput | CursoCreateOrConnectWithoutInstituicaoInput[]
    createMany?: CursoCreateManyInstituicaoInputEnvelope
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
  }

  export type OportunidadeCreateNestedManyWithoutInstituicaoInput = {
    create?: XOR<OportunidadeCreateWithoutInstituicaoInput, OportunidadeUncheckedCreateWithoutInstituicaoInput> | OportunidadeCreateWithoutInstituicaoInput[] | OportunidadeUncheckedCreateWithoutInstituicaoInput[]
    connectOrCreate?: OportunidadeCreateOrConnectWithoutInstituicaoInput | OportunidadeCreateOrConnectWithoutInstituicaoInput[]
    createMany?: OportunidadeCreateManyInstituicaoInputEnvelope
    connect?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
  }

  export type CursoUncheckedCreateNestedManyWithoutInstituicaoInput = {
    create?: XOR<CursoCreateWithoutInstituicaoInput, CursoUncheckedCreateWithoutInstituicaoInput> | CursoCreateWithoutInstituicaoInput[] | CursoUncheckedCreateWithoutInstituicaoInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutInstituicaoInput | CursoCreateOrConnectWithoutInstituicaoInput[]
    createMany?: CursoCreateManyInstituicaoInputEnvelope
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
  }

  export type OportunidadeUncheckedCreateNestedManyWithoutInstituicaoInput = {
    create?: XOR<OportunidadeCreateWithoutInstituicaoInput, OportunidadeUncheckedCreateWithoutInstituicaoInput> | OportunidadeCreateWithoutInstituicaoInput[] | OportunidadeUncheckedCreateWithoutInstituicaoInput[]
    connectOrCreate?: OportunidadeCreateOrConnectWithoutInstituicaoInput | OportunidadeCreateOrConnectWithoutInstituicaoInput[]
    createMany?: OportunidadeCreateManyInstituicaoInputEnvelope
    connect?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
  }

  export type UsuarioUpdateOneRequiredWithoutPerfilInstituicaoNestedInput = {
    create?: XOR<UsuarioCreateWithoutPerfilInstituicaoInput, UsuarioUncheckedCreateWithoutPerfilInstituicaoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPerfilInstituicaoInput
    upsert?: UsuarioUpsertWithoutPerfilInstituicaoInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPerfilInstituicaoInput, UsuarioUpdateWithoutPerfilInstituicaoInput>, UsuarioUncheckedUpdateWithoutPerfilInstituicaoInput>
  }

  export type CursoUpdateManyWithoutInstituicaoNestedInput = {
    create?: XOR<CursoCreateWithoutInstituicaoInput, CursoUncheckedCreateWithoutInstituicaoInput> | CursoCreateWithoutInstituicaoInput[] | CursoUncheckedCreateWithoutInstituicaoInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutInstituicaoInput | CursoCreateOrConnectWithoutInstituicaoInput[]
    upsert?: CursoUpsertWithWhereUniqueWithoutInstituicaoInput | CursoUpsertWithWhereUniqueWithoutInstituicaoInput[]
    createMany?: CursoCreateManyInstituicaoInputEnvelope
    set?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    disconnect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    delete?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    update?: CursoUpdateWithWhereUniqueWithoutInstituicaoInput | CursoUpdateWithWhereUniqueWithoutInstituicaoInput[]
    updateMany?: CursoUpdateManyWithWhereWithoutInstituicaoInput | CursoUpdateManyWithWhereWithoutInstituicaoInput[]
    deleteMany?: CursoScalarWhereInput | CursoScalarWhereInput[]
  }

  export type OportunidadeUpdateManyWithoutInstituicaoNestedInput = {
    create?: XOR<OportunidadeCreateWithoutInstituicaoInput, OportunidadeUncheckedCreateWithoutInstituicaoInput> | OportunidadeCreateWithoutInstituicaoInput[] | OportunidadeUncheckedCreateWithoutInstituicaoInput[]
    connectOrCreate?: OportunidadeCreateOrConnectWithoutInstituicaoInput | OportunidadeCreateOrConnectWithoutInstituicaoInput[]
    upsert?: OportunidadeUpsertWithWhereUniqueWithoutInstituicaoInput | OportunidadeUpsertWithWhereUniqueWithoutInstituicaoInput[]
    createMany?: OportunidadeCreateManyInstituicaoInputEnvelope
    set?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    disconnect?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    delete?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    connect?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    update?: OportunidadeUpdateWithWhereUniqueWithoutInstituicaoInput | OportunidadeUpdateWithWhereUniqueWithoutInstituicaoInput[]
    updateMany?: OportunidadeUpdateManyWithWhereWithoutInstituicaoInput | OportunidadeUpdateManyWithWhereWithoutInstituicaoInput[]
    deleteMany?: OportunidadeScalarWhereInput | OportunidadeScalarWhereInput[]
  }

  export type CursoUncheckedUpdateManyWithoutInstituicaoNestedInput = {
    create?: XOR<CursoCreateWithoutInstituicaoInput, CursoUncheckedCreateWithoutInstituicaoInput> | CursoCreateWithoutInstituicaoInput[] | CursoUncheckedCreateWithoutInstituicaoInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutInstituicaoInput | CursoCreateOrConnectWithoutInstituicaoInput[]
    upsert?: CursoUpsertWithWhereUniqueWithoutInstituicaoInput | CursoUpsertWithWhereUniqueWithoutInstituicaoInput[]
    createMany?: CursoCreateManyInstituicaoInputEnvelope
    set?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    disconnect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    delete?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    update?: CursoUpdateWithWhereUniqueWithoutInstituicaoInput | CursoUpdateWithWhereUniqueWithoutInstituicaoInput[]
    updateMany?: CursoUpdateManyWithWhereWithoutInstituicaoInput | CursoUpdateManyWithWhereWithoutInstituicaoInput[]
    deleteMany?: CursoScalarWhereInput | CursoScalarWhereInput[]
  }

  export type OportunidadeUncheckedUpdateManyWithoutInstituicaoNestedInput = {
    create?: XOR<OportunidadeCreateWithoutInstituicaoInput, OportunidadeUncheckedCreateWithoutInstituicaoInput> | OportunidadeCreateWithoutInstituicaoInput[] | OportunidadeUncheckedCreateWithoutInstituicaoInput[]
    connectOrCreate?: OportunidadeCreateOrConnectWithoutInstituicaoInput | OportunidadeCreateOrConnectWithoutInstituicaoInput[]
    upsert?: OportunidadeUpsertWithWhereUniqueWithoutInstituicaoInput | OportunidadeUpsertWithWhereUniqueWithoutInstituicaoInput[]
    createMany?: OportunidadeCreateManyInstituicaoInputEnvelope
    set?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    disconnect?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    delete?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    connect?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    update?: OportunidadeUpdateWithWhereUniqueWithoutInstituicaoInput | OportunidadeUpdateWithWhereUniqueWithoutInstituicaoInput[]
    updateMany?: OportunidadeUpdateManyWithWhereWithoutInstituicaoInput | OportunidadeUpdateManyWithWhereWithoutInstituicaoInput[]
    deleteMany?: OportunidadeScalarWhereInput | OportunidadeScalarWhereInput[]
  }

  export type CursoCategoriaCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<CursoCategoriaCreateWithoutCategoriaInput, CursoCategoriaUncheckedCreateWithoutCategoriaInput> | CursoCategoriaCreateWithoutCategoriaInput[] | CursoCategoriaUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: CursoCategoriaCreateOrConnectWithoutCategoriaInput | CursoCategoriaCreateOrConnectWithoutCategoriaInput[]
    createMany?: CursoCategoriaCreateManyCategoriaInputEnvelope
    connect?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
  }

  export type OportunidadeCreateNestedManyWithoutCategoriaCursoRelacionadaInput = {
    create?: XOR<OportunidadeCreateWithoutCategoriaCursoRelacionadaInput, OportunidadeUncheckedCreateWithoutCategoriaCursoRelacionadaInput> | OportunidadeCreateWithoutCategoriaCursoRelacionadaInput[] | OportunidadeUncheckedCreateWithoutCategoriaCursoRelacionadaInput[]
    connectOrCreate?: OportunidadeCreateOrConnectWithoutCategoriaCursoRelacionadaInput | OportunidadeCreateOrConnectWithoutCategoriaCursoRelacionadaInput[]
    createMany?: OportunidadeCreateManyCategoriaCursoRelacionadaInputEnvelope
    connect?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
  }

  export type CursoCategoriaUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<CursoCategoriaCreateWithoutCategoriaInput, CursoCategoriaUncheckedCreateWithoutCategoriaInput> | CursoCategoriaCreateWithoutCategoriaInput[] | CursoCategoriaUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: CursoCategoriaCreateOrConnectWithoutCategoriaInput | CursoCategoriaCreateOrConnectWithoutCategoriaInput[]
    createMany?: CursoCategoriaCreateManyCategoriaInputEnvelope
    connect?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
  }

  export type OportunidadeUncheckedCreateNestedManyWithoutCategoriaCursoRelacionadaInput = {
    create?: XOR<OportunidadeCreateWithoutCategoriaCursoRelacionadaInput, OportunidadeUncheckedCreateWithoutCategoriaCursoRelacionadaInput> | OportunidadeCreateWithoutCategoriaCursoRelacionadaInput[] | OportunidadeUncheckedCreateWithoutCategoriaCursoRelacionadaInput[]
    connectOrCreate?: OportunidadeCreateOrConnectWithoutCategoriaCursoRelacionadaInput | OportunidadeCreateOrConnectWithoutCategoriaCursoRelacionadaInput[]
    createMany?: OportunidadeCreateManyCategoriaCursoRelacionadaInputEnvelope
    connect?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
  }

  export type CursoCategoriaUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<CursoCategoriaCreateWithoutCategoriaInput, CursoCategoriaUncheckedCreateWithoutCategoriaInput> | CursoCategoriaCreateWithoutCategoriaInput[] | CursoCategoriaUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: CursoCategoriaCreateOrConnectWithoutCategoriaInput | CursoCategoriaCreateOrConnectWithoutCategoriaInput[]
    upsert?: CursoCategoriaUpsertWithWhereUniqueWithoutCategoriaInput | CursoCategoriaUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: CursoCategoriaCreateManyCategoriaInputEnvelope
    set?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    disconnect?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    delete?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    connect?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    update?: CursoCategoriaUpdateWithWhereUniqueWithoutCategoriaInput | CursoCategoriaUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: CursoCategoriaUpdateManyWithWhereWithoutCategoriaInput | CursoCategoriaUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: CursoCategoriaScalarWhereInput | CursoCategoriaScalarWhereInput[]
  }

  export type OportunidadeUpdateManyWithoutCategoriaCursoRelacionadaNestedInput = {
    create?: XOR<OportunidadeCreateWithoutCategoriaCursoRelacionadaInput, OportunidadeUncheckedCreateWithoutCategoriaCursoRelacionadaInput> | OportunidadeCreateWithoutCategoriaCursoRelacionadaInput[] | OportunidadeUncheckedCreateWithoutCategoriaCursoRelacionadaInput[]
    connectOrCreate?: OportunidadeCreateOrConnectWithoutCategoriaCursoRelacionadaInput | OportunidadeCreateOrConnectWithoutCategoriaCursoRelacionadaInput[]
    upsert?: OportunidadeUpsertWithWhereUniqueWithoutCategoriaCursoRelacionadaInput | OportunidadeUpsertWithWhereUniqueWithoutCategoriaCursoRelacionadaInput[]
    createMany?: OportunidadeCreateManyCategoriaCursoRelacionadaInputEnvelope
    set?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    disconnect?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    delete?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    connect?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    update?: OportunidadeUpdateWithWhereUniqueWithoutCategoriaCursoRelacionadaInput | OportunidadeUpdateWithWhereUniqueWithoutCategoriaCursoRelacionadaInput[]
    updateMany?: OportunidadeUpdateManyWithWhereWithoutCategoriaCursoRelacionadaInput | OportunidadeUpdateManyWithWhereWithoutCategoriaCursoRelacionadaInput[]
    deleteMany?: OportunidadeScalarWhereInput | OportunidadeScalarWhereInput[]
  }

  export type CursoCategoriaUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<CursoCategoriaCreateWithoutCategoriaInput, CursoCategoriaUncheckedCreateWithoutCategoriaInput> | CursoCategoriaCreateWithoutCategoriaInput[] | CursoCategoriaUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: CursoCategoriaCreateOrConnectWithoutCategoriaInput | CursoCategoriaCreateOrConnectWithoutCategoriaInput[]
    upsert?: CursoCategoriaUpsertWithWhereUniqueWithoutCategoriaInput | CursoCategoriaUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: CursoCategoriaCreateManyCategoriaInputEnvelope
    set?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    disconnect?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    delete?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    connect?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    update?: CursoCategoriaUpdateWithWhereUniqueWithoutCategoriaInput | CursoCategoriaUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: CursoCategoriaUpdateManyWithWhereWithoutCategoriaInput | CursoCategoriaUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: CursoCategoriaScalarWhereInput | CursoCategoriaScalarWhereInput[]
  }

  export type OportunidadeUncheckedUpdateManyWithoutCategoriaCursoRelacionadaNestedInput = {
    create?: XOR<OportunidadeCreateWithoutCategoriaCursoRelacionadaInput, OportunidadeUncheckedCreateWithoutCategoriaCursoRelacionadaInput> | OportunidadeCreateWithoutCategoriaCursoRelacionadaInput[] | OportunidadeUncheckedCreateWithoutCategoriaCursoRelacionadaInput[]
    connectOrCreate?: OportunidadeCreateOrConnectWithoutCategoriaCursoRelacionadaInput | OportunidadeCreateOrConnectWithoutCategoriaCursoRelacionadaInput[]
    upsert?: OportunidadeUpsertWithWhereUniqueWithoutCategoriaCursoRelacionadaInput | OportunidadeUpsertWithWhereUniqueWithoutCategoriaCursoRelacionadaInput[]
    createMany?: OportunidadeCreateManyCategoriaCursoRelacionadaInputEnvelope
    set?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    disconnect?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    delete?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    connect?: OportunidadeWhereUniqueInput | OportunidadeWhereUniqueInput[]
    update?: OportunidadeUpdateWithWhereUniqueWithoutCategoriaCursoRelacionadaInput | OportunidadeUpdateWithWhereUniqueWithoutCategoriaCursoRelacionadaInput[]
    updateMany?: OportunidadeUpdateManyWithWhereWithoutCategoriaCursoRelacionadaInput | OportunidadeUpdateManyWithWhereWithoutCategoriaCursoRelacionadaInput[]
    deleteMany?: OportunidadeScalarWhereInput | OportunidadeScalarWhereInput[]
  }

  export type PerfilInstituicaoCreateNestedOneWithoutCursosInput = {
    create?: XOR<PerfilInstituicaoCreateWithoutCursosInput, PerfilInstituicaoUncheckedCreateWithoutCursosInput>
    connectOrCreate?: PerfilInstituicaoCreateOrConnectWithoutCursosInput
    connect?: PerfilInstituicaoWhereUniqueInput
  }

  export type CursoCategoriaCreateNestedManyWithoutCursoInput = {
    create?: XOR<CursoCategoriaCreateWithoutCursoInput, CursoCategoriaUncheckedCreateWithoutCursoInput> | CursoCategoriaCreateWithoutCursoInput[] | CursoCategoriaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: CursoCategoriaCreateOrConnectWithoutCursoInput | CursoCategoriaCreateOrConnectWithoutCursoInput[]
    createMany?: CursoCategoriaCreateManyCursoInputEnvelope
    connect?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
  }

  export type MatriculaCreateNestedManyWithoutCursoInput = {
    create?: XOR<MatriculaCreateWithoutCursoInput, MatriculaUncheckedCreateWithoutCursoInput> | MatriculaCreateWithoutCursoInput[] | MatriculaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutCursoInput | MatriculaCreateOrConnectWithoutCursoInput[]
    createMany?: MatriculaCreateManyCursoInputEnvelope
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
  }

  export type CursoCategoriaUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<CursoCategoriaCreateWithoutCursoInput, CursoCategoriaUncheckedCreateWithoutCursoInput> | CursoCategoriaCreateWithoutCursoInput[] | CursoCategoriaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: CursoCategoriaCreateOrConnectWithoutCursoInput | CursoCategoriaCreateOrConnectWithoutCursoInput[]
    createMany?: CursoCategoriaCreateManyCursoInputEnvelope
    connect?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
  }

  export type MatriculaUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<MatriculaCreateWithoutCursoInput, MatriculaUncheckedCreateWithoutCursoInput> | MatriculaCreateWithoutCursoInput[] | MatriculaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutCursoInput | MatriculaCreateOrConnectWithoutCursoInput[]
    createMany?: MatriculaCreateManyCursoInputEnvelope
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
  }

  export type EnumCourseModalityEnumFieldUpdateOperationsInput = {
    set?: $Enums.CourseModalityEnum
  }

  export type EnumCourseLevelEnumFieldUpdateOperationsInput = {
    set?: $Enums.CourseLevelEnum
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PerfilInstituicaoUpdateOneRequiredWithoutCursosNestedInput = {
    create?: XOR<PerfilInstituicaoCreateWithoutCursosInput, PerfilInstituicaoUncheckedCreateWithoutCursosInput>
    connectOrCreate?: PerfilInstituicaoCreateOrConnectWithoutCursosInput
    upsert?: PerfilInstituicaoUpsertWithoutCursosInput
    connect?: PerfilInstituicaoWhereUniqueInput
    update?: XOR<XOR<PerfilInstituicaoUpdateToOneWithWhereWithoutCursosInput, PerfilInstituicaoUpdateWithoutCursosInput>, PerfilInstituicaoUncheckedUpdateWithoutCursosInput>
  }

  export type CursoCategoriaUpdateManyWithoutCursoNestedInput = {
    create?: XOR<CursoCategoriaCreateWithoutCursoInput, CursoCategoriaUncheckedCreateWithoutCursoInput> | CursoCategoriaCreateWithoutCursoInput[] | CursoCategoriaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: CursoCategoriaCreateOrConnectWithoutCursoInput | CursoCategoriaCreateOrConnectWithoutCursoInput[]
    upsert?: CursoCategoriaUpsertWithWhereUniqueWithoutCursoInput | CursoCategoriaUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: CursoCategoriaCreateManyCursoInputEnvelope
    set?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    disconnect?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    delete?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    connect?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    update?: CursoCategoriaUpdateWithWhereUniqueWithoutCursoInput | CursoCategoriaUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: CursoCategoriaUpdateManyWithWhereWithoutCursoInput | CursoCategoriaUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: CursoCategoriaScalarWhereInput | CursoCategoriaScalarWhereInput[]
  }

  export type MatriculaUpdateManyWithoutCursoNestedInput = {
    create?: XOR<MatriculaCreateWithoutCursoInput, MatriculaUncheckedCreateWithoutCursoInput> | MatriculaCreateWithoutCursoInput[] | MatriculaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutCursoInput | MatriculaCreateOrConnectWithoutCursoInput[]
    upsert?: MatriculaUpsertWithWhereUniqueWithoutCursoInput | MatriculaUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: MatriculaCreateManyCursoInputEnvelope
    set?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    disconnect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    delete?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    update?: MatriculaUpdateWithWhereUniqueWithoutCursoInput | MatriculaUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: MatriculaUpdateManyWithWhereWithoutCursoInput | MatriculaUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: MatriculaScalarWhereInput | MatriculaScalarWhereInput[]
  }

  export type CursoCategoriaUncheckedUpdateManyWithoutCursoNestedInput = {
    create?: XOR<CursoCategoriaCreateWithoutCursoInput, CursoCategoriaUncheckedCreateWithoutCursoInput> | CursoCategoriaCreateWithoutCursoInput[] | CursoCategoriaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: CursoCategoriaCreateOrConnectWithoutCursoInput | CursoCategoriaCreateOrConnectWithoutCursoInput[]
    upsert?: CursoCategoriaUpsertWithWhereUniqueWithoutCursoInput | CursoCategoriaUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: CursoCategoriaCreateManyCursoInputEnvelope
    set?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    disconnect?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    delete?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    connect?: CursoCategoriaWhereUniqueInput | CursoCategoriaWhereUniqueInput[]
    update?: CursoCategoriaUpdateWithWhereUniqueWithoutCursoInput | CursoCategoriaUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: CursoCategoriaUpdateManyWithWhereWithoutCursoInput | CursoCategoriaUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: CursoCategoriaScalarWhereInput | CursoCategoriaScalarWhereInput[]
  }

  export type MatriculaUncheckedUpdateManyWithoutCursoNestedInput = {
    create?: XOR<MatriculaCreateWithoutCursoInput, MatriculaUncheckedCreateWithoutCursoInput> | MatriculaCreateWithoutCursoInput[] | MatriculaUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: MatriculaCreateOrConnectWithoutCursoInput | MatriculaCreateOrConnectWithoutCursoInput[]
    upsert?: MatriculaUpsertWithWhereUniqueWithoutCursoInput | MatriculaUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: MatriculaCreateManyCursoInputEnvelope
    set?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    disconnect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    delete?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    connect?: MatriculaWhereUniqueInput | MatriculaWhereUniqueInput[]
    update?: MatriculaUpdateWithWhereUniqueWithoutCursoInput | MatriculaUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: MatriculaUpdateManyWithWhereWithoutCursoInput | MatriculaUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: MatriculaScalarWhereInput | MatriculaScalarWhereInput[]
  }

  export type CursoCreateNestedOneWithoutCategoriasInput = {
    create?: XOR<CursoCreateWithoutCategoriasInput, CursoUncheckedCreateWithoutCategoriasInput>
    connectOrCreate?: CursoCreateOrConnectWithoutCategoriasInput
    connect?: CursoWhereUniqueInput
  }

  export type CategoriaCursoCreateNestedOneWithoutCursosInput = {
    create?: XOR<CategoriaCursoCreateWithoutCursosInput, CategoriaCursoUncheckedCreateWithoutCursosInput>
    connectOrCreate?: CategoriaCursoCreateOrConnectWithoutCursosInput
    connect?: CategoriaCursoWhereUniqueInput
  }

  export type CursoUpdateOneRequiredWithoutCategoriasNestedInput = {
    create?: XOR<CursoCreateWithoutCategoriasInput, CursoUncheckedCreateWithoutCategoriasInput>
    connectOrCreate?: CursoCreateOrConnectWithoutCategoriasInput
    upsert?: CursoUpsertWithoutCategoriasInput
    connect?: CursoWhereUniqueInput
    update?: XOR<XOR<CursoUpdateToOneWithWhereWithoutCategoriasInput, CursoUpdateWithoutCategoriasInput>, CursoUncheckedUpdateWithoutCategoriasInput>
  }

  export type CategoriaCursoUpdateOneRequiredWithoutCursosNestedInput = {
    create?: XOR<CategoriaCursoCreateWithoutCursosInput, CategoriaCursoUncheckedCreateWithoutCursosInput>
    connectOrCreate?: CategoriaCursoCreateOrConnectWithoutCursosInput
    upsert?: CategoriaCursoUpsertWithoutCursosInput
    connect?: CategoriaCursoWhereUniqueInput
    update?: XOR<XOR<CategoriaCursoUpdateToOneWithWhereWithoutCursosInput, CategoriaCursoUpdateWithoutCursosInput>, CategoriaCursoUncheckedUpdateWithoutCursosInput>
  }

  export type PerfilInstituicaoCreateNestedOneWithoutOportunidadesInput = {
    create?: XOR<PerfilInstituicaoCreateWithoutOportunidadesInput, PerfilInstituicaoUncheckedCreateWithoutOportunidadesInput>
    connectOrCreate?: PerfilInstituicaoCreateOrConnectWithoutOportunidadesInput
    connect?: PerfilInstituicaoWhereUniqueInput
  }

  export type CategoriaCursoCreateNestedOneWithoutOportunidadesRelacionadasInput = {
    create?: XOR<CategoriaCursoCreateWithoutOportunidadesRelacionadasInput, CategoriaCursoUncheckedCreateWithoutOportunidadesRelacionadasInput>
    connectOrCreate?: CategoriaCursoCreateOrConnectWithoutOportunidadesRelacionadasInput
    connect?: CategoriaCursoWhereUniqueInput
  }

  export type CandidaturaCreateNestedManyWithoutOportunidadeInput = {
    create?: XOR<CandidaturaCreateWithoutOportunidadeInput, CandidaturaUncheckedCreateWithoutOportunidadeInput> | CandidaturaCreateWithoutOportunidadeInput[] | CandidaturaUncheckedCreateWithoutOportunidadeInput[]
    connectOrCreate?: CandidaturaCreateOrConnectWithoutOportunidadeInput | CandidaturaCreateOrConnectWithoutOportunidadeInput[]
    createMany?: CandidaturaCreateManyOportunidadeInputEnvelope
    connect?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
  }

  export type CandidaturaUncheckedCreateNestedManyWithoutOportunidadeInput = {
    create?: XOR<CandidaturaCreateWithoutOportunidadeInput, CandidaturaUncheckedCreateWithoutOportunidadeInput> | CandidaturaCreateWithoutOportunidadeInput[] | CandidaturaUncheckedCreateWithoutOportunidadeInput[]
    connectOrCreate?: CandidaturaCreateOrConnectWithoutOportunidadeInput | CandidaturaCreateOrConnectWithoutOportunidadeInput[]
    createMany?: CandidaturaCreateManyOportunidadeInputEnvelope
    connect?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
  }

  export type PerfilInstituicaoUpdateOneRequiredWithoutOportunidadesNestedInput = {
    create?: XOR<PerfilInstituicaoCreateWithoutOportunidadesInput, PerfilInstituicaoUncheckedCreateWithoutOportunidadesInput>
    connectOrCreate?: PerfilInstituicaoCreateOrConnectWithoutOportunidadesInput
    upsert?: PerfilInstituicaoUpsertWithoutOportunidadesInput
    connect?: PerfilInstituicaoWhereUniqueInput
    update?: XOR<XOR<PerfilInstituicaoUpdateToOneWithWhereWithoutOportunidadesInput, PerfilInstituicaoUpdateWithoutOportunidadesInput>, PerfilInstituicaoUncheckedUpdateWithoutOportunidadesInput>
  }

  export type CategoriaCursoUpdateOneWithoutOportunidadesRelacionadasNestedInput = {
    create?: XOR<CategoriaCursoCreateWithoutOportunidadesRelacionadasInput, CategoriaCursoUncheckedCreateWithoutOportunidadesRelacionadasInput>
    connectOrCreate?: CategoriaCursoCreateOrConnectWithoutOportunidadesRelacionadasInput
    upsert?: CategoriaCursoUpsertWithoutOportunidadesRelacionadasInput
    disconnect?: CategoriaCursoWhereInput | boolean
    delete?: CategoriaCursoWhereInput | boolean
    connect?: CategoriaCursoWhereUniqueInput
    update?: XOR<XOR<CategoriaCursoUpdateToOneWithWhereWithoutOportunidadesRelacionadasInput, CategoriaCursoUpdateWithoutOportunidadesRelacionadasInput>, CategoriaCursoUncheckedUpdateWithoutOportunidadesRelacionadasInput>
  }

  export type CandidaturaUpdateManyWithoutOportunidadeNestedInput = {
    create?: XOR<CandidaturaCreateWithoutOportunidadeInput, CandidaturaUncheckedCreateWithoutOportunidadeInput> | CandidaturaCreateWithoutOportunidadeInput[] | CandidaturaUncheckedCreateWithoutOportunidadeInput[]
    connectOrCreate?: CandidaturaCreateOrConnectWithoutOportunidadeInput | CandidaturaCreateOrConnectWithoutOportunidadeInput[]
    upsert?: CandidaturaUpsertWithWhereUniqueWithoutOportunidadeInput | CandidaturaUpsertWithWhereUniqueWithoutOportunidadeInput[]
    createMany?: CandidaturaCreateManyOportunidadeInputEnvelope
    set?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    disconnect?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    delete?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    connect?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    update?: CandidaturaUpdateWithWhereUniqueWithoutOportunidadeInput | CandidaturaUpdateWithWhereUniqueWithoutOportunidadeInput[]
    updateMany?: CandidaturaUpdateManyWithWhereWithoutOportunidadeInput | CandidaturaUpdateManyWithWhereWithoutOportunidadeInput[]
    deleteMany?: CandidaturaScalarWhereInput | CandidaturaScalarWhereInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type CandidaturaUncheckedUpdateManyWithoutOportunidadeNestedInput = {
    create?: XOR<CandidaturaCreateWithoutOportunidadeInput, CandidaturaUncheckedCreateWithoutOportunidadeInput> | CandidaturaCreateWithoutOportunidadeInput[] | CandidaturaUncheckedCreateWithoutOportunidadeInput[]
    connectOrCreate?: CandidaturaCreateOrConnectWithoutOportunidadeInput | CandidaturaCreateOrConnectWithoutOportunidadeInput[]
    upsert?: CandidaturaUpsertWithWhereUniqueWithoutOportunidadeInput | CandidaturaUpsertWithWhereUniqueWithoutOportunidadeInput[]
    createMany?: CandidaturaCreateManyOportunidadeInputEnvelope
    set?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    disconnect?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    delete?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    connect?: CandidaturaWhereUniqueInput | CandidaturaWhereUniqueInput[]
    update?: CandidaturaUpdateWithWhereUniqueWithoutOportunidadeInput | CandidaturaUpdateWithWhereUniqueWithoutOportunidadeInput[]
    updateMany?: CandidaturaUpdateManyWithWhereWithoutOportunidadeInput | CandidaturaUpdateManyWithWhereWithoutOportunidadeInput[]
    deleteMany?: CandidaturaScalarWhereInput | CandidaturaScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutPostagensBlogInput = {
    create?: XOR<UsuarioCreateWithoutPostagensBlogInput, UsuarioUncheckedCreateWithoutPostagensBlogInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPostagensBlogInput
    connect?: UsuarioWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UsuarioUpdateOneRequiredWithoutPostagensBlogNestedInput = {
    create?: XOR<UsuarioCreateWithoutPostagensBlogInput, UsuarioUncheckedCreateWithoutPostagensBlogInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPostagensBlogInput
    upsert?: UsuarioUpsertWithoutPostagensBlogInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPostagensBlogInput, UsuarioUpdateWithoutPostagensBlogInput>, UsuarioUncheckedUpdateWithoutPostagensBlogInput>
  }

  export type CursoCreateNestedOneWithoutMatriculasInput = {
    create?: XOR<CursoCreateWithoutMatriculasInput, CursoUncheckedCreateWithoutMatriculasInput>
    connectOrCreate?: CursoCreateOrConnectWithoutMatriculasInput
    connect?: CursoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutMatriculasInput = {
    create?: XOR<UsuarioCreateWithoutMatriculasInput, UsuarioUncheckedCreateWithoutMatriculasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutMatriculasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type CursoUpdateOneRequiredWithoutMatriculasNestedInput = {
    create?: XOR<CursoCreateWithoutMatriculasInput, CursoUncheckedCreateWithoutMatriculasInput>
    connectOrCreate?: CursoCreateOrConnectWithoutMatriculasInput
    upsert?: CursoUpsertWithoutMatriculasInput
    connect?: CursoWhereUniqueInput
    update?: XOR<XOR<CursoUpdateToOneWithWhereWithoutMatriculasInput, CursoUpdateWithoutMatriculasInput>, CursoUncheckedUpdateWithoutMatriculasInput>
  }

  export type UsuarioUpdateOneRequiredWithoutMatriculasNestedInput = {
    create?: XOR<UsuarioCreateWithoutMatriculasInput, UsuarioUncheckedCreateWithoutMatriculasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutMatriculasInput
    upsert?: UsuarioUpsertWithoutMatriculasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutMatriculasInput, UsuarioUpdateWithoutMatriculasInput>, UsuarioUncheckedUpdateWithoutMatriculasInput>
  }

  export type OportunidadeCreateNestedOneWithoutCandidaturasInput = {
    create?: XOR<OportunidadeCreateWithoutCandidaturasInput, OportunidadeUncheckedCreateWithoutCandidaturasInput>
    connectOrCreate?: OportunidadeCreateOrConnectWithoutCandidaturasInput
    connect?: OportunidadeWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutCandidaturasInput = {
    create?: XOR<UsuarioCreateWithoutCandidaturasInput, UsuarioUncheckedCreateWithoutCandidaturasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCandidaturasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type OportunidadeUpdateOneRequiredWithoutCandidaturasNestedInput = {
    create?: XOR<OportunidadeCreateWithoutCandidaturasInput, OportunidadeUncheckedCreateWithoutCandidaturasInput>
    connectOrCreate?: OportunidadeCreateOrConnectWithoutCandidaturasInput
    upsert?: OportunidadeUpsertWithoutCandidaturasInput
    connect?: OportunidadeWhereUniqueInput
    update?: XOR<XOR<OportunidadeUpdateToOneWithWhereWithoutCandidaturasInput, OportunidadeUpdateWithoutCandidaturasInput>, OportunidadeUncheckedUpdateWithoutCandidaturasInput>
  }

  export type UsuarioUpdateOneRequiredWithoutCandidaturasNestedInput = {
    create?: XOR<UsuarioCreateWithoutCandidaturasInput, UsuarioUncheckedCreateWithoutCandidaturasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCandidaturasInput
    upsert?: UsuarioUpsertWithoutCandidaturasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutCandidaturasInput, UsuarioUpdateWithoutCandidaturasInput>, UsuarioUncheckedUpdateWithoutCandidaturasInput>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTypeEnum | EnumUserTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.UserTypeEnum[] | ListEnumUserTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTypeEnum[] | ListEnumUserTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeEnumFilter<$PrismaModel> | $Enums.UserTypeEnum
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTypeEnum | EnumUserTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.UserTypeEnum[] | ListEnumUserTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTypeEnum[] | ListEnumUserTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.UserTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumUserTypeEnumFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCourseModalityEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseModalityEnum | EnumCourseModalityEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CourseModalityEnum[] | ListEnumCourseModalityEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseModalityEnum[] | ListEnumCourseModalityEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseModalityEnumFilter<$PrismaModel> | $Enums.CourseModalityEnum
  }

  export type NestedEnumCourseLevelEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevelEnum | EnumCourseLevelEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevelEnum[] | ListEnumCourseLevelEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevelEnum[] | ListEnumCourseLevelEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelEnumFilter<$PrismaModel> | $Enums.CourseLevelEnum
  }

  export type NestedEnumCourseModalityEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseModalityEnum | EnumCourseModalityEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CourseModalityEnum[] | ListEnumCourseModalityEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseModalityEnum[] | ListEnumCourseModalityEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseModalityEnumWithAggregatesFilter<$PrismaModel> | $Enums.CourseModalityEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseModalityEnumFilter<$PrismaModel>
    _max?: NestedEnumCourseModalityEnumFilter<$PrismaModel>
  }

  export type NestedEnumCourseLevelEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseLevelEnum | EnumCourseLevelEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CourseLevelEnum[] | ListEnumCourseLevelEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseLevelEnum[] | ListEnumCourseLevelEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseLevelEnumWithAggregatesFilter<$PrismaModel> | $Enums.CourseLevelEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseLevelEnumFilter<$PrismaModel>
    _max?: NestedEnumCourseLevelEnumFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PerfilEstudanteCreateWithoutUsuarioInput = {
    id?: bigint | number
    nomeEscola: string
    areaInteressePrincipal: string
    urlCurriculo?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type PerfilEstudanteUncheckedCreateWithoutUsuarioInput = {
    id?: bigint | number
    nomeEscola: string
    areaInteressePrincipal: string
    urlCurriculo?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type PerfilEstudanteCreateOrConnectWithoutUsuarioInput = {
    where: PerfilEstudanteWhereUniqueInput
    create: XOR<PerfilEstudanteCreateWithoutUsuarioInput, PerfilEstudanteUncheckedCreateWithoutUsuarioInput>
  }

  export type PerfilInstituicaoCreateWithoutUsuarioInput = {
    id?: bigint | number
    nomeInstituicao: string
    descricao: string
    urlSite?: string | null
    urlLogo?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    cursos?: CursoCreateNestedManyWithoutInstituicaoInput
    oportunidades?: OportunidadeCreateNestedManyWithoutInstituicaoInput
  }

  export type PerfilInstituicaoUncheckedCreateWithoutUsuarioInput = {
    id?: bigint | number
    nomeInstituicao: string
    descricao: string
    urlSite?: string | null
    urlLogo?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    cursos?: CursoUncheckedCreateNestedManyWithoutInstituicaoInput
    oportunidades?: OportunidadeUncheckedCreateNestedManyWithoutInstituicaoInput
  }

  export type PerfilInstituicaoCreateOrConnectWithoutUsuarioInput = {
    where: PerfilInstituicaoWhereUniqueInput
    create: XOR<PerfilInstituicaoCreateWithoutUsuarioInput, PerfilInstituicaoUncheckedCreateWithoutUsuarioInput>
  }

  export type PostagemBlogCreateWithoutAutorInput = {
    id?: bigint | number
    titulo: string
    conteudo: string
    slug: string
    publicadoEm?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type PostagemBlogUncheckedCreateWithoutAutorInput = {
    id?: bigint | number
    titulo: string
    conteudo: string
    slug: string
    publicadoEm?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type PostagemBlogCreateOrConnectWithoutAutorInput = {
    where: PostagemBlogWhereUniqueInput
    create: XOR<PostagemBlogCreateWithoutAutorInput, PostagemBlogUncheckedCreateWithoutAutorInput>
  }

  export type PostagemBlogCreateManyAutorInputEnvelope = {
    data: PostagemBlogCreateManyAutorInput | PostagemBlogCreateManyAutorInput[]
    skipDuplicates?: boolean
  }

  export type MatriculaCreateWithoutUsuarioInput = {
    id?: bigint | number
    status?: string
    dataInscricao?: Date | string
    curso: CursoCreateNestedOneWithoutMatriculasInput
  }

  export type MatriculaUncheckedCreateWithoutUsuarioInput = {
    id?: bigint | number
    cursoId: bigint | number
    status?: string
    dataInscricao?: Date | string
  }

  export type MatriculaCreateOrConnectWithoutUsuarioInput = {
    where: MatriculaWhereUniqueInput
    create: XOR<MatriculaCreateWithoutUsuarioInput, MatriculaUncheckedCreateWithoutUsuarioInput>
  }

  export type MatriculaCreateManyUsuarioInputEnvelope = {
    data: MatriculaCreateManyUsuarioInput | MatriculaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type CandidaturaCreateWithoutUsuarioInput = {
    id?: bigint | number
    status?: string
    dataCandidatura?: Date | string
    oportunidade: OportunidadeCreateNestedOneWithoutCandidaturasInput
  }

  export type CandidaturaUncheckedCreateWithoutUsuarioInput = {
    id?: bigint | number
    oportunidadeId: bigint | number
    status?: string
    dataCandidatura?: Date | string
  }

  export type CandidaturaCreateOrConnectWithoutUsuarioInput = {
    where: CandidaturaWhereUniqueInput
    create: XOR<CandidaturaCreateWithoutUsuarioInput, CandidaturaUncheckedCreateWithoutUsuarioInput>
  }

  export type CandidaturaCreateManyUsuarioInputEnvelope = {
    data: CandidaturaCreateManyUsuarioInput | CandidaturaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type PerfilEstudanteUpsertWithoutUsuarioInput = {
    update: XOR<PerfilEstudanteUpdateWithoutUsuarioInput, PerfilEstudanteUncheckedUpdateWithoutUsuarioInput>
    create: XOR<PerfilEstudanteCreateWithoutUsuarioInput, PerfilEstudanteUncheckedCreateWithoutUsuarioInput>
    where?: PerfilEstudanteWhereInput
  }

  export type PerfilEstudanteUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: PerfilEstudanteWhereInput
    data: XOR<PerfilEstudanteUpdateWithoutUsuarioInput, PerfilEstudanteUncheckedUpdateWithoutUsuarioInput>
  }

  export type PerfilEstudanteUpdateWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeEscola?: StringFieldUpdateOperationsInput | string
    areaInteressePrincipal?: StringFieldUpdateOperationsInput | string
    urlCurriculo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerfilEstudanteUncheckedUpdateWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeEscola?: StringFieldUpdateOperationsInput | string
    areaInteressePrincipal?: StringFieldUpdateOperationsInput | string
    urlCurriculo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerfilInstituicaoUpsertWithoutUsuarioInput = {
    update: XOR<PerfilInstituicaoUpdateWithoutUsuarioInput, PerfilInstituicaoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<PerfilInstituicaoCreateWithoutUsuarioInput, PerfilInstituicaoUncheckedCreateWithoutUsuarioInput>
    where?: PerfilInstituicaoWhereInput
  }

  export type PerfilInstituicaoUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: PerfilInstituicaoWhereInput
    data: XOR<PerfilInstituicaoUpdateWithoutUsuarioInput, PerfilInstituicaoUncheckedUpdateWithoutUsuarioInput>
  }

  export type PerfilInstituicaoUpdateWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeInstituicao?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    urlSite?: NullableStringFieldUpdateOperationsInput | string | null
    urlLogo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    cursos?: CursoUpdateManyWithoutInstituicaoNestedInput
    oportunidades?: OportunidadeUpdateManyWithoutInstituicaoNestedInput
  }

  export type PerfilInstituicaoUncheckedUpdateWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeInstituicao?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    urlSite?: NullableStringFieldUpdateOperationsInput | string | null
    urlLogo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    cursos?: CursoUncheckedUpdateManyWithoutInstituicaoNestedInput
    oportunidades?: OportunidadeUncheckedUpdateManyWithoutInstituicaoNestedInput
  }

  export type PostagemBlogUpsertWithWhereUniqueWithoutAutorInput = {
    where: PostagemBlogWhereUniqueInput
    update: XOR<PostagemBlogUpdateWithoutAutorInput, PostagemBlogUncheckedUpdateWithoutAutorInput>
    create: XOR<PostagemBlogCreateWithoutAutorInput, PostagemBlogUncheckedCreateWithoutAutorInput>
  }

  export type PostagemBlogUpdateWithWhereUniqueWithoutAutorInput = {
    where: PostagemBlogWhereUniqueInput
    data: XOR<PostagemBlogUpdateWithoutAutorInput, PostagemBlogUncheckedUpdateWithoutAutorInput>
  }

  export type PostagemBlogUpdateManyWithWhereWithoutAutorInput = {
    where: PostagemBlogScalarWhereInput
    data: XOR<PostagemBlogUpdateManyMutationInput, PostagemBlogUncheckedUpdateManyWithoutAutorInput>
  }

  export type PostagemBlogScalarWhereInput = {
    AND?: PostagemBlogScalarWhereInput | PostagemBlogScalarWhereInput[]
    OR?: PostagemBlogScalarWhereInput[]
    NOT?: PostagemBlogScalarWhereInput | PostagemBlogScalarWhereInput[]
    id?: BigIntFilter<"PostagemBlog"> | bigint | number
    autorId?: BigIntFilter<"PostagemBlog"> | bigint | number
    titulo?: StringFilter<"PostagemBlog"> | string
    conteudo?: StringFilter<"PostagemBlog"> | string
    slug?: StringFilter<"PostagemBlog"> | string
    publicadoEm?: DateTimeNullableFilter<"PostagemBlog"> | Date | string | null
    criadoEm?: DateTimeFilter<"PostagemBlog"> | Date | string
    atualizadoEm?: DateTimeFilter<"PostagemBlog"> | Date | string
  }

  export type MatriculaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: MatriculaWhereUniqueInput
    update: XOR<MatriculaUpdateWithoutUsuarioInput, MatriculaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<MatriculaCreateWithoutUsuarioInput, MatriculaUncheckedCreateWithoutUsuarioInput>
  }

  export type MatriculaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: MatriculaWhereUniqueInput
    data: XOR<MatriculaUpdateWithoutUsuarioInput, MatriculaUncheckedUpdateWithoutUsuarioInput>
  }

  export type MatriculaUpdateManyWithWhereWithoutUsuarioInput = {
    where: MatriculaScalarWhereInput
    data: XOR<MatriculaUpdateManyMutationInput, MatriculaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type MatriculaScalarWhereInput = {
    AND?: MatriculaScalarWhereInput | MatriculaScalarWhereInput[]
    OR?: MatriculaScalarWhereInput[]
    NOT?: MatriculaScalarWhereInput | MatriculaScalarWhereInput[]
    id?: BigIntFilter<"Matricula"> | bigint | number
    cursoId?: BigIntFilter<"Matricula"> | bigint | number
    usuarioId?: BigIntFilter<"Matricula"> | bigint | number
    status?: StringFilter<"Matricula"> | string
    dataInscricao?: DateTimeFilter<"Matricula"> | Date | string
  }

  export type CandidaturaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: CandidaturaWhereUniqueInput
    update: XOR<CandidaturaUpdateWithoutUsuarioInput, CandidaturaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<CandidaturaCreateWithoutUsuarioInput, CandidaturaUncheckedCreateWithoutUsuarioInput>
  }

  export type CandidaturaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: CandidaturaWhereUniqueInput
    data: XOR<CandidaturaUpdateWithoutUsuarioInput, CandidaturaUncheckedUpdateWithoutUsuarioInput>
  }

  export type CandidaturaUpdateManyWithWhereWithoutUsuarioInput = {
    where: CandidaturaScalarWhereInput
    data: XOR<CandidaturaUpdateManyMutationInput, CandidaturaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type CandidaturaScalarWhereInput = {
    AND?: CandidaturaScalarWhereInput | CandidaturaScalarWhereInput[]
    OR?: CandidaturaScalarWhereInput[]
    NOT?: CandidaturaScalarWhereInput | CandidaturaScalarWhereInput[]
    id?: BigIntFilter<"Candidatura"> | bigint | number
    oportunidadeId?: BigIntFilter<"Candidatura"> | bigint | number
    usuarioId?: BigIntFilter<"Candidatura"> | bigint | number
    status?: StringFilter<"Candidatura"> | string
    dataCandidatura?: DateTimeFilter<"Candidatura"> | Date | string
  }

  export type UsuarioCreateWithoutPerfilEstudanteInput = {
    id?: bigint | number
    publicId?: string
    nomeCompleto: string
    email: string
    senha: string
    tipoUsuario: $Enums.UserTypeEnum
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    perfilInstituicao?: PerfilInstituicaoCreateNestedOneWithoutUsuarioInput
    postagensBlog?: PostagemBlogCreateNestedManyWithoutAutorInput
    matriculas?: MatriculaCreateNestedManyWithoutUsuarioInput
    candidaturas?: CandidaturaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPerfilEstudanteInput = {
    id?: bigint | number
    publicId?: string
    nomeCompleto: string
    email: string
    senha: string
    tipoUsuario: $Enums.UserTypeEnum
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    perfilInstituicao?: PerfilInstituicaoUncheckedCreateNestedOneWithoutUsuarioInput
    postagensBlog?: PostagemBlogUncheckedCreateNestedManyWithoutAutorInput
    matriculas?: MatriculaUncheckedCreateNestedManyWithoutUsuarioInput
    candidaturas?: CandidaturaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPerfilEstudanteInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPerfilEstudanteInput, UsuarioUncheckedCreateWithoutPerfilEstudanteInput>
  }

  export type UsuarioUpsertWithoutPerfilEstudanteInput = {
    update: XOR<UsuarioUpdateWithoutPerfilEstudanteInput, UsuarioUncheckedUpdateWithoutPerfilEstudanteInput>
    create: XOR<UsuarioCreateWithoutPerfilEstudanteInput, UsuarioUncheckedCreateWithoutPerfilEstudanteInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPerfilEstudanteInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPerfilEstudanteInput, UsuarioUncheckedUpdateWithoutPerfilEstudanteInput>
  }

  export type UsuarioUpdateWithoutPerfilEstudanteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publicId?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: EnumUserTypeEnumFieldUpdateOperationsInput | $Enums.UserTypeEnum
    emailConfirmado?: BoolFieldUpdateOperationsInput | boolean
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    perfilInstituicao?: PerfilInstituicaoUpdateOneWithoutUsuarioNestedInput
    postagensBlog?: PostagemBlogUpdateManyWithoutAutorNestedInput
    matriculas?: MatriculaUpdateManyWithoutUsuarioNestedInput
    candidaturas?: CandidaturaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPerfilEstudanteInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publicId?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: EnumUserTypeEnumFieldUpdateOperationsInput | $Enums.UserTypeEnum
    emailConfirmado?: BoolFieldUpdateOperationsInput | boolean
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    perfilInstituicao?: PerfilInstituicaoUncheckedUpdateOneWithoutUsuarioNestedInput
    postagensBlog?: PostagemBlogUncheckedUpdateManyWithoutAutorNestedInput
    matriculas?: MatriculaUncheckedUpdateManyWithoutUsuarioNestedInput
    candidaturas?: CandidaturaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutPerfilInstituicaoInput = {
    id?: bigint | number
    publicId?: string
    nomeCompleto: string
    email: string
    senha: string
    tipoUsuario: $Enums.UserTypeEnum
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    perfilEstudante?: PerfilEstudanteCreateNestedOneWithoutUsuarioInput
    postagensBlog?: PostagemBlogCreateNestedManyWithoutAutorInput
    matriculas?: MatriculaCreateNestedManyWithoutUsuarioInput
    candidaturas?: CandidaturaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPerfilInstituicaoInput = {
    id?: bigint | number
    publicId?: string
    nomeCompleto: string
    email: string
    senha: string
    tipoUsuario: $Enums.UserTypeEnum
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    perfilEstudante?: PerfilEstudanteUncheckedCreateNestedOneWithoutUsuarioInput
    postagensBlog?: PostagemBlogUncheckedCreateNestedManyWithoutAutorInput
    matriculas?: MatriculaUncheckedCreateNestedManyWithoutUsuarioInput
    candidaturas?: CandidaturaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPerfilInstituicaoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPerfilInstituicaoInput, UsuarioUncheckedCreateWithoutPerfilInstituicaoInput>
  }

  export type CursoCreateWithoutInstituicaoInput = {
    id?: bigint | number
    titulo: string
    descricao: string
    modalidade: $Enums.CourseModalityEnum
    nivel: $Enums.CourseLevelEnum
    cargaHorariaHoras: number
    localizacao?: string | null
    requisitos: string
    linkInscricao: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    categorias?: CursoCategoriaCreateNestedManyWithoutCursoInput
    matriculas?: MatriculaCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateWithoutInstituicaoInput = {
    id?: bigint | number
    titulo: string
    descricao: string
    modalidade: $Enums.CourseModalityEnum
    nivel: $Enums.CourseLevelEnum
    cargaHorariaHoras: number
    localizacao?: string | null
    requisitos: string
    linkInscricao: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    categorias?: CursoCategoriaUncheckedCreateNestedManyWithoutCursoInput
    matriculas?: MatriculaUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoCreateOrConnectWithoutInstituicaoInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutInstituicaoInput, CursoUncheckedCreateWithoutInstituicaoInput>
  }

  export type CursoCreateManyInstituicaoInputEnvelope = {
    data: CursoCreateManyInstituicaoInput | CursoCreateManyInstituicaoInput[]
    skipDuplicates?: boolean
  }

  export type OportunidadeCreateWithoutInstituicaoInput = {
    id?: bigint | number
    titulo: string
    descricao: string
    requisitos: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    categoriaCursoRelacionada?: CategoriaCursoCreateNestedOneWithoutOportunidadesRelacionadasInput
    candidaturas?: CandidaturaCreateNestedManyWithoutOportunidadeInput
  }

  export type OportunidadeUncheckedCreateWithoutInstituicaoInput = {
    id?: bigint | number
    titulo: string
    descricao: string
    requisitos: string
    categoriaCursoRelacionadaId?: bigint | number | null
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    candidaturas?: CandidaturaUncheckedCreateNestedManyWithoutOportunidadeInput
  }

  export type OportunidadeCreateOrConnectWithoutInstituicaoInput = {
    where: OportunidadeWhereUniqueInput
    create: XOR<OportunidadeCreateWithoutInstituicaoInput, OportunidadeUncheckedCreateWithoutInstituicaoInput>
  }

  export type OportunidadeCreateManyInstituicaoInputEnvelope = {
    data: OportunidadeCreateManyInstituicaoInput | OportunidadeCreateManyInstituicaoInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutPerfilInstituicaoInput = {
    update: XOR<UsuarioUpdateWithoutPerfilInstituicaoInput, UsuarioUncheckedUpdateWithoutPerfilInstituicaoInput>
    create: XOR<UsuarioCreateWithoutPerfilInstituicaoInput, UsuarioUncheckedCreateWithoutPerfilInstituicaoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPerfilInstituicaoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPerfilInstituicaoInput, UsuarioUncheckedUpdateWithoutPerfilInstituicaoInput>
  }

  export type UsuarioUpdateWithoutPerfilInstituicaoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publicId?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: EnumUserTypeEnumFieldUpdateOperationsInput | $Enums.UserTypeEnum
    emailConfirmado?: BoolFieldUpdateOperationsInput | boolean
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    perfilEstudante?: PerfilEstudanteUpdateOneWithoutUsuarioNestedInput
    postagensBlog?: PostagemBlogUpdateManyWithoutAutorNestedInput
    matriculas?: MatriculaUpdateManyWithoutUsuarioNestedInput
    candidaturas?: CandidaturaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPerfilInstituicaoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publicId?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: EnumUserTypeEnumFieldUpdateOperationsInput | $Enums.UserTypeEnum
    emailConfirmado?: BoolFieldUpdateOperationsInput | boolean
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    perfilEstudante?: PerfilEstudanteUncheckedUpdateOneWithoutUsuarioNestedInput
    postagensBlog?: PostagemBlogUncheckedUpdateManyWithoutAutorNestedInput
    matriculas?: MatriculaUncheckedUpdateManyWithoutUsuarioNestedInput
    candidaturas?: CandidaturaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type CursoUpsertWithWhereUniqueWithoutInstituicaoInput = {
    where: CursoWhereUniqueInput
    update: XOR<CursoUpdateWithoutInstituicaoInput, CursoUncheckedUpdateWithoutInstituicaoInput>
    create: XOR<CursoCreateWithoutInstituicaoInput, CursoUncheckedCreateWithoutInstituicaoInput>
  }

  export type CursoUpdateWithWhereUniqueWithoutInstituicaoInput = {
    where: CursoWhereUniqueInput
    data: XOR<CursoUpdateWithoutInstituicaoInput, CursoUncheckedUpdateWithoutInstituicaoInput>
  }

  export type CursoUpdateManyWithWhereWithoutInstituicaoInput = {
    where: CursoScalarWhereInput
    data: XOR<CursoUpdateManyMutationInput, CursoUncheckedUpdateManyWithoutInstituicaoInput>
  }

  export type CursoScalarWhereInput = {
    AND?: CursoScalarWhereInput | CursoScalarWhereInput[]
    OR?: CursoScalarWhereInput[]
    NOT?: CursoScalarWhereInput | CursoScalarWhereInput[]
    id?: BigIntFilter<"Curso"> | bigint | number
    instituicaoId?: BigIntFilter<"Curso"> | bigint | number
    titulo?: StringFilter<"Curso"> | string
    descricao?: StringFilter<"Curso"> | string
    modalidade?: EnumCourseModalityEnumFilter<"Curso"> | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumFilter<"Curso"> | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntFilter<"Curso"> | number
    localizacao?: StringNullableFilter<"Curso"> | string | null
    requisitos?: StringFilter<"Curso"> | string
    linkInscricao?: StringFilter<"Curso"> | string
    estaAtivo?: BoolFilter<"Curso"> | boolean
    criadoEm?: DateTimeFilter<"Curso"> | Date | string
    atualizadoEm?: DateTimeFilter<"Curso"> | Date | string
  }

  export type OportunidadeUpsertWithWhereUniqueWithoutInstituicaoInput = {
    where: OportunidadeWhereUniqueInput
    update: XOR<OportunidadeUpdateWithoutInstituicaoInput, OportunidadeUncheckedUpdateWithoutInstituicaoInput>
    create: XOR<OportunidadeCreateWithoutInstituicaoInput, OportunidadeUncheckedCreateWithoutInstituicaoInput>
  }

  export type OportunidadeUpdateWithWhereUniqueWithoutInstituicaoInput = {
    where: OportunidadeWhereUniqueInput
    data: XOR<OportunidadeUpdateWithoutInstituicaoInput, OportunidadeUncheckedUpdateWithoutInstituicaoInput>
  }

  export type OportunidadeUpdateManyWithWhereWithoutInstituicaoInput = {
    where: OportunidadeScalarWhereInput
    data: XOR<OportunidadeUpdateManyMutationInput, OportunidadeUncheckedUpdateManyWithoutInstituicaoInput>
  }

  export type OportunidadeScalarWhereInput = {
    AND?: OportunidadeScalarWhereInput | OportunidadeScalarWhereInput[]
    OR?: OportunidadeScalarWhereInput[]
    NOT?: OportunidadeScalarWhereInput | OportunidadeScalarWhereInput[]
    id?: BigIntFilter<"Oportunidade"> | bigint | number
    instituicaoId?: BigIntFilter<"Oportunidade"> | bigint | number
    titulo?: StringFilter<"Oportunidade"> | string
    descricao?: StringFilter<"Oportunidade"> | string
    requisitos?: StringFilter<"Oportunidade"> | string
    categoriaCursoRelacionadaId?: BigIntNullableFilter<"Oportunidade"> | bigint | number | null
    estaAtivo?: BoolFilter<"Oportunidade"> | boolean
    criadoEm?: DateTimeFilter<"Oportunidade"> | Date | string
    atualizadoEm?: DateTimeFilter<"Oportunidade"> | Date | string
  }

  export type CursoCategoriaCreateWithoutCategoriaInput = {
    curso: CursoCreateNestedOneWithoutCategoriasInput
  }

  export type CursoCategoriaUncheckedCreateWithoutCategoriaInput = {
    cursoId: bigint | number
  }

  export type CursoCategoriaCreateOrConnectWithoutCategoriaInput = {
    where: CursoCategoriaWhereUniqueInput
    create: XOR<CursoCategoriaCreateWithoutCategoriaInput, CursoCategoriaUncheckedCreateWithoutCategoriaInput>
  }

  export type CursoCategoriaCreateManyCategoriaInputEnvelope = {
    data: CursoCategoriaCreateManyCategoriaInput | CursoCategoriaCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type OportunidadeCreateWithoutCategoriaCursoRelacionadaInput = {
    id?: bigint | number
    titulo: string
    descricao: string
    requisitos: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    instituicao: PerfilInstituicaoCreateNestedOneWithoutOportunidadesInput
    candidaturas?: CandidaturaCreateNestedManyWithoutOportunidadeInput
  }

  export type OportunidadeUncheckedCreateWithoutCategoriaCursoRelacionadaInput = {
    id?: bigint | number
    instituicaoId: bigint | number
    titulo: string
    descricao: string
    requisitos: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    candidaturas?: CandidaturaUncheckedCreateNestedManyWithoutOportunidadeInput
  }

  export type OportunidadeCreateOrConnectWithoutCategoriaCursoRelacionadaInput = {
    where: OportunidadeWhereUniqueInput
    create: XOR<OportunidadeCreateWithoutCategoriaCursoRelacionadaInput, OportunidadeUncheckedCreateWithoutCategoriaCursoRelacionadaInput>
  }

  export type OportunidadeCreateManyCategoriaCursoRelacionadaInputEnvelope = {
    data: OportunidadeCreateManyCategoriaCursoRelacionadaInput | OportunidadeCreateManyCategoriaCursoRelacionadaInput[]
    skipDuplicates?: boolean
  }

  export type CursoCategoriaUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: CursoCategoriaWhereUniqueInput
    update: XOR<CursoCategoriaUpdateWithoutCategoriaInput, CursoCategoriaUncheckedUpdateWithoutCategoriaInput>
    create: XOR<CursoCategoriaCreateWithoutCategoriaInput, CursoCategoriaUncheckedCreateWithoutCategoriaInput>
  }

  export type CursoCategoriaUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: CursoCategoriaWhereUniqueInput
    data: XOR<CursoCategoriaUpdateWithoutCategoriaInput, CursoCategoriaUncheckedUpdateWithoutCategoriaInput>
  }

  export type CursoCategoriaUpdateManyWithWhereWithoutCategoriaInput = {
    where: CursoCategoriaScalarWhereInput
    data: XOR<CursoCategoriaUpdateManyMutationInput, CursoCategoriaUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type CursoCategoriaScalarWhereInput = {
    AND?: CursoCategoriaScalarWhereInput | CursoCategoriaScalarWhereInput[]
    OR?: CursoCategoriaScalarWhereInput[]
    NOT?: CursoCategoriaScalarWhereInput | CursoCategoriaScalarWhereInput[]
    cursoId?: BigIntFilter<"CursoCategoria"> | bigint | number
    categoriaId?: BigIntFilter<"CursoCategoria"> | bigint | number
  }

  export type OportunidadeUpsertWithWhereUniqueWithoutCategoriaCursoRelacionadaInput = {
    where: OportunidadeWhereUniqueInput
    update: XOR<OportunidadeUpdateWithoutCategoriaCursoRelacionadaInput, OportunidadeUncheckedUpdateWithoutCategoriaCursoRelacionadaInput>
    create: XOR<OportunidadeCreateWithoutCategoriaCursoRelacionadaInput, OportunidadeUncheckedCreateWithoutCategoriaCursoRelacionadaInput>
  }

  export type OportunidadeUpdateWithWhereUniqueWithoutCategoriaCursoRelacionadaInput = {
    where: OportunidadeWhereUniqueInput
    data: XOR<OportunidadeUpdateWithoutCategoriaCursoRelacionadaInput, OportunidadeUncheckedUpdateWithoutCategoriaCursoRelacionadaInput>
  }

  export type OportunidadeUpdateManyWithWhereWithoutCategoriaCursoRelacionadaInput = {
    where: OportunidadeScalarWhereInput
    data: XOR<OportunidadeUpdateManyMutationInput, OportunidadeUncheckedUpdateManyWithoutCategoriaCursoRelacionadaInput>
  }

  export type PerfilInstituicaoCreateWithoutCursosInput = {
    id?: bigint | number
    nomeInstituicao: string
    descricao: string
    urlSite?: string | null
    urlLogo?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    usuario: UsuarioCreateNestedOneWithoutPerfilInstituicaoInput
    oportunidades?: OportunidadeCreateNestedManyWithoutInstituicaoInput
  }

  export type PerfilInstituicaoUncheckedCreateWithoutCursosInput = {
    id?: bigint | number
    usuarioId: bigint | number
    nomeInstituicao: string
    descricao: string
    urlSite?: string | null
    urlLogo?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    oportunidades?: OportunidadeUncheckedCreateNestedManyWithoutInstituicaoInput
  }

  export type PerfilInstituicaoCreateOrConnectWithoutCursosInput = {
    where: PerfilInstituicaoWhereUniqueInput
    create: XOR<PerfilInstituicaoCreateWithoutCursosInput, PerfilInstituicaoUncheckedCreateWithoutCursosInput>
  }

  export type CursoCategoriaCreateWithoutCursoInput = {
    categoria: CategoriaCursoCreateNestedOneWithoutCursosInput
  }

  export type CursoCategoriaUncheckedCreateWithoutCursoInput = {
    categoriaId: bigint | number
  }

  export type CursoCategoriaCreateOrConnectWithoutCursoInput = {
    where: CursoCategoriaWhereUniqueInput
    create: XOR<CursoCategoriaCreateWithoutCursoInput, CursoCategoriaUncheckedCreateWithoutCursoInput>
  }

  export type CursoCategoriaCreateManyCursoInputEnvelope = {
    data: CursoCategoriaCreateManyCursoInput | CursoCategoriaCreateManyCursoInput[]
    skipDuplicates?: boolean
  }

  export type MatriculaCreateWithoutCursoInput = {
    id?: bigint | number
    status?: string
    dataInscricao?: Date | string
    usuario: UsuarioCreateNestedOneWithoutMatriculasInput
  }

  export type MatriculaUncheckedCreateWithoutCursoInput = {
    id?: bigint | number
    usuarioId: bigint | number
    status?: string
    dataInscricao?: Date | string
  }

  export type MatriculaCreateOrConnectWithoutCursoInput = {
    where: MatriculaWhereUniqueInput
    create: XOR<MatriculaCreateWithoutCursoInput, MatriculaUncheckedCreateWithoutCursoInput>
  }

  export type MatriculaCreateManyCursoInputEnvelope = {
    data: MatriculaCreateManyCursoInput | MatriculaCreateManyCursoInput[]
    skipDuplicates?: boolean
  }

  export type PerfilInstituicaoUpsertWithoutCursosInput = {
    update: XOR<PerfilInstituicaoUpdateWithoutCursosInput, PerfilInstituicaoUncheckedUpdateWithoutCursosInput>
    create: XOR<PerfilInstituicaoCreateWithoutCursosInput, PerfilInstituicaoUncheckedCreateWithoutCursosInput>
    where?: PerfilInstituicaoWhereInput
  }

  export type PerfilInstituicaoUpdateToOneWithWhereWithoutCursosInput = {
    where?: PerfilInstituicaoWhereInput
    data: XOR<PerfilInstituicaoUpdateWithoutCursosInput, PerfilInstituicaoUncheckedUpdateWithoutCursosInput>
  }

  export type PerfilInstituicaoUpdateWithoutCursosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeInstituicao?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    urlSite?: NullableStringFieldUpdateOperationsInput | string | null
    urlLogo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutPerfilInstituicaoNestedInput
    oportunidades?: OportunidadeUpdateManyWithoutInstituicaoNestedInput
  }

  export type PerfilInstituicaoUncheckedUpdateWithoutCursosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usuarioId?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeInstituicao?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    urlSite?: NullableStringFieldUpdateOperationsInput | string | null
    urlLogo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    oportunidades?: OportunidadeUncheckedUpdateManyWithoutInstituicaoNestedInput
  }

  export type CursoCategoriaUpsertWithWhereUniqueWithoutCursoInput = {
    where: CursoCategoriaWhereUniqueInput
    update: XOR<CursoCategoriaUpdateWithoutCursoInput, CursoCategoriaUncheckedUpdateWithoutCursoInput>
    create: XOR<CursoCategoriaCreateWithoutCursoInput, CursoCategoriaUncheckedCreateWithoutCursoInput>
  }

  export type CursoCategoriaUpdateWithWhereUniqueWithoutCursoInput = {
    where: CursoCategoriaWhereUniqueInput
    data: XOR<CursoCategoriaUpdateWithoutCursoInput, CursoCategoriaUncheckedUpdateWithoutCursoInput>
  }

  export type CursoCategoriaUpdateManyWithWhereWithoutCursoInput = {
    where: CursoCategoriaScalarWhereInput
    data: XOR<CursoCategoriaUpdateManyMutationInput, CursoCategoriaUncheckedUpdateManyWithoutCursoInput>
  }

  export type MatriculaUpsertWithWhereUniqueWithoutCursoInput = {
    where: MatriculaWhereUniqueInput
    update: XOR<MatriculaUpdateWithoutCursoInput, MatriculaUncheckedUpdateWithoutCursoInput>
    create: XOR<MatriculaCreateWithoutCursoInput, MatriculaUncheckedCreateWithoutCursoInput>
  }

  export type MatriculaUpdateWithWhereUniqueWithoutCursoInput = {
    where: MatriculaWhereUniqueInput
    data: XOR<MatriculaUpdateWithoutCursoInput, MatriculaUncheckedUpdateWithoutCursoInput>
  }

  export type MatriculaUpdateManyWithWhereWithoutCursoInput = {
    where: MatriculaScalarWhereInput
    data: XOR<MatriculaUpdateManyMutationInput, MatriculaUncheckedUpdateManyWithoutCursoInput>
  }

  export type CursoCreateWithoutCategoriasInput = {
    id?: bigint | number
    titulo: string
    descricao: string
    modalidade: $Enums.CourseModalityEnum
    nivel: $Enums.CourseLevelEnum
    cargaHorariaHoras: number
    localizacao?: string | null
    requisitos: string
    linkInscricao: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    instituicao: PerfilInstituicaoCreateNestedOneWithoutCursosInput
    matriculas?: MatriculaCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateWithoutCategoriasInput = {
    id?: bigint | number
    instituicaoId: bigint | number
    titulo: string
    descricao: string
    modalidade: $Enums.CourseModalityEnum
    nivel: $Enums.CourseLevelEnum
    cargaHorariaHoras: number
    localizacao?: string | null
    requisitos: string
    linkInscricao: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    matriculas?: MatriculaUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoCreateOrConnectWithoutCategoriasInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutCategoriasInput, CursoUncheckedCreateWithoutCategoriasInput>
  }

  export type CategoriaCursoCreateWithoutCursosInput = {
    id?: bigint | number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    oportunidadesRelacionadas?: OportunidadeCreateNestedManyWithoutCategoriaCursoRelacionadaInput
  }

  export type CategoriaCursoUncheckedCreateWithoutCursosInput = {
    id?: bigint | number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    oportunidadesRelacionadas?: OportunidadeUncheckedCreateNestedManyWithoutCategoriaCursoRelacionadaInput
  }

  export type CategoriaCursoCreateOrConnectWithoutCursosInput = {
    where: CategoriaCursoWhereUniqueInput
    create: XOR<CategoriaCursoCreateWithoutCursosInput, CategoriaCursoUncheckedCreateWithoutCursosInput>
  }

  export type CursoUpsertWithoutCategoriasInput = {
    update: XOR<CursoUpdateWithoutCategoriasInput, CursoUncheckedUpdateWithoutCategoriasInput>
    create: XOR<CursoCreateWithoutCategoriasInput, CursoUncheckedCreateWithoutCategoriasInput>
    where?: CursoWhereInput
  }

  export type CursoUpdateToOneWithWhereWithoutCategoriasInput = {
    where?: CursoWhereInput
    data: XOR<CursoUpdateWithoutCategoriasInput, CursoUncheckedUpdateWithoutCategoriasInput>
  }

  export type CursoUpdateWithoutCategoriasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: EnumCourseModalityEnumFieldUpdateOperationsInput | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumFieldUpdateOperationsInput | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntFieldUpdateOperationsInput | number
    localizacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisitos?: StringFieldUpdateOperationsInput | string
    linkInscricao?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    instituicao?: PerfilInstituicaoUpdateOneRequiredWithoutCursosNestedInput
    matriculas?: MatriculaUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateWithoutCategoriasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instituicaoId?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: EnumCourseModalityEnumFieldUpdateOperationsInput | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumFieldUpdateOperationsInput | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntFieldUpdateOperationsInput | number
    localizacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisitos?: StringFieldUpdateOperationsInput | string
    linkInscricao?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    matriculas?: MatriculaUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type CategoriaCursoUpsertWithoutCursosInput = {
    update: XOR<CategoriaCursoUpdateWithoutCursosInput, CategoriaCursoUncheckedUpdateWithoutCursosInput>
    create: XOR<CategoriaCursoCreateWithoutCursosInput, CategoriaCursoUncheckedCreateWithoutCursosInput>
    where?: CategoriaCursoWhereInput
  }

  export type CategoriaCursoUpdateToOneWithWhereWithoutCursosInput = {
    where?: CategoriaCursoWhereInput
    data: XOR<CategoriaCursoUpdateWithoutCursosInput, CategoriaCursoUncheckedUpdateWithoutCursosInput>
  }

  export type CategoriaCursoUpdateWithoutCursosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    oportunidadesRelacionadas?: OportunidadeUpdateManyWithoutCategoriaCursoRelacionadaNestedInput
  }

  export type CategoriaCursoUncheckedUpdateWithoutCursosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    oportunidadesRelacionadas?: OportunidadeUncheckedUpdateManyWithoutCategoriaCursoRelacionadaNestedInput
  }

  export type PerfilInstituicaoCreateWithoutOportunidadesInput = {
    id?: bigint | number
    nomeInstituicao: string
    descricao: string
    urlSite?: string | null
    urlLogo?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    usuario: UsuarioCreateNestedOneWithoutPerfilInstituicaoInput
    cursos?: CursoCreateNestedManyWithoutInstituicaoInput
  }

  export type PerfilInstituicaoUncheckedCreateWithoutOportunidadesInput = {
    id?: bigint | number
    usuarioId: bigint | number
    nomeInstituicao: string
    descricao: string
    urlSite?: string | null
    urlLogo?: string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    cursos?: CursoUncheckedCreateNestedManyWithoutInstituicaoInput
  }

  export type PerfilInstituicaoCreateOrConnectWithoutOportunidadesInput = {
    where: PerfilInstituicaoWhereUniqueInput
    create: XOR<PerfilInstituicaoCreateWithoutOportunidadesInput, PerfilInstituicaoUncheckedCreateWithoutOportunidadesInput>
  }

  export type CategoriaCursoCreateWithoutOportunidadesRelacionadasInput = {
    id?: bigint | number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    cursos?: CursoCategoriaCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaCursoUncheckedCreateWithoutOportunidadesRelacionadasInput = {
    id?: bigint | number
    nome: string
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    cursos?: CursoCategoriaUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaCursoCreateOrConnectWithoutOportunidadesRelacionadasInput = {
    where: CategoriaCursoWhereUniqueInput
    create: XOR<CategoriaCursoCreateWithoutOportunidadesRelacionadasInput, CategoriaCursoUncheckedCreateWithoutOportunidadesRelacionadasInput>
  }

  export type CandidaturaCreateWithoutOportunidadeInput = {
    id?: bigint | number
    status?: string
    dataCandidatura?: Date | string
    usuario: UsuarioCreateNestedOneWithoutCandidaturasInput
  }

  export type CandidaturaUncheckedCreateWithoutOportunidadeInput = {
    id?: bigint | number
    usuarioId: bigint | number
    status?: string
    dataCandidatura?: Date | string
  }

  export type CandidaturaCreateOrConnectWithoutOportunidadeInput = {
    where: CandidaturaWhereUniqueInput
    create: XOR<CandidaturaCreateWithoutOportunidadeInput, CandidaturaUncheckedCreateWithoutOportunidadeInput>
  }

  export type CandidaturaCreateManyOportunidadeInputEnvelope = {
    data: CandidaturaCreateManyOportunidadeInput | CandidaturaCreateManyOportunidadeInput[]
    skipDuplicates?: boolean
  }

  export type PerfilInstituicaoUpsertWithoutOportunidadesInput = {
    update: XOR<PerfilInstituicaoUpdateWithoutOportunidadesInput, PerfilInstituicaoUncheckedUpdateWithoutOportunidadesInput>
    create: XOR<PerfilInstituicaoCreateWithoutOportunidadesInput, PerfilInstituicaoUncheckedCreateWithoutOportunidadesInput>
    where?: PerfilInstituicaoWhereInput
  }

  export type PerfilInstituicaoUpdateToOneWithWhereWithoutOportunidadesInput = {
    where?: PerfilInstituicaoWhereInput
    data: XOR<PerfilInstituicaoUpdateWithoutOportunidadesInput, PerfilInstituicaoUncheckedUpdateWithoutOportunidadesInput>
  }

  export type PerfilInstituicaoUpdateWithoutOportunidadesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeInstituicao?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    urlSite?: NullableStringFieldUpdateOperationsInput | string | null
    urlLogo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutPerfilInstituicaoNestedInput
    cursos?: CursoUpdateManyWithoutInstituicaoNestedInput
  }

  export type PerfilInstituicaoUncheckedUpdateWithoutOportunidadesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usuarioId?: BigIntFieldUpdateOperationsInput | bigint | number
    nomeInstituicao?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    urlSite?: NullableStringFieldUpdateOperationsInput | string | null
    urlLogo?: NullableStringFieldUpdateOperationsInput | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    cursos?: CursoUncheckedUpdateManyWithoutInstituicaoNestedInput
  }

  export type CategoriaCursoUpsertWithoutOportunidadesRelacionadasInput = {
    update: XOR<CategoriaCursoUpdateWithoutOportunidadesRelacionadasInput, CategoriaCursoUncheckedUpdateWithoutOportunidadesRelacionadasInput>
    create: XOR<CategoriaCursoCreateWithoutOportunidadesRelacionadasInput, CategoriaCursoUncheckedCreateWithoutOportunidadesRelacionadasInput>
    where?: CategoriaCursoWhereInput
  }

  export type CategoriaCursoUpdateToOneWithWhereWithoutOportunidadesRelacionadasInput = {
    where?: CategoriaCursoWhereInput
    data: XOR<CategoriaCursoUpdateWithoutOportunidadesRelacionadasInput, CategoriaCursoUncheckedUpdateWithoutOportunidadesRelacionadasInput>
  }

  export type CategoriaCursoUpdateWithoutOportunidadesRelacionadasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    cursos?: CursoCategoriaUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaCursoUncheckedUpdateWithoutOportunidadesRelacionadasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    nome?: StringFieldUpdateOperationsInput | string
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    cursos?: CursoCategoriaUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CandidaturaUpsertWithWhereUniqueWithoutOportunidadeInput = {
    where: CandidaturaWhereUniqueInput
    update: XOR<CandidaturaUpdateWithoutOportunidadeInput, CandidaturaUncheckedUpdateWithoutOportunidadeInput>
    create: XOR<CandidaturaCreateWithoutOportunidadeInput, CandidaturaUncheckedCreateWithoutOportunidadeInput>
  }

  export type CandidaturaUpdateWithWhereUniqueWithoutOportunidadeInput = {
    where: CandidaturaWhereUniqueInput
    data: XOR<CandidaturaUpdateWithoutOportunidadeInput, CandidaturaUncheckedUpdateWithoutOportunidadeInput>
  }

  export type CandidaturaUpdateManyWithWhereWithoutOportunidadeInput = {
    where: CandidaturaScalarWhereInput
    data: XOR<CandidaturaUpdateManyMutationInput, CandidaturaUncheckedUpdateManyWithoutOportunidadeInput>
  }

  export type UsuarioCreateWithoutPostagensBlogInput = {
    id?: bigint | number
    publicId?: string
    nomeCompleto: string
    email: string
    senha: string
    tipoUsuario: $Enums.UserTypeEnum
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    perfilEstudante?: PerfilEstudanteCreateNestedOneWithoutUsuarioInput
    perfilInstituicao?: PerfilInstituicaoCreateNestedOneWithoutUsuarioInput
    matriculas?: MatriculaCreateNestedManyWithoutUsuarioInput
    candidaturas?: CandidaturaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPostagensBlogInput = {
    id?: bigint | number
    publicId?: string
    nomeCompleto: string
    email: string
    senha: string
    tipoUsuario: $Enums.UserTypeEnum
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    perfilEstudante?: PerfilEstudanteUncheckedCreateNestedOneWithoutUsuarioInput
    perfilInstituicao?: PerfilInstituicaoUncheckedCreateNestedOneWithoutUsuarioInput
    matriculas?: MatriculaUncheckedCreateNestedManyWithoutUsuarioInput
    candidaturas?: CandidaturaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPostagensBlogInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPostagensBlogInput, UsuarioUncheckedCreateWithoutPostagensBlogInput>
  }

  export type UsuarioUpsertWithoutPostagensBlogInput = {
    update: XOR<UsuarioUpdateWithoutPostagensBlogInput, UsuarioUncheckedUpdateWithoutPostagensBlogInput>
    create: XOR<UsuarioCreateWithoutPostagensBlogInput, UsuarioUncheckedCreateWithoutPostagensBlogInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPostagensBlogInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPostagensBlogInput, UsuarioUncheckedUpdateWithoutPostagensBlogInput>
  }

  export type UsuarioUpdateWithoutPostagensBlogInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publicId?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: EnumUserTypeEnumFieldUpdateOperationsInput | $Enums.UserTypeEnum
    emailConfirmado?: BoolFieldUpdateOperationsInput | boolean
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    perfilEstudante?: PerfilEstudanteUpdateOneWithoutUsuarioNestedInput
    perfilInstituicao?: PerfilInstituicaoUpdateOneWithoutUsuarioNestedInput
    matriculas?: MatriculaUpdateManyWithoutUsuarioNestedInput
    candidaturas?: CandidaturaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPostagensBlogInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publicId?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: EnumUserTypeEnumFieldUpdateOperationsInput | $Enums.UserTypeEnum
    emailConfirmado?: BoolFieldUpdateOperationsInput | boolean
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    perfilEstudante?: PerfilEstudanteUncheckedUpdateOneWithoutUsuarioNestedInput
    perfilInstituicao?: PerfilInstituicaoUncheckedUpdateOneWithoutUsuarioNestedInput
    matriculas?: MatriculaUncheckedUpdateManyWithoutUsuarioNestedInput
    candidaturas?: CandidaturaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type CursoCreateWithoutMatriculasInput = {
    id?: bigint | number
    titulo: string
    descricao: string
    modalidade: $Enums.CourseModalityEnum
    nivel: $Enums.CourseLevelEnum
    cargaHorariaHoras: number
    localizacao?: string | null
    requisitos: string
    linkInscricao: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    instituicao: PerfilInstituicaoCreateNestedOneWithoutCursosInput
    categorias?: CursoCategoriaCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateWithoutMatriculasInput = {
    id?: bigint | number
    instituicaoId: bigint | number
    titulo: string
    descricao: string
    modalidade: $Enums.CourseModalityEnum
    nivel: $Enums.CourseLevelEnum
    cargaHorariaHoras: number
    localizacao?: string | null
    requisitos: string
    linkInscricao: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    categorias?: CursoCategoriaUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoCreateOrConnectWithoutMatriculasInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutMatriculasInput, CursoUncheckedCreateWithoutMatriculasInput>
  }

  export type UsuarioCreateWithoutMatriculasInput = {
    id?: bigint | number
    publicId?: string
    nomeCompleto: string
    email: string
    senha: string
    tipoUsuario: $Enums.UserTypeEnum
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    perfilEstudante?: PerfilEstudanteCreateNestedOneWithoutUsuarioInput
    perfilInstituicao?: PerfilInstituicaoCreateNestedOneWithoutUsuarioInput
    postagensBlog?: PostagemBlogCreateNestedManyWithoutAutorInput
    candidaturas?: CandidaturaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutMatriculasInput = {
    id?: bigint | number
    publicId?: string
    nomeCompleto: string
    email: string
    senha: string
    tipoUsuario: $Enums.UserTypeEnum
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    perfilEstudante?: PerfilEstudanteUncheckedCreateNestedOneWithoutUsuarioInput
    perfilInstituicao?: PerfilInstituicaoUncheckedCreateNestedOneWithoutUsuarioInput
    postagensBlog?: PostagemBlogUncheckedCreateNestedManyWithoutAutorInput
    candidaturas?: CandidaturaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutMatriculasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutMatriculasInput, UsuarioUncheckedCreateWithoutMatriculasInput>
  }

  export type CursoUpsertWithoutMatriculasInput = {
    update: XOR<CursoUpdateWithoutMatriculasInput, CursoUncheckedUpdateWithoutMatriculasInput>
    create: XOR<CursoCreateWithoutMatriculasInput, CursoUncheckedCreateWithoutMatriculasInput>
    where?: CursoWhereInput
  }

  export type CursoUpdateToOneWithWhereWithoutMatriculasInput = {
    where?: CursoWhereInput
    data: XOR<CursoUpdateWithoutMatriculasInput, CursoUncheckedUpdateWithoutMatriculasInput>
  }

  export type CursoUpdateWithoutMatriculasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: EnumCourseModalityEnumFieldUpdateOperationsInput | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumFieldUpdateOperationsInput | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntFieldUpdateOperationsInput | number
    localizacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisitos?: StringFieldUpdateOperationsInput | string
    linkInscricao?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    instituicao?: PerfilInstituicaoUpdateOneRequiredWithoutCursosNestedInput
    categorias?: CursoCategoriaUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateWithoutMatriculasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instituicaoId?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: EnumCourseModalityEnumFieldUpdateOperationsInput | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumFieldUpdateOperationsInput | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntFieldUpdateOperationsInput | number
    localizacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisitos?: StringFieldUpdateOperationsInput | string
    linkInscricao?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    categorias?: CursoCategoriaUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type UsuarioUpsertWithoutMatriculasInput = {
    update: XOR<UsuarioUpdateWithoutMatriculasInput, UsuarioUncheckedUpdateWithoutMatriculasInput>
    create: XOR<UsuarioCreateWithoutMatriculasInput, UsuarioUncheckedCreateWithoutMatriculasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutMatriculasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutMatriculasInput, UsuarioUncheckedUpdateWithoutMatriculasInput>
  }

  export type UsuarioUpdateWithoutMatriculasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publicId?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: EnumUserTypeEnumFieldUpdateOperationsInput | $Enums.UserTypeEnum
    emailConfirmado?: BoolFieldUpdateOperationsInput | boolean
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    perfilEstudante?: PerfilEstudanteUpdateOneWithoutUsuarioNestedInput
    perfilInstituicao?: PerfilInstituicaoUpdateOneWithoutUsuarioNestedInput
    postagensBlog?: PostagemBlogUpdateManyWithoutAutorNestedInput
    candidaturas?: CandidaturaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutMatriculasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publicId?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: EnumUserTypeEnumFieldUpdateOperationsInput | $Enums.UserTypeEnum
    emailConfirmado?: BoolFieldUpdateOperationsInput | boolean
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    perfilEstudante?: PerfilEstudanteUncheckedUpdateOneWithoutUsuarioNestedInput
    perfilInstituicao?: PerfilInstituicaoUncheckedUpdateOneWithoutUsuarioNestedInput
    postagensBlog?: PostagemBlogUncheckedUpdateManyWithoutAutorNestedInput
    candidaturas?: CandidaturaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type OportunidadeCreateWithoutCandidaturasInput = {
    id?: bigint | number
    titulo: string
    descricao: string
    requisitos: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    instituicao: PerfilInstituicaoCreateNestedOneWithoutOportunidadesInput
    categoriaCursoRelacionada?: CategoriaCursoCreateNestedOneWithoutOportunidadesRelacionadasInput
  }

  export type OportunidadeUncheckedCreateWithoutCandidaturasInput = {
    id?: bigint | number
    instituicaoId: bigint | number
    titulo: string
    descricao: string
    requisitos: string
    categoriaCursoRelacionadaId?: bigint | number | null
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type OportunidadeCreateOrConnectWithoutCandidaturasInput = {
    where: OportunidadeWhereUniqueInput
    create: XOR<OportunidadeCreateWithoutCandidaturasInput, OportunidadeUncheckedCreateWithoutCandidaturasInput>
  }

  export type UsuarioCreateWithoutCandidaturasInput = {
    id?: bigint | number
    publicId?: string
    nomeCompleto: string
    email: string
    senha: string
    tipoUsuario: $Enums.UserTypeEnum
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    perfilEstudante?: PerfilEstudanteCreateNestedOneWithoutUsuarioInput
    perfilInstituicao?: PerfilInstituicaoCreateNestedOneWithoutUsuarioInput
    postagensBlog?: PostagemBlogCreateNestedManyWithoutAutorInput
    matriculas?: MatriculaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutCandidaturasInput = {
    id?: bigint | number
    publicId?: string
    nomeCompleto: string
    email: string
    senha: string
    tipoUsuario: $Enums.UserTypeEnum
    emailConfirmado?: boolean
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    perfilEstudante?: PerfilEstudanteUncheckedCreateNestedOneWithoutUsuarioInput
    perfilInstituicao?: PerfilInstituicaoUncheckedCreateNestedOneWithoutUsuarioInput
    postagensBlog?: PostagemBlogUncheckedCreateNestedManyWithoutAutorInput
    matriculas?: MatriculaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutCandidaturasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutCandidaturasInput, UsuarioUncheckedCreateWithoutCandidaturasInput>
  }

  export type OportunidadeUpsertWithoutCandidaturasInput = {
    update: XOR<OportunidadeUpdateWithoutCandidaturasInput, OportunidadeUncheckedUpdateWithoutCandidaturasInput>
    create: XOR<OportunidadeCreateWithoutCandidaturasInput, OportunidadeUncheckedCreateWithoutCandidaturasInput>
    where?: OportunidadeWhereInput
  }

  export type OportunidadeUpdateToOneWithWhereWithoutCandidaturasInput = {
    where?: OportunidadeWhereInput
    data: XOR<OportunidadeUpdateWithoutCandidaturasInput, OportunidadeUncheckedUpdateWithoutCandidaturasInput>
  }

  export type OportunidadeUpdateWithoutCandidaturasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    requisitos?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    instituicao?: PerfilInstituicaoUpdateOneRequiredWithoutOportunidadesNestedInput
    categoriaCursoRelacionada?: CategoriaCursoUpdateOneWithoutOportunidadesRelacionadasNestedInput
  }

  export type OportunidadeUncheckedUpdateWithoutCandidaturasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instituicaoId?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    requisitos?: StringFieldUpdateOperationsInput | string
    categoriaCursoRelacionadaId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUpsertWithoutCandidaturasInput = {
    update: XOR<UsuarioUpdateWithoutCandidaturasInput, UsuarioUncheckedUpdateWithoutCandidaturasInput>
    create: XOR<UsuarioCreateWithoutCandidaturasInput, UsuarioUncheckedCreateWithoutCandidaturasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutCandidaturasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutCandidaturasInput, UsuarioUncheckedUpdateWithoutCandidaturasInput>
  }

  export type UsuarioUpdateWithoutCandidaturasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publicId?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: EnumUserTypeEnumFieldUpdateOperationsInput | $Enums.UserTypeEnum
    emailConfirmado?: BoolFieldUpdateOperationsInput | boolean
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    perfilEstudante?: PerfilEstudanteUpdateOneWithoutUsuarioNestedInput
    perfilInstituicao?: PerfilInstituicaoUpdateOneWithoutUsuarioNestedInput
    postagensBlog?: PostagemBlogUpdateManyWithoutAutorNestedInput
    matriculas?: MatriculaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutCandidaturasInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publicId?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipoUsuario?: EnumUserTypeEnumFieldUpdateOperationsInput | $Enums.UserTypeEnum
    emailConfirmado?: BoolFieldUpdateOperationsInput | boolean
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    perfilEstudante?: PerfilEstudanteUncheckedUpdateOneWithoutUsuarioNestedInput
    perfilInstituicao?: PerfilInstituicaoUncheckedUpdateOneWithoutUsuarioNestedInput
    postagensBlog?: PostagemBlogUncheckedUpdateManyWithoutAutorNestedInput
    matriculas?: MatriculaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type PostagemBlogCreateManyAutorInput = {
    id?: bigint | number
    titulo: string
    conteudo: string
    slug: string
    publicadoEm?: Date | string | null
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type MatriculaCreateManyUsuarioInput = {
    id?: bigint | number
    cursoId: bigint | number
    status?: string
    dataInscricao?: Date | string
  }

  export type CandidaturaCreateManyUsuarioInput = {
    id?: bigint | number
    oportunidadeId: bigint | number
    status?: string
    dataCandidatura?: Date | string
  }

  export type PostagemBlogUpdateWithoutAutorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    publicadoEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostagemBlogUncheckedUpdateWithoutAutorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    publicadoEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostagemBlogUncheckedUpdateManyWithoutAutorInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    publicadoEm?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatriculaUpdateWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataInscricao?: DateTimeFieldUpdateOperationsInput | Date | string
    curso?: CursoUpdateOneRequiredWithoutMatriculasNestedInput
  }

  export type MatriculaUncheckedUpdateWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cursoId?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataInscricao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatriculaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cursoId?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataInscricao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidaturaUpdateWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataCandidatura?: DateTimeFieldUpdateOperationsInput | Date | string
    oportunidade?: OportunidadeUpdateOneRequiredWithoutCandidaturasNestedInput
  }

  export type CandidaturaUncheckedUpdateWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    oportunidadeId?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataCandidatura?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidaturaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    oportunidadeId?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataCandidatura?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursoCreateManyInstituicaoInput = {
    id?: bigint | number
    titulo: string
    descricao: string
    modalidade: $Enums.CourseModalityEnum
    nivel: $Enums.CourseLevelEnum
    cargaHorariaHoras: number
    localizacao?: string | null
    requisitos: string
    linkInscricao: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type OportunidadeCreateManyInstituicaoInput = {
    id?: bigint | number
    titulo: string
    descricao: string
    requisitos: string
    categoriaCursoRelacionadaId?: bigint | number | null
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type CursoUpdateWithoutInstituicaoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: EnumCourseModalityEnumFieldUpdateOperationsInput | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumFieldUpdateOperationsInput | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntFieldUpdateOperationsInput | number
    localizacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisitos?: StringFieldUpdateOperationsInput | string
    linkInscricao?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    categorias?: CursoCategoriaUpdateManyWithoutCursoNestedInput
    matriculas?: MatriculaUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateWithoutInstituicaoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: EnumCourseModalityEnumFieldUpdateOperationsInput | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumFieldUpdateOperationsInput | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntFieldUpdateOperationsInput | number
    localizacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisitos?: StringFieldUpdateOperationsInput | string
    linkInscricao?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    categorias?: CursoCategoriaUncheckedUpdateManyWithoutCursoNestedInput
    matriculas?: MatriculaUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateManyWithoutInstituicaoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    modalidade?: EnumCourseModalityEnumFieldUpdateOperationsInput | $Enums.CourseModalityEnum
    nivel?: EnumCourseLevelEnumFieldUpdateOperationsInput | $Enums.CourseLevelEnum
    cargaHorariaHoras?: IntFieldUpdateOperationsInput | number
    localizacao?: NullableStringFieldUpdateOperationsInput | string | null
    requisitos?: StringFieldUpdateOperationsInput | string
    linkInscricao?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OportunidadeUpdateWithoutInstituicaoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    requisitos?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    categoriaCursoRelacionada?: CategoriaCursoUpdateOneWithoutOportunidadesRelacionadasNestedInput
    candidaturas?: CandidaturaUpdateManyWithoutOportunidadeNestedInput
  }

  export type OportunidadeUncheckedUpdateWithoutInstituicaoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    requisitos?: StringFieldUpdateOperationsInput | string
    categoriaCursoRelacionadaId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    candidaturas?: CandidaturaUncheckedUpdateManyWithoutOportunidadeNestedInput
  }

  export type OportunidadeUncheckedUpdateManyWithoutInstituicaoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    requisitos?: StringFieldUpdateOperationsInput | string
    categoriaCursoRelacionadaId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursoCategoriaCreateManyCategoriaInput = {
    cursoId: bigint | number
  }

  export type OportunidadeCreateManyCategoriaCursoRelacionadaInput = {
    id?: bigint | number
    instituicaoId: bigint | number
    titulo: string
    descricao: string
    requisitos: string
    estaAtivo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type CursoCategoriaUpdateWithoutCategoriaInput = {
    curso?: CursoUpdateOneRequiredWithoutCategoriasNestedInput
  }

  export type CursoCategoriaUncheckedUpdateWithoutCategoriaInput = {
    cursoId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CursoCategoriaUncheckedUpdateManyWithoutCategoriaInput = {
    cursoId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OportunidadeUpdateWithoutCategoriaCursoRelacionadaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    requisitos?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    instituicao?: PerfilInstituicaoUpdateOneRequiredWithoutOportunidadesNestedInput
    candidaturas?: CandidaturaUpdateManyWithoutOportunidadeNestedInput
  }

  export type OportunidadeUncheckedUpdateWithoutCategoriaCursoRelacionadaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instituicaoId?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    requisitos?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    candidaturas?: CandidaturaUncheckedUpdateManyWithoutOportunidadeNestedInput
  }

  export type OportunidadeUncheckedUpdateManyWithoutCategoriaCursoRelacionadaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    instituicaoId?: BigIntFieldUpdateOperationsInput | bigint | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    requisitos?: StringFieldUpdateOperationsInput | string
    estaAtivo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursoCategoriaCreateManyCursoInput = {
    categoriaId: bigint | number
  }

  export type MatriculaCreateManyCursoInput = {
    id?: bigint | number
    usuarioId: bigint | number
    status?: string
    dataInscricao?: Date | string
  }

  export type CursoCategoriaUpdateWithoutCursoInput = {
    categoria?: CategoriaCursoUpdateOneRequiredWithoutCursosNestedInput
  }

  export type CursoCategoriaUncheckedUpdateWithoutCursoInput = {
    categoriaId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CursoCategoriaUncheckedUpdateManyWithoutCursoInput = {
    categoriaId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MatriculaUpdateWithoutCursoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataInscricao?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutMatriculasNestedInput
  }

  export type MatriculaUncheckedUpdateWithoutCursoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usuarioId?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataInscricao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatriculaUncheckedUpdateManyWithoutCursoInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usuarioId?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataInscricao?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidaturaCreateManyOportunidadeInput = {
    id?: bigint | number
    usuarioId: bigint | number
    status?: string
    dataCandidatura?: Date | string
  }

  export type CandidaturaUpdateWithoutOportunidadeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataCandidatura?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutCandidaturasNestedInput
  }

  export type CandidaturaUncheckedUpdateWithoutOportunidadeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usuarioId?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataCandidatura?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CandidaturaUncheckedUpdateManyWithoutOportunidadeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usuarioId?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    dataCandidatura?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PerfilInstituicaoCountOutputTypeDefaultArgs instead
     */
    export type PerfilInstituicaoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PerfilInstituicaoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriaCursoCountOutputTypeDefaultArgs instead
     */
    export type CategoriaCursoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriaCursoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CursoCountOutputTypeDefaultArgs instead
     */
    export type CursoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CursoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OportunidadeCountOutputTypeDefaultArgs instead
     */
    export type OportunidadeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OportunidadeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PerfilEstudanteDefaultArgs instead
     */
    export type PerfilEstudanteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PerfilEstudanteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PerfilInstituicaoDefaultArgs instead
     */
    export type PerfilInstituicaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PerfilInstituicaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriaCursoDefaultArgs instead
     */
    export type CategoriaCursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriaCursoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CursoDefaultArgs instead
     */
    export type CursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CursoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CursoCategoriaDefaultArgs instead
     */
    export type CursoCategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CursoCategoriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OportunidadeDefaultArgs instead
     */
    export type OportunidadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OportunidadeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostagemBlogDefaultArgs instead
     */
    export type PostagemBlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostagemBlogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatriculaDefaultArgs instead
     */
    export type MatriculaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatriculaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CandidaturaDefaultArgs instead
     */
    export type CandidaturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CandidaturaDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}